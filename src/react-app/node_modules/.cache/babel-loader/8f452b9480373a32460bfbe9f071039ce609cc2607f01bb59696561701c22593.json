{"ast":null,"code":"/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as Stream from \"stream\";\nimport async from 'async';\nimport BlockStream2 from 'block-stream2';\nimport _ from 'lodash';\nimport * as querystring from 'query-string';\nimport { TextEncoder } from 'web-encoding';\nimport Xml from 'xml';\nimport xml2js from 'xml2js';\nimport * as errors from \"./errors.mjs\";\nimport { CopyDestinationOptions, CopySourceOptions, DEFAULT_REGION } from \"./helpers.mjs\";\nimport { callbackify } from \"./internal/callbackify.mjs\";\nimport { TypedClient } from \"./internal/client.mjs\";\nimport { CopyConditions } from \"./internal/copy-conditions.mjs\";\nimport { calculateEvenSplits, extractMetadata, getScope, getSourceVersionId, getVersionId, insertContentType, isBoolean, isFunction, isNumber, isObject, isReadableStream, isString, isValidBucketName, isValidDate, isValidObjectName, isValidPrefix, makeDateLong, PART_CONSTRAINTS, partsRequired, pipesetup, prependXAMZMeta, readableStream, sanitizeETag, toMd5, uriEscape, uriResourceEscape } from \"./internal/helper.mjs\";\nimport { PostPolicy } from \"./internal/post-policy.mjs\";\nimport { LEGAL_HOLD_STATUS, RETENTION_MODES, RETENTION_VALIDITY_UNITS } from \"./internal/type.mjs\";\nimport { NotificationConfig, NotificationPoller } from \"./notification.mjs\";\nimport { ObjectUploader } from \"./object-uploader.mjs\";\nimport { promisify } from \"./promisify.mjs\";\nimport { postPresignSignatureV4, presignSignatureV4 } from \"./signing.mjs\";\nimport * as transformers from \"./transformers.mjs\";\nimport { parseSelectObjectContentResponse } from \"./xml-parsers.mjs\";\nexport * from \"./helpers.mjs\";\nexport * from \"./notification.mjs\";\nexport { CopyConditions, PostPolicy };\nexport class Client extends TypedClient {\n  // Set application specific information.\n  //\n  // Generates User-Agent in the following style.\n  //\n  //       MinIO (OS; ARCH) LIB/VER APP/VER\n  //\n  // __Arguments__\n  // * `appName` _string_ - Application name.\n  // * `appVersion` _string_ - Application version.\n  setAppInfo(appName, appVersion) {\n    if (!isString(appName)) {\n      throw new TypeError(`Invalid appName: ${appName}`);\n    }\n    if (appName.trim() === '') {\n      throw new errors.InvalidArgumentError('Input appName cannot be empty.');\n    }\n    if (!isString(appVersion)) {\n      throw new TypeError(`Invalid appVersion: ${appVersion}`);\n    }\n    if (appVersion.trim() === '') {\n      throw new errors.InvalidArgumentError('Input appVersion cannot be empty.');\n    }\n    this.userAgent = `${this.userAgent} ${appName}/${appVersion}`;\n  }\n\n  // Calculate part size given the object size. Part size will be atleast this.partSize\n  calculatePartSize(size) {\n    if (!isNumber(size)) {\n      throw new TypeError('size should be of type \"number\"');\n    }\n    if (size > this.maxObjectSize) {\n      throw new TypeError(`size should not be more than ${this.maxObjectSize}`);\n    }\n    if (this.overRidePartSize) {\n      return this.partSize;\n    }\n    var partSize = this.partSize;\n    for (;;) {\n      // while(true) {...} throws linting error.\n      // If partSize is big enough to accomodate the object size, then use it.\n      if (partSize * 10000 > size) {\n        return partSize;\n      }\n      // Try part sizes as 64MB, 80MB, 96MB etc.\n      partSize += 16 * 1024 * 1024;\n    }\n  }\n\n  // Creates the bucket `bucketName`.\n  //\n  // __Arguments__\n  // * `bucketName` _string_ - Name of the bucket\n  // * `region` _string_ - region valid values are _us-west-1_, _us-west-2_,  _eu-west-1_, _eu-central-1_, _ap-southeast-1_, _ap-northeast-1_, _ap-southeast-2_, _sa-east-1_.\n  // * `makeOpts` _object_ - Options to create a bucket. e.g {ObjectLocking:true} (Optional)\n  // * `callback(err)` _function_ - callback function with `err` as the error argument. `err` is null if the bucket is successfully created.\n  makeBucket(bucketName, region, makeOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    // Backward Compatibility\n    if (isObject(region)) {\n      cb = makeOpts;\n      makeOpts = region;\n      region = '';\n    }\n    if (isFunction(region)) {\n      cb = region;\n      region = '';\n      makeOpts = {};\n    }\n    if (isFunction(makeOpts)) {\n      cb = makeOpts;\n      makeOpts = {};\n    }\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"');\n    }\n    if (!isObject(makeOpts)) {\n      throw new TypeError('makeOpts should be of type \"object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var payload = '';\n\n    // Region already set in constructor, validate if\n    // caller requested bucket location is same.\n    if (region && this.region) {\n      if (region !== this.region) {\n        throw new errors.InvalidArgumentError(`Configured region ${this.region}, requested ${region}`);\n      }\n    }\n    // sending makeBucket request with XML containing 'us-east-1' fails. For\n    // default region server expects the request without body\n    if (region && region !== DEFAULT_REGION) {\n      var createBucketConfiguration = [];\n      createBucketConfiguration.push({\n        _attr: {\n          xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/'\n        }\n      });\n      createBucketConfiguration.push({\n        LocationConstraint: region\n      });\n      var payloadObject = {\n        CreateBucketConfiguration: createBucketConfiguration\n      };\n      payload = Xml(payloadObject);\n    }\n    var method = 'PUT';\n    var headers = {};\n    if (makeOpts.ObjectLocking) {\n      headers['x-amz-bucket-object-lock-enabled'] = true;\n    }\n    if (!region) {\n      region = DEFAULT_REGION;\n    }\n    const processWithRetry = err => {\n      if (err && (region === '' || region === DEFAULT_REGION)) {\n        if (err.code === 'AuthorizationHeaderMalformed' && err.region !== '') {\n          // Retry with region returned as part of error\n          this.makeRequest({\n            method,\n            bucketName,\n            headers\n          }, payload, [200], err.region, false, cb);\n        } else {\n          return cb && cb(err);\n        }\n      }\n      return cb && cb(err);\n    };\n    this.makeRequest({\n      method,\n      bucketName,\n      headers\n    }, payload, [200], region, false, processWithRetry);\n  }\n\n  // Returns a stream that emits objects that are partially uploaded.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: prefix of the object names that are partially uploaded (optional, default `''`)\n  // * `recursive` _bool_: directory style listing when false, recursive listing when true (optional, default `false`)\n  //\n  // __Return Value__\n  // * `stream` _Stream_ : emits objects of the format:\n  //   * `object.key` _string_: name of the object\n  //   * `object.uploadId` _string_: upload ID of the object\n  //   * `object.size` _Integer_: size of the partially uploaded object\n  listIncompleteUploads(bucket, prefix, recursive) {\n    if (prefix === undefined) {\n      prefix = '';\n    }\n    if (recursive === undefined) {\n      recursive = false;\n    }\n    if (!isValidBucketName(bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucket);\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`);\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"');\n    }\n    var delimiter = recursive ? '' : '/';\n    var keyMarker = '';\n    var uploadIdMarker = '';\n    var uploads = [];\n    var ended = false;\n    var readStream = Stream.Readable({\n      objectMode: true\n    });\n    readStream._read = () => {\n      // push one upload info per _read()\n      if (uploads.length) {\n        return readStream.push(uploads.shift());\n      }\n      if (ended) {\n        return readStream.push(null);\n      }\n      this.listIncompleteUploadsQuery(bucket, prefix, keyMarker, uploadIdMarker, delimiter).on('error', e => readStream.emit('error', e)).on('data', result => {\n        result.prefixes.forEach(prefix => uploads.push(prefix));\n        async.eachSeries(result.uploads, (upload, cb) => {\n          // for each incomplete upload add the sizes of its uploaded parts\n          this.listParts(bucket, upload.key, upload.uploadId).then(parts => {\n            upload.size = parts.reduce((acc, item) => acc + item.size, 0);\n            uploads.push(upload);\n            cb();\n          }, cb);\n        }, err => {\n          if (err) {\n            readStream.emit('error', err);\n            return;\n          }\n          if (result.isTruncated) {\n            keyMarker = result.nextKeyMarker;\n            uploadIdMarker = result.nextUploadIdMarker;\n          } else {\n            ended = true;\n          }\n          readStream._read();\n        });\n      });\n    };\n    return readStream;\n  }\n\n  // To check if a bucket already exists.\n  //\n  // __Arguments__\n  // * `bucketName` _string_ : name of the bucket\n  // * `callback(err)` _function_ : `err` is `null` if the bucket exists\n  bucketExists(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var method = 'HEAD';\n    this.makeRequest({\n      method,\n      bucketName\n    }, '', [200], '', false, err => {\n      if (err) {\n        if (err.code == 'NoSuchBucket' || err.code == 'NotFound') {\n          return cb(null, false);\n        }\n        return cb(err);\n      }\n      cb(null, true);\n    });\n  }\n\n  // Remove the partially uploaded object.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `callback(err)` _function_: callback function is called with non `null` value in case of error\n  removeIncompleteUpload(bucketName, objectName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.IsValidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var removeUploadId;\n    async.during(cb => {\n      this.findUploadId(bucketName, objectName, (e, uploadId) => {\n        if (e) {\n          return cb(e);\n        }\n        removeUploadId = uploadId;\n        cb(null, uploadId);\n      });\n    }, cb => {\n      var method = 'DELETE';\n      var query = `uploadId=${removeUploadId}`;\n      this.makeRequest({\n        method,\n        bucketName,\n        objectName,\n        query\n      }, '', [204], '', false, e => cb(e));\n    }, cb);\n  }\n\n  // Callback is called with `error` in case of error or `null` in case of success\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `filePath` _string_: path to which the object data will be written to\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err)` _function_: callback is called with `err` in case of error.\n  fGetObject(bucketName, objectName, filePath, getOpts = {}, cb) {\n    // Input validation.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(filePath)) {\n      throw new TypeError('filePath should be of type \"string\"');\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts;\n      getOpts = {};\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n\n    // Internal data.\n    var partFile;\n    var partFileStream;\n    var objStat;\n\n    // Rename wrapper.\n    var rename = err => {\n      if (err) {\n        return cb(err);\n      }\n      fs.rename(partFile, filePath, cb);\n    };\n    async.waterfall([cb => this.statObject(bucketName, objectName, getOpts, cb), (result, cb) => {\n      objStat = result;\n      // Create any missing top level directories.\n      fs.mkdir(path.dirname(filePath), {\n        recursive: true\n      }, err => cb(err));\n    }, cb => {\n      partFile = `${filePath}.${objStat.etag}.part.minio`;\n      fs.stat(partFile, (e, stats) => {\n        var offset = 0;\n        if (e) {\n          partFileStream = fs.createWriteStream(partFile, {\n            flags: 'w'\n          });\n        } else {\n          if (objStat.size === stats.size) {\n            return rename();\n          }\n          offset = stats.size;\n          partFileStream = fs.createWriteStream(partFile, {\n            flags: 'a'\n          });\n        }\n        this.getPartialObject(bucketName, objectName, offset, 0, getOpts, cb);\n      });\n    }, (downloadStream, cb) => {\n      pipesetup(downloadStream, partFileStream).on('error', e => cb(e)).on('finish', cb);\n    }, cb => fs.stat(partFile, cb), (stats, cb) => {\n      if (stats.size === objStat.size) {\n        return cb();\n      }\n      cb(new Error('Size mismatch between downloaded file and the object'));\n    }], rename);\n  }\n\n  // Callback is called with readable stream of the object content.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  getObject(bucketName, objectName, getOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts;\n      getOpts = {};\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    this.getPartialObject(bucketName, objectName, 0, 0, getOpts, cb);\n  }\n\n  // Callback is called with readable stream of the partial object content.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `offset` _number_: offset of the object from where the stream will start\n  // * `length` _number_: length of the object that will be read in the stream (optional, if not specified we read the rest of the file from the offset)\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  getPartialObject(bucketName, objectName, offset, length, getOpts = {}, cb) {\n    if (isFunction(length)) {\n      cb = length;\n      length = 0;\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isNumber(offset)) {\n      throw new TypeError('offset should be of type \"number\"');\n    }\n    if (!isNumber(length)) {\n      throw new TypeError('length should be of type \"number\"');\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts;\n      getOpts = {};\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var range = '';\n    if (offset || length) {\n      if (offset) {\n        range = `bytes=${+offset}-`;\n      } else {\n        range = 'bytes=0-';\n        offset = 0;\n      }\n      if (length) {\n        range += `${+length + offset - 1}`;\n      }\n    }\n    var headers = {};\n    if (range !== '') {\n      headers.range = range;\n    }\n    var expectedStatusCodes = [200];\n    if (range) {\n      expectedStatusCodes.push(206);\n    }\n    var method = 'GET';\n    var query = querystring.stringify(getOpts);\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      headers,\n      query\n    }, '', expectedStatusCodes, '', true, cb);\n  }\n\n  // Uploads the object using contents from a file\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `filePath` _string_: file path of the file to be uploaded\n  // * `metaData` _Javascript Object_: metaData assosciated with the object\n  // * `callback(err, objInfo)` _function_: non null `err` indicates error, `objInfo` _object_ which contains versionId and etag.\n  fPutObject(bucketName, objectName, filePath, metaData, callback) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(filePath)) {\n      throw new TypeError('filePath should be of type \"string\"');\n    }\n    if (isFunction(metaData)) {\n      callback = metaData;\n      metaData = {}; // Set metaData empty if no metaData provided.\n    }\n    if (!isObject(metaData)) {\n      throw new TypeError('metaData should be of type \"object\"');\n    }\n\n    // Inserts correct `content-type` attribute based on metaData and filePath\n    metaData = insertContentType(metaData, filePath);\n    fs.lstat(filePath, (err, stat) => {\n      if (err) {\n        return callback(err);\n      }\n      return this.putObject(bucketName, objectName, fs.createReadStream(filePath), stat.size, metaData, callback);\n    });\n  }\n\n  // Uploads the object.\n  //\n  // Uploading a stream\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `stream` _Stream_: Readable stream\n  // * `size` _number_: size of the object (optional)\n  // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.\n  //\n  // Uploading \"Buffer\" or \"string\"\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `string or Buffer` _string_ or _Buffer_: string or buffer\n  // * `callback(err, objInfo)` _function_: `err` is `null` in case of success and `info` will have the following object details:\n  //   * `etag` _string_: etag of the object\n  //   * `versionId` _string_: versionId of the object\n  putObject(bucketName, objectName, stream, size, metaData, callback) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n\n    // We'll need to shift arguments to the left because of size and metaData.\n    if (isFunction(size)) {\n      callback = size;\n      metaData = {};\n    } else if (isFunction(metaData)) {\n      callback = metaData;\n      metaData = {};\n    }\n\n    // We'll need to shift arguments to the left because of metaData\n    // and size being optional.\n    if (isObject(size)) {\n      metaData = size;\n    }\n\n    // Ensures Metadata has appropriate prefix for A3 API\n    metaData = prependXAMZMeta(metaData);\n    if (typeof stream === 'string' || stream instanceof Buffer) {\n      // Adapts the non-stream interface into a stream.\n      size = stream.length;\n      stream = readableStream(stream);\n    } else if (!isReadableStream(stream)) {\n      throw new TypeError('third argument should be of type \"stream.Readable\" or \"Buffer\" or \"string\"');\n    }\n    if (!isFunction(callback)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    if (isNumber(size) && size < 0) {\n      throw new errors.InvalidArgumentError(`size cannot be negative, given size: ${size}`);\n    }\n\n    // Get the part size and forward that to the BlockStream. Default to the\n    // largest block size possible if necessary.\n    if (!isNumber(size)) {\n      size = this.maxObjectSize;\n    }\n    size = this.calculatePartSize(size);\n\n    // s3 requires that all non-end chunks be at least `this.partSize`,\n    // so we chunk the stream until we hit either that size or the end before\n    // we flush it to s3.\n    let chunker = new BlockStream2({\n      size,\n      zeroPadding: false\n    });\n\n    // This is a Writable stream that can be written to in order to upload\n    // to the specified bucket and object automatically.\n    let uploader = new ObjectUploader(this, bucketName, objectName, size, metaData, callback);\n    // stream => chunker => uploader\n    pipesetup(stream, chunker, uploader);\n  }\n\n  // Copy the object.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `srcObject` _string_: path of the source object to be copied\n  // * `conditions` _CopyConditions_: copy conditions that needs to be satisfied (optional, default `null`)\n  // * `callback(err, {etag, lastModified})` _function_: non null `err` indicates error, `etag` _string_ and `listModifed` _Date_ are respectively the etag and the last modified date of the newly copied object\n  copyObjectV1(arg1, arg2, arg3, arg4, arg5) {\n    var bucketName = arg1;\n    var objectName = arg2;\n    var srcObject = arg3;\n    var conditions, cb;\n    if (typeof arg4 == 'function' && arg5 === undefined) {\n      conditions = null;\n      cb = arg4;\n    } else {\n      conditions = arg4;\n      cb = arg5;\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(srcObject)) {\n      throw new TypeError('srcObject should be of type \"string\"');\n    }\n    if (srcObject === '') {\n      throw new errors.InvalidPrefixError(`Empty source prefix`);\n    }\n    if (conditions !== null && !(conditions instanceof CopyConditions)) {\n      throw new TypeError('conditions should be of type \"CopyConditions\"');\n    }\n    var headers = {};\n    headers['x-amz-copy-source'] = uriResourceEscape(srcObject);\n    if (conditions !== null) {\n      if (conditions.modified !== '') {\n        headers['x-amz-copy-source-if-modified-since'] = conditions.modified;\n      }\n      if (conditions.unmodified !== '') {\n        headers['x-amz-copy-source-if-unmodified-since'] = conditions.unmodified;\n      }\n      if (conditions.matchETag !== '') {\n        headers['x-amz-copy-source-if-match'] = conditions.matchETag;\n      }\n      if (conditions.matchEtagExcept !== '') {\n        headers['x-amz-copy-source-if-none-match'] = conditions.matchETagExcept;\n      }\n    }\n    var method = 'PUT';\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      headers\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      var transformer = transformers.getCopyObjectTransformer();\n      pipesetup(response, transformer).on('error', e => cb(e)).on('data', data => cb(null, data));\n    });\n  }\n\n  /**\n   * Internal Method to perform copy of an object.\n   * @param sourceConfig __object__   instance of CopySourceOptions @link ./helpers/CopySourceOptions\n   * @param destConfig  __object__   instance of CopyDestinationOptions @link ./helpers/CopyDestinationOptions\n   * @param cb __function__ called with null if there is an error\n   * @returns Promise if no callack is passed.\n   */\n  copyObjectV2(sourceConfig, destConfig, cb) {\n    if (!(sourceConfig instanceof CopySourceOptions)) {\n      throw new errors.InvalidArgumentError('sourceConfig should of type CopySourceOptions ');\n    }\n    if (!(destConfig instanceof CopyDestinationOptions)) {\n      throw new errors.InvalidArgumentError('destConfig should of type CopyDestinationOptions ');\n    }\n    if (!destConfig.validate()) {\n      return false;\n    }\n    if (!destConfig.validate()) {\n      return false;\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    const headers = Object.assign({}, sourceConfig.getHeaders(), destConfig.getHeaders());\n    const bucketName = destConfig.Bucket;\n    const objectName = destConfig.Object;\n    const method = 'PUT';\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      headers\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      const transformer = transformers.getCopyObjectTransformer();\n      pipesetup(response, transformer).on('error', e => cb(e)).on('data', data => {\n        const resHeaders = response.headers;\n        const copyObjResponse = {\n          Bucket: destConfig.Bucket,\n          Key: destConfig.Object,\n          LastModified: data.LastModified,\n          MetaData: extractMetadata(resHeaders),\n          VersionId: getVersionId(resHeaders),\n          SourceVersionId: getSourceVersionId(resHeaders),\n          Etag: sanitizeETag(resHeaders.etag),\n          Size: +resHeaders['content-length']\n        };\n        return cb(null, copyObjResponse);\n      });\n    });\n  }\n\n  // Backward compatibility for Copy Object API.\n  copyObject(...allArgs) {\n    if (allArgs[0] instanceof CopySourceOptions && allArgs[1] instanceof CopyDestinationOptions) {\n      return this.copyObjectV2(...arguments);\n    }\n    return this.copyObjectV1(...arguments);\n  }\n\n  // list a batch of objects\n  listObjectsQuery(bucketName, prefix, marker, listQueryOpts = {}) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isString(marker)) {\n      throw new TypeError('marker should be of type \"string\"');\n    }\n    let {\n      Delimiter,\n      MaxKeys,\n      IncludeVersion\n    } = listQueryOpts;\n    if (!isObject(listQueryOpts)) {\n      throw new TypeError('listQueryOpts should be of type \"object\"');\n    }\n    if (!isString(Delimiter)) {\n      throw new TypeError('Delimiter should be of type \"string\"');\n    }\n    if (!isNumber(MaxKeys)) {\n      throw new TypeError('MaxKeys should be of type \"number\"');\n    }\n    const queries = [];\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`);\n    queries.push(`delimiter=${uriEscape(Delimiter)}`);\n    queries.push(`encoding-type=url`);\n    if (IncludeVersion) {\n      queries.push(`versions`);\n    }\n    if (marker) {\n      marker = uriEscape(marker);\n      if (IncludeVersion) {\n        queries.push(`key-marker=${marker}`);\n      } else {\n        queries.push(`marker=${marker}`);\n      }\n    }\n\n    // no need to escape maxKeys\n    if (MaxKeys) {\n      if (MaxKeys >= 1000) {\n        MaxKeys = 1000;\n      }\n      queries.push(`max-keys=${MaxKeys}`);\n    }\n    queries.sort();\n    var query = '';\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`;\n    }\n    var method = 'GET';\n    var transformer = transformers.getListObjectsTransformer();\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e);\n      }\n      pipesetup(response, transformer);\n    });\n    return transformer;\n  }\n\n  // List the objects in the bucket.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n  // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n  // * `listOpts _object_: query params to list object with below keys\n  // *    listOpts.MaxKeys _int_ maximum number of keys to return\n  // *    listOpts.IncludeVersion  _bool_ true|false to include versions.\n  // __Return Value__\n  // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n  // * `obj.name` _string_: name of the object\n  // * `obj.prefix` _string_: name of the object prefix\n  // * `obj.size` _number_: size of the object\n  // * `obj.etag` _string_: etag of the object\n  // * `obj.lastModified` _Date_: modified time stamp\n  // * `obj.isDeleteMarker` _boolean_: true if it is a delete marker\n  // * `obj.versionId` _string_: versionId of the object\n  listObjects(bucketName, prefix, recursive, listOpts = {}) {\n    if (prefix === undefined) {\n      prefix = '';\n    }\n    if (recursive === undefined) {\n      recursive = false;\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"');\n    }\n    if (!isObject(listOpts)) {\n      throw new TypeError('listOpts should be of type \"object\"');\n    }\n    var marker = '';\n    const listQueryOpts = {\n      Delimiter: recursive ? '' : '/',\n      // if recursive is false set delimiter to '/'\n      MaxKeys: 1000,\n      IncludeVersion: listOpts.IncludeVersion\n    };\n    var objects = [];\n    var ended = false;\n    var readStream = Stream.Readable({\n      objectMode: true\n    });\n    readStream._read = () => {\n      // push one object per _read()\n      if (objects.length) {\n        readStream.push(objects.shift());\n        return;\n      }\n      if (ended) {\n        return readStream.push(null);\n      }\n      // if there are no objects to push do query for the next batch of objects\n      this.listObjectsQuery(bucketName, prefix, marker, listQueryOpts).on('error', e => readStream.emit('error', e)).on('data', result => {\n        if (result.isTruncated) {\n          marker = result.nextMarker || result.versionIdMarker;\n        } else {\n          ended = true;\n        }\n        objects = result.objects;\n        readStream._read();\n      });\n    };\n    return readStream;\n  }\n\n  // listObjectsV2Query - (List Objects V2) - List some or all (up to 1000) of the objects in a bucket.\n  //\n  // You can use the request parameters as selection criteria to return a subset of the objects in a bucket.\n  // request parameters :-\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: Limits the response to keys that begin with the specified prefix.\n  // * `continuation-token` _string_: Used to continue iterating over a set of objects.\n  // * `delimiter` _string_: A delimiter is a character you use to group keys.\n  // * `max-keys` _number_: Sets the maximum number of keys returned in the response body.\n  // * `start-after` _string_: Specifies the key to start after when listing objects in a bucket.\n  listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, maxKeys, startAfter) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isString(continuationToken)) {\n      throw new TypeError('continuationToken should be of type \"string\"');\n    }\n    if (!isString(delimiter)) {\n      throw new TypeError('delimiter should be of type \"string\"');\n    }\n    if (!isNumber(maxKeys)) {\n      throw new TypeError('maxKeys should be of type \"number\"');\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"');\n    }\n    var queries = [];\n\n    // Call for listing objects v2 API\n    queries.push(`list-type=2`);\n    queries.push(`encoding-type=url`);\n\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`);\n    queries.push(`delimiter=${uriEscape(delimiter)}`);\n    if (continuationToken) {\n      continuationToken = uriEscape(continuationToken);\n      queries.push(`continuation-token=${continuationToken}`);\n    }\n    // Set start-after\n    if (startAfter) {\n      startAfter = uriEscape(startAfter);\n      queries.push(`start-after=${startAfter}`);\n    }\n    // no need to escape maxKeys\n    if (maxKeys) {\n      if (maxKeys >= 1000) {\n        maxKeys = 1000;\n      }\n      queries.push(`max-keys=${maxKeys}`);\n    }\n    queries.sort();\n    var query = '';\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`;\n    }\n    var method = 'GET';\n    var transformer = transformers.getListObjectsV2Transformer();\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e);\n      }\n      pipesetup(response, transformer);\n    });\n    return transformer;\n  }\n\n  // List the objects in the bucket using S3 ListObjects V2\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n  // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n  // * `startAfter` _string_: Specifies the key to start after when listing objects in a bucket. (optional, default `''`)\n  //\n  // __Return Value__\n  // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n  //   * `obj.name` _string_: name of the object\n  //   * `obj.prefix` _string_: name of the object prefix\n  //   * `obj.size` _number_: size of the object\n  //   * `obj.etag` _string_: etag of the object\n  //   * `obj.lastModified` _Date_: modified time stamp\n  listObjectsV2(bucketName, prefix, recursive, startAfter) {\n    if (prefix === undefined) {\n      prefix = '';\n    }\n    if (recursive === undefined) {\n      recursive = false;\n    }\n    if (startAfter === undefined) {\n      startAfter = '';\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"');\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"');\n    }\n    // if recursive is false set delimiter to '/'\n    var delimiter = recursive ? '' : '/';\n    var continuationToken = '';\n    var objects = [];\n    var ended = false;\n    var readStream = Stream.Readable({\n      objectMode: true\n    });\n    readStream._read = () => {\n      // push one object per _read()\n      if (objects.length) {\n        readStream.push(objects.shift());\n        return;\n      }\n      if (ended) {\n        return readStream.push(null);\n      }\n      // if there are no objects to push do query for the next batch of objects\n      this.listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, 1000, startAfter).on('error', e => readStream.emit('error', e)).on('data', result => {\n        if (result.isTruncated) {\n          continuationToken = result.nextContinuationToken;\n        } else {\n          ended = true;\n        }\n        objects = result.objects;\n        readStream._read();\n      });\n    };\n    return readStream;\n  }\n\n  // Remove all the objects residing in the objectsList.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectsList` _array_: array of objects of one of the following:\n  // *         List of Object names as array of strings which are object keys:  ['objectname1','objectname2']\n  // *         List of Object name and versionId as an object:  [{name:\"objectname\",versionId:\"my-version-id\"}]\n\n  removeObjects(bucketName, objectsList, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!Array.isArray(objectsList)) {\n      throw new errors.InvalidArgumentError('objectsList should be a list');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    const maxEntries = 1000;\n    const query = 'delete';\n    const method = 'POST';\n    let result = objectsList.reduce((result, entry) => {\n      result.list.push(entry);\n      if (result.list.length === maxEntries) {\n        result.listOfList.push(result.list);\n        result.list = [];\n      }\n      return result;\n    }, {\n      listOfList: [],\n      list: []\n    });\n    if (result.list.length > 0) {\n      result.listOfList.push(result.list);\n    }\n    const encoder = new TextEncoder();\n    const batchResults = [];\n    async.eachSeries(result.listOfList, (list, batchCb) => {\n      var objects = [];\n      list.forEach(function (value) {\n        if (isObject(value)) {\n          objects.push({\n            Key: value.name,\n            VersionId: value.versionId\n          });\n        } else {\n          objects.push({\n            Key: value\n          });\n        }\n      });\n      let deleteObjects = {\n        Delete: {\n          Quiet: true,\n          Object: objects\n        }\n      };\n      const builder = new xml2js.Builder({\n        headless: true\n      });\n      let payload = builder.buildObject(deleteObjects);\n      payload = Buffer.from(encoder.encode(payload));\n      const headers = {};\n      headers['Content-MD5'] = toMd5(payload);\n      let removeObjectsResult;\n      this.makeRequest({\n        method,\n        bucketName,\n        query,\n        headers\n      }, payload, [200], '', true, (e, response) => {\n        if (e) {\n          return batchCb(e);\n        }\n        pipesetup(response, transformers.removeObjectsTransformer()).on('data', data => {\n          removeObjectsResult = data;\n        }).on('error', e => {\n          return batchCb(e, null);\n        }).on('end', () => {\n          batchResults.push(removeObjectsResult);\n          return batchCb(null, removeObjectsResult);\n        });\n      });\n    }, () => {\n      cb(null, _.flatten(batchResults));\n    });\n  }\n\n  // Get the policy on a bucket or an object prefix.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `callback(err, policy)` _function_: callback function\n  getBucketPolicy(bucketName, cb) {\n    // Validate arguments.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    let method = 'GET';\n    let query = 'policy';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let policy = Buffer.from('');\n      pipesetup(response, transformers.getConcater()).on('data', data => policy = data).on('error', cb).on('end', () => {\n        cb(null, policy.toString());\n      });\n    });\n  }\n\n  // Set the policy on a bucket or an object prefix.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `bucketPolicy` _string_: bucket policy (JSON stringify'ed)\n  // * `callback(err)` _function_: callback function\n  setBucketPolicy(bucketName, policy, cb) {\n    // Validate arguments.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isString(policy)) {\n      throw new errors.InvalidBucketPolicyError(`Invalid bucket policy: ${policy} - must be \"string\"`);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    let method = 'DELETE';\n    let query = 'policy';\n    if (policy) {\n      method = 'PUT';\n    }\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, policy, [204], '', false, cb);\n  }\n\n  // Generate a generic presigned URL which can be\n  // used for HTTP methods GET, PUT, HEAD and DELETE\n  //\n  // __Arguments__\n  // * `method` _string_: name of the HTTP method\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  // * `reqParams` _object_: request parameters (optional) e.g {versionId:\"10fa9946-3f64-4137-a58f-888065c0732e\"}\n  // * `requestDate` _Date_: A date object, the url will be issued at (optional)\n  presignedUrl(method, bucketName, objectName, expires, reqParams, requestDate, cb) {\n    if (this.anonymous) {\n      throw new errors.AnonymousRequestError('Presigned ' + method + ' url cannot be generated for anonymous requests');\n    }\n    if (isFunction(requestDate)) {\n      cb = requestDate;\n      requestDate = new Date();\n    }\n    if (isFunction(reqParams)) {\n      cb = reqParams;\n      reqParams = {};\n      requestDate = new Date();\n    }\n    if (isFunction(expires)) {\n      cb = expires;\n      reqParams = {};\n      expires = 24 * 60 * 60 * 7; // 7 days in seconds\n      requestDate = new Date();\n    }\n    if (!isNumber(expires)) {\n      throw new TypeError('expires should be of type \"number\"');\n    }\n    if (!isObject(reqParams)) {\n      throw new TypeError('reqParams should be of type \"object\"');\n    }\n    if (!isValidDate(requestDate)) {\n      throw new TypeError('requestDate should be of type \"Date\" and valid');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var query = querystring.stringify(reqParams);\n    this.getBucketRegion(bucketName, (e, region) => {\n      if (e) {\n        return cb(e);\n      }\n      // This statement is added to ensure that we send error through\n      // callback on presign failure.\n      var url;\n      var reqOptions = this.getRequestOptions({\n        method,\n        region,\n        bucketName,\n        objectName,\n        query\n      });\n      this.checkAndRefreshCreds();\n      try {\n        url = presignSignatureV4(reqOptions, this.accessKey, this.secretKey, this.sessionToken, region, requestDate, expires);\n      } catch (pe) {\n        return cb(pe);\n      }\n      cb(null, url);\n    });\n  }\n\n  // Generate a presigned URL for GET\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  // * `respHeaders` _object_: response headers to override or request params for query (optional) e.g {versionId:\"10fa9946-3f64-4137-a58f-888065c0732e\"}\n  // * `requestDate` _Date_: A date object, the url will be issued at (optional)\n  presignedGetObject(bucketName, objectName, expires, respHeaders, requestDate, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (isFunction(respHeaders)) {\n      cb = respHeaders;\n      respHeaders = {};\n      requestDate = new Date();\n    }\n    var validRespHeaders = ['response-content-type', 'response-content-language', 'response-expires', 'response-cache-control', 'response-content-disposition', 'response-content-encoding'];\n    validRespHeaders.forEach(header => {\n      if (respHeaders !== undefined && respHeaders[header] !== undefined && !isString(respHeaders[header])) {\n        throw new TypeError(`response header ${header} should be of type \"string\"`);\n      }\n    });\n    return this.presignedUrl('GET', bucketName, objectName, expires, respHeaders, requestDate, cb);\n  }\n\n  // Generate a presigned URL for PUT. Using this URL, the browser can upload to S3 only with the specified object name.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  presignedPutObject(bucketName, objectName, expires, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    return this.presignedUrl('PUT', bucketName, objectName, expires, cb);\n  }\n\n  // return PostPolicy object\n  newPostPolicy() {\n    return new PostPolicy();\n  }\n\n  // presignedPostPolicy can be used in situations where we want more control on the upload than what\n  // presignedPutObject() provides. i.e Using presignedPostPolicy we will be able to put policy restrictions\n  // on the object's `name` `bucket` `expiry` `Content-Type` `Content-Disposition` `metaData`\n  presignedPostPolicy(postPolicy, cb) {\n    if (this.anonymous) {\n      throw new errors.AnonymousRequestError('Presigned POST policy cannot be generated for anonymous requests');\n    }\n    if (!isObject(postPolicy)) {\n      throw new TypeError('postPolicy should be of type \"object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"');\n    }\n    this.getBucketRegion(postPolicy.formData.bucket, (e, region) => {\n      if (e) {\n        return cb(e);\n      }\n      var date = new Date();\n      var dateStr = makeDateLong(date);\n      this.checkAndRefreshCreds();\n      if (!postPolicy.policy.expiration) {\n        // 'expiration' is mandatory field for S3.\n        // Set default expiration date of 7 days.\n        var expires = new Date();\n        expires.setSeconds(24 * 60 * 60 * 7);\n        postPolicy.setExpires(expires);\n      }\n      postPolicy.policy.conditions.push(['eq', '$x-amz-date', dateStr]);\n      postPolicy.formData['x-amz-date'] = dateStr;\n      postPolicy.policy.conditions.push(['eq', '$x-amz-algorithm', 'AWS4-HMAC-SHA256']);\n      postPolicy.formData['x-amz-algorithm'] = 'AWS4-HMAC-SHA256';\n      postPolicy.policy.conditions.push(['eq', '$x-amz-credential', this.accessKey + '/' + getScope(region, date)]);\n      postPolicy.formData['x-amz-credential'] = this.accessKey + '/' + getScope(region, date);\n      if (this.sessionToken) {\n        postPolicy.policy.conditions.push(['eq', '$x-amz-security-token', this.sessionToken]);\n        postPolicy.formData['x-amz-security-token'] = this.sessionToken;\n      }\n      var policyBase64 = Buffer.from(JSON.stringify(postPolicy.policy)).toString('base64');\n      postPolicy.formData.policy = policyBase64;\n      var signature = postPresignSignatureV4(region, date, this.secretKey, policyBase64);\n      postPolicy.formData['x-amz-signature'] = signature;\n      var opts = {};\n      opts.region = region;\n      opts.bucketName = postPolicy.formData.bucket;\n      var reqOptions = this.getRequestOptions(opts);\n      var portStr = this.port == 80 || this.port === 443 ? '' : `:${this.port.toString()}`;\n      var urlStr = `${reqOptions.protocol}//${reqOptions.host}${portStr}${reqOptions.path}`;\n      cb(null, {\n        postURL: urlStr,\n        formData: postPolicy.formData\n      });\n    });\n  }\n\n  // Complete the multipart upload. After all the parts are uploaded issuing\n  // this call will aggregate the parts on the server into a single object.\n  completeMultipartUpload(bucketName, objectName, uploadId, etags, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"');\n    }\n    if (!isObject(etags)) {\n      throw new TypeError('etags should be of type \"Array\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"');\n    }\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty');\n    }\n    var method = 'POST';\n    var query = `uploadId=${uriEscape(uploadId)}`;\n    var parts = [];\n    etags.forEach(element => {\n      parts.push({\n        Part: [{\n          PartNumber: element.part\n        }, {\n          ETag: element.etag\n        }]\n      });\n    });\n    var payloadObject = {\n      CompleteMultipartUpload: parts\n    };\n    var payload = Xml(payloadObject);\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query\n    }, payload, [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      var transformer = transformers.getCompleteMultipartTransformer();\n      pipesetup(response, transformer).on('error', e => cb(e)).on('data', result => {\n        if (result.errCode) {\n          // Multipart Complete API returns an error XML after a 200 http status\n          cb(new errors.S3Error(result.errMessage));\n        } else {\n          const completeMultipartResult = {\n            etag: result.etag,\n            versionId: getVersionId(response.headers)\n          };\n          cb(null, completeMultipartResult);\n        }\n      });\n    });\n  }\n\n  // Called by listIncompleteUploads to fetch a batch of incomplete uploads.\n  listIncompleteUploadsQuery(bucketName, prefix, keyMarker, uploadIdMarker, delimiter) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isString(keyMarker)) {\n      throw new TypeError('keyMarker should be of type \"string\"');\n    }\n    if (!isString(uploadIdMarker)) {\n      throw new TypeError('uploadIdMarker should be of type \"string\"');\n    }\n    if (!isString(delimiter)) {\n      throw new TypeError('delimiter should be of type \"string\"');\n    }\n    var queries = [];\n    queries.push(`prefix=${uriEscape(prefix)}`);\n    queries.push(`delimiter=${uriEscape(delimiter)}`);\n    if (keyMarker) {\n      keyMarker = uriEscape(keyMarker);\n      queries.push(`key-marker=${keyMarker}`);\n    }\n    if (uploadIdMarker) {\n      queries.push(`upload-id-marker=${uploadIdMarker}`);\n    }\n    var maxUploads = 1000;\n    queries.push(`max-uploads=${maxUploads}`);\n    queries.sort();\n    queries.unshift('uploads');\n    var query = '';\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`;\n    }\n    var method = 'GET';\n    var transformer = transformers.getListMultipartTransformer();\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e);\n      }\n      pipesetup(response, transformer);\n    });\n    return transformer;\n  }\n\n  // Find uploadId of an incomplete upload.\n  findUploadId(bucketName, objectName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"');\n    }\n    var latestUpload;\n    var listNext = (keyMarker, uploadIdMarker) => {\n      this.listIncompleteUploadsQuery(bucketName, objectName, keyMarker, uploadIdMarker, '').on('error', e => cb(e)).on('data', result => {\n        result.uploads.forEach(upload => {\n          if (upload.key === objectName) {\n            if (!latestUpload || upload.initiated.getTime() > latestUpload.initiated.getTime()) {\n              latestUpload = upload;\n              return;\n            }\n          }\n        });\n        if (result.isTruncated) {\n          listNext(result.nextKeyMarker, result.nextUploadIdMarker);\n          return;\n        }\n        if (latestUpload) {\n          return cb(null, latestUpload.uploadId);\n        }\n        cb(null, undefined);\n      });\n    };\n    listNext('', '');\n  }\n\n  // Remove all the notification configurations in the S3 provider\n  setBucketNotification(bucketName, config, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isObject(config)) {\n      throw new TypeError('notification config should be of type \"Object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var method = 'PUT';\n    var query = 'notification';\n    var builder = new xml2js.Builder({\n      rootName: 'NotificationConfiguration',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    var payload = builder.buildObject(config);\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, payload, [200], '', false, cb);\n  }\n  removeAllBucketNotification(bucketName, cb) {\n    this.setBucketNotification(bucketName, new NotificationConfig(), cb);\n  }\n\n  // Return the list of notification configurations stored\n  // in the S3 provider\n  getBucketNotification(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var method = 'GET';\n    var query = 'notification';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      var transformer = transformers.getBucketNotificationTransformer();\n      var bucketNotification;\n      pipesetup(response, transformer).on('data', result => bucketNotification = result).on('error', e => cb(e)).on('end', () => cb(null, bucketNotification));\n    });\n  }\n\n  // Listens for bucket notifications. Returns an EventEmitter.\n  listenBucketNotification(bucketName, prefix, suffix, events) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix must be of type string');\n    }\n    if (!isString(suffix)) {\n      throw new TypeError('suffix must be of type string');\n    }\n    if (!Array.isArray(events)) {\n      throw new TypeError('events must be of type Array');\n    }\n    let listener = new NotificationPoller(this, bucketName, prefix, suffix, events);\n    listener.start();\n    return listener;\n  }\n  getBucketVersioning(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    var method = 'GET';\n    var query = 'versioning';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let versionConfig = Buffer.from('');\n      pipesetup(response, transformers.bucketVersioningTransformer()).on('data', data => {\n        versionConfig = data;\n      }).on('error', cb).on('end', () => {\n        cb(null, versionConfig);\n      });\n    });\n  }\n  setBucketVersioning(bucketName, versionConfig, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!Object.keys(versionConfig).length) {\n      throw new errors.InvalidArgumentError('versionConfig should be of type \"object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    var method = 'PUT';\n    var query = 'versioning';\n    var builder = new xml2js.Builder({\n      rootName: 'VersioningConfiguration',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    var payload = builder.buildObject(versionConfig);\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, payload, [200], '', false, cb);\n  }\n\n  /** To set Tags on a bucket or object based on the params\n   *  __Arguments__\n   * taggingParams _object_ Which contains the following properties\n   *  bucketName _string_,\n   *  objectName _string_ (Optional),\n   *  tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   *  putOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   *  cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setTagging(taggingParams) {\n    const {\n      bucketName,\n      objectName,\n      tags,\n      putOpts = {},\n      cb\n    } = taggingParams;\n    const method = 'PUT';\n    let query = 'tagging';\n    if (putOpts && putOpts.versionId) {\n      query = `${query}&versionId=${putOpts.versionId}`;\n    }\n    const tagsList = [];\n    for (const [key, value] of Object.entries(tags)) {\n      tagsList.push({\n        Key: key,\n        Value: value\n      });\n    }\n    const taggingConfig = {\n      Tagging: {\n        TagSet: {\n          Tag: tagsList\n        }\n      }\n    };\n    const encoder = new TextEncoder();\n    const headers = {};\n    const builder = new xml2js.Builder({\n      headless: true,\n      renderOpts: {\n        pretty: false\n      }\n    });\n    let payload = builder.buildObject(taggingConfig);\n    payload = Buffer.from(encoder.encode(payload));\n    headers['Content-MD5'] = toMd5(payload);\n    const requestOptions = {\n      method,\n      bucketName,\n      query,\n      headers\n    };\n    if (objectName) {\n      requestOptions['objectName'] = objectName;\n    }\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest(requestOptions, payload, [200], '', false, cb);\n  }\n\n  /** Set Tags on a Bucket\n   * __Arguments__\n   * bucketName _string_\n   * tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setBucketTagging(bucketName, tags, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isObject(tags)) {\n      throw new errors.InvalidArgumentError('tags should be of type \"object\"');\n    }\n    if (Object.keys(tags).length > 10) {\n      throw new errors.InvalidArgumentError('maximum tags allowed is 10\"');\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    return this.setTagging({\n      bucketName,\n      tags,\n      cb\n    });\n  }\n\n  /** Set Tags on an Object\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_\n   *  * tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   *  putOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setObjectTagging(bucketName, objectName, tags, putOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName);\n    }\n    if (isFunction(putOpts)) {\n      cb = putOpts;\n      putOpts = {};\n    }\n    if (!isObject(tags)) {\n      throw new errors.InvalidArgumentError('tags should be of type \"object\"');\n    }\n    if (Object.keys(tags).length > 10) {\n      throw new errors.InvalidArgumentError('Maximum tags allowed is 10\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    return this.setTagging({\n      bucketName,\n      objectName,\n      tags,\n      putOpts,\n      cb\n    });\n  }\n\n  /** Remove Tags on an Bucket/Object based on params\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_ (optional)\n   * removeOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeTagging({\n    bucketName,\n    objectName,\n    removeOpts,\n    cb\n  }) {\n    const method = 'DELETE';\n    let query = 'tagging';\n    if (removeOpts && Object.keys(removeOpts).length && removeOpts.versionId) {\n      query = `${query}&versionId=${removeOpts.versionId}`;\n    }\n    const requestOptions = {\n      method,\n      bucketName,\n      objectName,\n      query\n    };\n    if (objectName) {\n      requestOptions['objectName'] = objectName;\n    }\n    this.makeRequest(requestOptions, '', [200, 204], '', true, cb);\n  }\n\n  /** Remove Tags associated with a bucket\n   *  __Arguments__\n   * bucketName _string_\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeBucketTagging(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    return this.removeTagging({\n      bucketName,\n      cb\n    });\n  }\n\n  /** Remove tags associated with an object\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_\n   * removeOpts _object_ (Optional) e.g. {VersionID:\"my-object-version-id\"}\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeObjectTagging(bucketName, objectName, removeOpts, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName);\n    }\n    if (isFunction(removeOpts)) {\n      cb = removeOpts;\n      removeOpts = {};\n    }\n    if (removeOpts && Object.keys(removeOpts).length && !isObject(removeOpts)) {\n      throw new errors.InvalidArgumentError('removeOpts should be of type \"object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    return this.removeTagging({\n      bucketName,\n      objectName,\n      removeOpts,\n      cb\n    });\n  }\n\n  /** Get Tags associated with a Bucket\n   *  __Arguments__\n   * bucketName _string_\n   * `cb(error, tags)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  getBucketTagging(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    const method = 'GET';\n    const query = 'tagging';\n    const requestOptions = {\n      method,\n      bucketName,\n      query\n    };\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      var transformer = transformers.getTagsTransformer();\n      if (e) {\n        return cb(e);\n      }\n      let tagsList;\n      pipesetup(response, transformer).on('data', result => tagsList = result).on('error', e => cb(e)).on('end', () => cb(null, tagsList));\n    });\n  }\n\n  /** Get the tags associated with a bucket OR an object\n   * bucketName _string_\n   * objectName _string_ (Optional)\n   * getOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"}\n   * `cb(error, tags)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  getObjectTagging(bucketName, objectName, getOpts = {}, cb = () => false) {\n    const method = 'GET';\n    let query = 'tagging';\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName);\n    }\n    if (isFunction(getOpts)) {\n      cb = getOpts;\n      getOpts = {};\n    }\n    if (!isObject(getOpts)) {\n      throw new errors.InvalidArgumentError('getOpts should be of type \"object\"');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    if (getOpts && getOpts.versionId) {\n      query = `${query}&versionId=${getOpts.versionId}`;\n    }\n    const requestOptions = {\n      method,\n      bucketName,\n      query\n    };\n    if (objectName) {\n      requestOptions['objectName'] = objectName;\n    }\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      const transformer = transformers.getTagsTransformer();\n      if (e) {\n        return cb(e);\n      }\n      let tagsList;\n      pipesetup(response, transformer).on('data', result => tagsList = result).on('error', e => cb(e)).on('end', () => cb(null, tagsList));\n    });\n  }\n\n  /**\n   * Apply lifecycle configuration on a bucket.\n   * bucketName _string_\n   * policyConfig _object_ a valid policy configuration object.\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  applyBucketLifecycle(bucketName, policyConfig, cb) {\n    const method = 'PUT';\n    const query = 'lifecycle';\n    const encoder = new TextEncoder();\n    const headers = {};\n    const builder = new xml2js.Builder({\n      rootName: 'LifecycleConfiguration',\n      headless: true,\n      renderOpts: {\n        pretty: false\n      }\n    });\n    let payload = builder.buildObject(policyConfig);\n    payload = Buffer.from(encoder.encode(payload));\n    const requestOptions = {\n      method,\n      bucketName,\n      query,\n      headers\n    };\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest(requestOptions, payload, [200], '', false, cb);\n  }\n\n  /** Remove lifecycle configuration of a bucket.\n   * bucketName _string_\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeBucketLifecycle(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    const method = 'DELETE';\n    const query = 'lifecycle';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [204], '', false, cb);\n  }\n\n  /** Set/Override lifecycle configuration on a bucket. if the configuration is empty, it removes the configuration.\n   * bucketName _string_\n   * lifeCycleConfig _object_ one of the following values: (null or '') to remove the lifecycle configuration. or a valid lifecycle configuration\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setBucketLifecycle(bucketName, lifeCycleConfig = null, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (_.isEmpty(lifeCycleConfig)) {\n      this.removeBucketLifecycle(bucketName, cb);\n    } else {\n      this.applyBucketLifecycle(bucketName, lifeCycleConfig, cb);\n    }\n  }\n\n  /** Get lifecycle configuration on a bucket.\n   * bucketName _string_\n   * `cb(config)` _function_ - callback function with lifecycle configuration as the error argument.\n   */\n  getBucketLifecycle(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    const method = 'GET';\n    const query = 'lifecycle';\n    const requestOptions = {\n      method,\n      bucketName,\n      query\n    };\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      const transformer = transformers.lifecycleTransformer();\n      if (e) {\n        return cb(e);\n      }\n      let lifecycleConfig;\n      pipesetup(response, transformer).on('data', result => lifecycleConfig = result).on('error', e => cb(e)).on('end', () => cb(null, lifecycleConfig));\n    });\n  }\n  setObjectLockConfig(bucketName, lockConfigOpts = {}, cb) {\n    const retentionModes = [RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE];\n    const validUnits = [RETENTION_VALIDITY_UNITS.DAYS, RETENTION_VALIDITY_UNITS.YEARS];\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (lockConfigOpts.mode && !retentionModes.includes(lockConfigOpts.mode)) {\n      throw new TypeError(`lockConfigOpts.mode should be one of ${retentionModes}`);\n    }\n    if (lockConfigOpts.unit && !validUnits.includes(lockConfigOpts.unit)) {\n      throw new TypeError(`lockConfigOpts.unit should be one of ${validUnits}`);\n    }\n    if (lockConfigOpts.validity && !isNumber(lockConfigOpts.validity)) {\n      throw new TypeError(`lockConfigOpts.validity should be a number`);\n    }\n    const method = 'PUT';\n    const query = 'object-lock';\n    let config = {\n      ObjectLockEnabled: 'Enabled'\n    };\n    const configKeys = Object.keys(lockConfigOpts);\n    // Check if keys are present and all keys are present.\n    if (configKeys.length > 0) {\n      if (_.difference(configKeys, ['unit', 'mode', 'validity']).length !== 0) {\n        throw new TypeError(`lockConfigOpts.mode,lockConfigOpts.unit,lockConfigOpts.validity all the properties should be specified.`);\n      } else {\n        config.Rule = {\n          DefaultRetention: {}\n        };\n        if (lockConfigOpts.mode) {\n          config.Rule.DefaultRetention.Mode = lockConfigOpts.mode;\n        }\n        if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.DAYS) {\n          config.Rule.DefaultRetention.Days = lockConfigOpts.validity;\n        } else if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.YEARS) {\n          config.Rule.DefaultRetention.Years = lockConfigOpts.validity;\n        }\n      }\n    }\n    const builder = new xml2js.Builder({\n      rootName: 'ObjectLockConfiguration',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    const payload = builder.buildObject(config);\n    const headers = {};\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest({\n      method,\n      bucketName,\n      query,\n      headers\n    }, payload, [200], '', false, cb);\n  }\n  getObjectLockConfig(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    const method = 'GET';\n    const query = 'object-lock';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let objectLockConfig = Buffer.from('');\n      pipesetup(response, transformers.objectLockTransformer()).on('data', data => {\n        objectLockConfig = data;\n      }).on('error', cb).on('end', () => {\n        cb(null, objectLockConfig);\n      });\n    });\n  }\n  putObjectRetention(bucketName, objectName, retentionOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isObject(retentionOpts)) {\n      throw new errors.InvalidArgumentError('retentionOpts should be of type \"object\"');\n    } else {\n      if (retentionOpts.governanceBypass && !isBoolean(retentionOpts.governanceBypass)) {\n        throw new errors.InvalidArgumentError('Invalid value for governanceBypass', retentionOpts.governanceBypass);\n      }\n      if (retentionOpts.mode && ![RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE].includes(retentionOpts.mode)) {\n        throw new errors.InvalidArgumentError('Invalid object retention mode ', retentionOpts.mode);\n      }\n      if (retentionOpts.retainUntilDate && !isString(retentionOpts.retainUntilDate)) {\n        throw new errors.InvalidArgumentError('Invalid value for retainUntilDate', retentionOpts.retainUntilDate);\n      }\n      if (retentionOpts.versionId && !isString(retentionOpts.versionId)) {\n        throw new errors.InvalidArgumentError('Invalid value for versionId', retentionOpts.versionId);\n      }\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    const method = 'PUT';\n    let query = 'retention';\n    const headers = {};\n    if (retentionOpts.governanceBypass) {\n      headers['X-Amz-Bypass-Governance-Retention'] = true;\n    }\n    const builder = new xml2js.Builder({\n      rootName: 'Retention',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    const params = {};\n    if (retentionOpts.mode) {\n      params.Mode = retentionOpts.mode;\n    }\n    if (retentionOpts.retainUntilDate) {\n      params.RetainUntilDate = retentionOpts.retainUntilDate;\n    }\n    if (retentionOpts.versionId) {\n      query += `&versionId=${retentionOpts.versionId}`;\n    }\n    let payload = builder.buildObject(params);\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query,\n      headers\n    }, payload, [200, 204], '', false, cb);\n  }\n  getObjectRetention(bucketName, objectName, getOpts, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isObject(getOpts)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"object\"');\n    } else if (getOpts.versionId && !isString(getOpts.versionId)) {\n      throw new errors.InvalidArgumentError('VersionID should be of type \"string\"');\n    }\n    if (cb && !isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    const method = 'GET';\n    let query = 'retention';\n    if (getOpts.versionId) {\n      query += `&versionId=${getOpts.versionId}`;\n    }\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let retentionConfig = Buffer.from('');\n      pipesetup(response, transformers.objectRetentionTransformer()).on('data', data => {\n        retentionConfig = data;\n      }).on('error', cb).on('end', () => {\n        cb(null, retentionConfig);\n      });\n    });\n  }\n  setBucketEncryption(bucketName, encryptionConfig, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (isFunction(encryptionConfig)) {\n      cb = encryptionConfig;\n      encryptionConfig = null;\n    }\n    if (!_.isEmpty(encryptionConfig) && encryptionConfig.Rule.length > 1) {\n      throw new errors.InvalidArgumentError('Invalid Rule length. Only one rule is allowed.: ' + encryptionConfig.Rule);\n    }\n    if (cb && !isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    let encryptionObj = encryptionConfig;\n    if (_.isEmpty(encryptionConfig)) {\n      encryptionObj = {\n        // Default MinIO Server Supported Rule\n        Rule: [{\n          ApplyServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'AES256'\n          }\n        }]\n      };\n    }\n    let method = 'PUT';\n    let query = 'encryption';\n    let builder = new xml2js.Builder({\n      rootName: 'ServerSideEncryptionConfiguration',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    let payload = builder.buildObject(encryptionObj);\n    const headers = {};\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest({\n      method,\n      bucketName,\n      query,\n      headers\n    }, payload, [200], '', false, cb);\n  }\n  getBucketEncryption(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    const method = 'GET';\n    const query = 'encryption';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let bucketEncConfig = Buffer.from('');\n      pipesetup(response, transformers.bucketEncryptionTransformer()).on('data', data => {\n        bucketEncConfig = data;\n      }).on('error', cb).on('end', () => {\n        cb(null, bucketEncConfig);\n      });\n    });\n  }\n  removeBucketEncryption(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    const method = 'DELETE';\n    const query = 'encryption';\n    this.makeRequest({\n      method,\n      bucketName,\n      query\n    }, '', [204], '', false, cb);\n  }\n  getObjectLegalHold(bucketName, objectName, getOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (isFunction(getOpts)) {\n      cb = getOpts;\n      getOpts = {};\n    }\n    if (!isObject(getOpts)) {\n      throw new TypeError('getOpts should be of type \"Object\"');\n    } else if (Object.keys(getOpts).length > 0 && getOpts.versionId && !isString(getOpts.versionId)) {\n      throw new TypeError('versionId should be of type string.:', getOpts.versionId);\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    const method = 'GET';\n    let query = 'legal-hold';\n    if (getOpts.versionId) {\n      query += `&versionId=${getOpts.versionId}`;\n    }\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query\n    }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let legalHoldConfig = Buffer.from('');\n      pipesetup(response, transformers.objectLegalHoldTransformer()).on('data', data => {\n        legalHoldConfig = data;\n      }).on('error', cb).on('end', () => {\n        cb(null, legalHoldConfig);\n      });\n    });\n  }\n  setObjectLegalHold(bucketName, objectName, setOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    const defaultOpts = {\n      status: LEGAL_HOLD_STATUS.ENABLED\n    };\n    if (isFunction(setOpts)) {\n      cb = setOpts;\n      setOpts = defaultOpts;\n    }\n    if (!isObject(setOpts)) {\n      throw new TypeError('setOpts should be of type \"Object\"');\n    } else {\n      if (![LEGAL_HOLD_STATUS.ENABLED, LEGAL_HOLD_STATUS.DISABLED].includes(setOpts.status)) {\n        throw new TypeError('Invalid status: ' + setOpts.status);\n      }\n      if (setOpts.versionId && !setOpts.versionId.length) {\n        throw new TypeError('versionId should be of type string.:' + setOpts.versionId);\n      }\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"');\n    }\n    if (_.isEmpty(setOpts)) {\n      setOpts = {\n        defaultOpts\n      };\n    }\n    const method = 'PUT';\n    let query = 'legal-hold';\n    if (setOpts.versionId) {\n      query += `&versionId=${setOpts.versionId}`;\n    }\n    let config = {\n      Status: setOpts.status\n    };\n    const builder = new xml2js.Builder({\n      rootName: 'LegalHold',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    const payload = builder.buildObject(config);\n    const headers = {};\n    headers['Content-MD5'] = toMd5(payload);\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query,\n      headers\n    }, payload, [200], '', false, cb);\n  }\n\n  /**\n   * Internal method to upload a part during compose object.\n   * @param partConfig __object__ contains the following.\n   *    bucketName __string__\n   *    objectName __string__\n   *    uploadID __string__\n   *    partNumber __number__\n   *    headers __object__\n   * @param cb called with null incase of error.\n   */\n  uploadPartCopy(partConfig, cb) {\n    const {\n      bucketName,\n      objectName,\n      uploadID,\n      partNumber,\n      headers\n    } = partConfig;\n    const method = 'PUT';\n    let query = `uploadId=${uploadID}&partNumber=${partNumber}`;\n    const requestOptions = {\n      method,\n      bucketName,\n      objectName: objectName,\n      query,\n      headers\n    };\n    return this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      let partCopyResult = Buffer.from('');\n      if (e) {\n        return cb(e);\n      }\n      pipesetup(response, transformers.uploadPartTransformer()).on('data', data => {\n        partCopyResult = data;\n      }).on('error', cb).on('end', () => {\n        let uploadPartCopyRes = {\n          etag: sanitizeETag(partCopyResult.ETag),\n          key: objectName,\n          part: partNumber\n        };\n        cb(null, uploadPartCopyRes);\n      });\n    });\n  }\n  composeObject(destObjConfig = {}, sourceObjList = [], cb) {\n    const me = this; // many async flows. so store the ref.\n    const sourceFilesLength = sourceObjList.length;\n    if (!Array.isArray(sourceObjList)) {\n      throw new errors.InvalidArgumentError('sourceConfig should an array of CopySourceOptions ');\n    }\n    if (!(destObjConfig instanceof CopyDestinationOptions)) {\n      throw new errors.InvalidArgumentError('destConfig should of type CopyDestinationOptions ');\n    }\n    if (sourceFilesLength < 1 || sourceFilesLength > PART_CONSTRAINTS.MAX_PARTS_COUNT) {\n      throw new errors.InvalidArgumentError(`\"There must be as least one and up to ${PART_CONSTRAINTS.MAX_PARTS_COUNT} source objects.`);\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    for (let i = 0; i < sourceFilesLength; i++) {\n      if (!sourceObjList[i].validate()) {\n        return false;\n      }\n    }\n    if (!destObjConfig.validate()) {\n      return false;\n    }\n    const getStatOptions = srcConfig => {\n      let statOpts = {};\n      if (!_.isEmpty(srcConfig.VersionID)) {\n        statOpts = {\n          versionId: srcConfig.VersionID\n        };\n      }\n      return statOpts;\n    };\n    const srcObjectSizes = [];\n    let totalSize = 0;\n    let totalParts = 0;\n    const sourceObjStats = sourceObjList.map(srcItem => me.statObject(srcItem.Bucket, srcItem.Object, getStatOptions(srcItem)));\n    return Promise.all(sourceObjStats).then(srcObjectInfos => {\n      const validatedStats = srcObjectInfos.map((resItemStat, index) => {\n        const srcConfig = sourceObjList[index];\n        let srcCopySize = resItemStat.size;\n        // Check if a segment is specified, and if so, is the\n        // segment within object bounds?\n        if (srcConfig.MatchRange) {\n          // Since range is specified,\n          //    0 <= src.srcStart <= src.srcEnd\n          // so only invalid case to check is:\n          const srcStart = srcConfig.Start;\n          const srcEnd = srcConfig.End;\n          if (srcEnd >= srcCopySize || srcStart < 0) {\n            throw new errors.InvalidArgumentError(`CopySrcOptions ${index} has invalid segment-to-copy [${srcStart}, ${srcEnd}] (size is ${srcCopySize})`);\n          }\n          srcCopySize = srcEnd - srcStart + 1;\n        }\n\n        // Only the last source may be less than `absMinPartSize`\n        if (srcCopySize < PART_CONSTRAINTS.ABS_MIN_PART_SIZE && index < sourceFilesLength - 1) {\n          throw new errors.InvalidArgumentError(`CopySrcOptions ${index} is too small (${srcCopySize}) and it is not the last part.`);\n        }\n\n        // Is data to copy too large?\n        totalSize += srcCopySize;\n        if (totalSize > PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE) {\n          throw new errors.InvalidArgumentError(`Cannot compose an object of size ${totalSize} (> 5TiB)`);\n        }\n\n        // record source size\n        srcObjectSizes[index] = srcCopySize;\n\n        // calculate parts needed for current source\n        totalParts += partsRequired(srcCopySize);\n        // Do we need more parts than we are allowed?\n        if (totalParts > PART_CONSTRAINTS.MAX_PARTS_COUNT) {\n          throw new errors.InvalidArgumentError(`Your proposed compose object requires more than ${PART_CONSTRAINTS.MAX_PARTS_COUNT} parts`);\n        }\n        return resItemStat;\n      });\n      if (totalParts === 1 && totalSize <= PART_CONSTRAINTS.MAX_PART_SIZE || totalSize === 0) {\n        return this.copyObject(sourceObjList[0], destObjConfig, cb); // use copyObjectV2\n      }\n\n      // preserve etag to avoid modification of object while copying.\n      for (let i = 0; i < sourceFilesLength; i++) {\n        sourceObjList[i].MatchETag = validatedStats[i].etag;\n      }\n      const splitPartSizeList = validatedStats.map((resItemStat, idx) => {\n        const calSize = calculateEvenSplits(srcObjectSizes[idx], sourceObjList[idx]);\n        return calSize;\n      });\n      function getUploadPartConfigList(uploadId) {\n        const uploadPartConfigList = [];\n        splitPartSizeList.forEach((splitSize, splitIndex) => {\n          const {\n            startIndex: startIdx,\n            endIndex: endIdx,\n            objInfo: objConfig\n          } = splitSize;\n          let partIndex = splitIndex + 1; // part index starts from 1.\n          const totalUploads = Array.from(startIdx);\n          const headers = sourceObjList[splitIndex].getHeaders();\n          totalUploads.forEach((splitStart, upldCtrIdx) => {\n            let splitEnd = endIdx[upldCtrIdx];\n            const sourceObj = `${objConfig.Bucket}/${objConfig.Object}`;\n            headers['x-amz-copy-source'] = `${sourceObj}`;\n            headers['x-amz-copy-source-range'] = `bytes=${splitStart}-${splitEnd}`;\n            const uploadPartConfig = {\n              bucketName: destObjConfig.Bucket,\n              objectName: destObjConfig.Object,\n              uploadID: uploadId,\n              partNumber: partIndex,\n              headers: headers,\n              sourceObj: sourceObj\n            };\n            uploadPartConfigList.push(uploadPartConfig);\n          });\n        });\n        return uploadPartConfigList;\n      }\n      const performUploadParts = uploadId => {\n        const uploadList = getUploadPartConfigList(uploadId);\n        async.map(uploadList, me.uploadPartCopy.bind(me), (err, res) => {\n          if (err) {\n            this.abortMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId).then(() => cb(), err => cb(err));\n            return;\n          }\n          const partsDone = res.map(partCopy => ({\n            etag: partCopy.etag,\n            part: partCopy.part\n          }));\n          return me.completeMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId, partsDone, cb);\n        });\n      };\n      const newUploadHeaders = destObjConfig.getHeaders();\n      me.initiateNewMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, newUploadHeaders).then(uploadId => {\n        performUploadParts(uploadId);\n      }, err => {\n        cb(err, null);\n      });\n    }).catch(error => {\n      cb(error, null);\n    });\n  }\n  selectObjectContent(bucketName, objectName, selectOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!_.isEmpty(selectOpts)) {\n      if (!isString(selectOpts.expression)) {\n        throw new TypeError('sqlExpression should be of type \"string\"');\n      }\n      if (!_.isEmpty(selectOpts.inputSerialization)) {\n        if (!isObject(selectOpts.inputSerialization)) {\n          throw new TypeError('inputSerialization should be of type \"object\"');\n        }\n      } else {\n        throw new TypeError('inputSerialization is required');\n      }\n      if (!_.isEmpty(selectOpts.outputSerialization)) {\n        if (!isObject(selectOpts.outputSerialization)) {\n          throw new TypeError('outputSerialization should be of type \"object\"');\n        }\n      } else {\n        throw new TypeError('outputSerialization is required');\n      }\n    } else {\n      throw new TypeError('valid select configuration is required');\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"');\n    }\n    const method = 'POST';\n    let query = `select`;\n    query += '&select-type=2';\n    const config = [{\n      Expression: selectOpts.expression\n    }, {\n      ExpressionType: selectOpts.expressionType || 'SQL'\n    }, {\n      InputSerialization: [selectOpts.inputSerialization]\n    }, {\n      OutputSerialization: [selectOpts.outputSerialization]\n    }];\n\n    // Optional\n    if (selectOpts.requestProgress) {\n      config.push({\n        RequestProgress: selectOpts.requestProgress\n      });\n    }\n    // Optional\n    if (selectOpts.scanRange) {\n      config.push({\n        ScanRange: selectOpts.scanRange\n      });\n    }\n    const builder = new xml2js.Builder({\n      rootName: 'SelectObjectContentRequest',\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    const payload = builder.buildObject(config);\n    this.makeRequest({\n      method,\n      bucketName,\n      objectName,\n      query\n    }, payload, [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e);\n      }\n      let selectResult;\n      pipesetup(response, transformers.selectObjectContentTransformer()).on('data', data => {\n        selectResult = parseSelectObjectContentResponse(data);\n      }).on('error', cb).on('end', () => {\n        cb(null, selectResult);\n      });\n    });\n  }\n}\n\n// Promisify various public-facing APIs on the Client module.\nClient.prototype.makeBucket = promisify(Client.prototype.makeBucket);\nClient.prototype.bucketExists = promisify(Client.prototype.bucketExists);\nClient.prototype.getObject = promisify(Client.prototype.getObject);\nClient.prototype.getPartialObject = promisify(Client.prototype.getPartialObject);\nClient.prototype.fGetObject = promisify(Client.prototype.fGetObject);\nClient.prototype.putObject = promisify(Client.prototype.putObject);\nClient.prototype.fPutObject = promisify(Client.prototype.fPutObject);\nClient.prototype.copyObject = promisify(Client.prototype.copyObject);\nClient.prototype.removeObjects = promisify(Client.prototype.removeObjects);\nClient.prototype.presignedUrl = promisify(Client.prototype.presignedUrl);\nClient.prototype.presignedGetObject = promisify(Client.prototype.presignedGetObject);\nClient.prototype.presignedPutObject = promisify(Client.prototype.presignedPutObject);\nClient.prototype.presignedPostPolicy = promisify(Client.prototype.presignedPostPolicy);\nClient.prototype.getBucketNotification = promisify(Client.prototype.getBucketNotification);\nClient.prototype.setBucketNotification = promisify(Client.prototype.setBucketNotification);\nClient.prototype.removeAllBucketNotification = promisify(Client.prototype.removeAllBucketNotification);\nClient.prototype.getBucketPolicy = promisify(Client.prototype.getBucketPolicy);\nClient.prototype.setBucketPolicy = promisify(Client.prototype.setBucketPolicy);\nClient.prototype.removeIncompleteUpload = promisify(Client.prototype.removeIncompleteUpload);\nClient.prototype.getBucketVersioning = promisify(Client.prototype.getBucketVersioning);\nClient.prototype.setBucketVersioning = promisify(Client.prototype.setBucketVersioning);\nClient.prototype.setBucketTagging = promisify(Client.prototype.setBucketTagging);\nClient.prototype.removeBucketTagging = promisify(Client.prototype.removeBucketTagging);\nClient.prototype.getBucketTagging = promisify(Client.prototype.getBucketTagging);\nClient.prototype.setObjectTagging = promisify(Client.prototype.setObjectTagging);\nClient.prototype.removeObjectTagging = promisify(Client.prototype.removeObjectTagging);\nClient.prototype.getObjectTagging = promisify(Client.prototype.getObjectTagging);\nClient.prototype.setBucketLifecycle = promisify(Client.prototype.setBucketLifecycle);\nClient.prototype.getBucketLifecycle = promisify(Client.prototype.getBucketLifecycle);\nClient.prototype.removeBucketLifecycle = promisify(Client.prototype.removeBucketLifecycle);\nClient.prototype.setObjectLockConfig = promisify(Client.prototype.setObjectLockConfig);\nClient.prototype.getObjectLockConfig = promisify(Client.prototype.getObjectLockConfig);\nClient.prototype.putObjectRetention = promisify(Client.prototype.putObjectRetention);\nClient.prototype.getObjectRetention = promisify(Client.prototype.getObjectRetention);\nClient.prototype.setBucketEncryption = promisify(Client.prototype.setBucketEncryption);\nClient.prototype.getBucketEncryption = promisify(Client.prototype.getBucketEncryption);\nClient.prototype.removeBucketEncryption = promisify(Client.prototype.removeBucketEncryption);\nClient.prototype.setObjectLegalHold = promisify(Client.prototype.setObjectLegalHold);\nClient.prototype.getObjectLegalHold = promisify(Client.prototype.getObjectLegalHold);\nClient.prototype.composeObject = promisify(Client.prototype.composeObject);\nClient.prototype.selectObjectContent = promisify(Client.prototype.selectObjectContent);\n\n// refactored API use promise internally\nClient.prototype.removeObject = callbackify(Client.prototype.removeObject);\nClient.prototype.statObject = callbackify(Client.prototype.statObject);\nClient.prototype.removeBucket = callbackify(Client.prototype.removeBucket);\nClient.prototype.listBuckets = callbackify(Client.prototype.listBuckets);\nClient.prototype.removeBucketReplication = callbackify(Client.prototype.removeBucketReplication);\nClient.prototype.setBucketReplication = callbackify(Client.prototype.setBucketReplication);\nClient.prototype.getBucketReplication = callbackify(Client.prototype.getBucketReplication);","map":{"version":3,"names":["fs","path","Stream","async","BlockStream2","_","querystring","TextEncoder","Xml","xml2js","errors","CopyDestinationOptions","CopySourceOptions","DEFAULT_REGION","callbackify","TypedClient","CopyConditions","calculateEvenSplits","extractMetadata","getScope","getSourceVersionId","getVersionId","insertContentType","isBoolean","isFunction","isNumber","isObject","isReadableStream","isString","isValidBucketName","isValidDate","isValidObjectName","isValidPrefix","makeDateLong","PART_CONSTRAINTS","partsRequired","pipesetup","prependXAMZMeta","readableStream","sanitizeETag","toMd5","uriEscape","uriResourceEscape","PostPolicy","LEGAL_HOLD_STATUS","RETENTION_MODES","RETENTION_VALIDITY_UNITS","NotificationConfig","NotificationPoller","ObjectUploader","promisify","postPresignSignatureV4","presignSignatureV4","transformers","parseSelectObjectContentResponse","Client","setAppInfo","appName","appVersion","TypeError","trim","InvalidArgumentError","userAgent","calculatePartSize","size","maxObjectSize","overRidePartSize","partSize","makeBucket","bucketName","region","makeOpts","cb","InvalidBucketNameError","payload","createBucketConfiguration","push","_attr","xmlns","LocationConstraint","payloadObject","CreateBucketConfiguration","method","headers","ObjectLocking","processWithRetry","err","code","makeRequest","listIncompleteUploads","bucket","prefix","recursive","undefined","InvalidPrefixError","delimiter","keyMarker","uploadIdMarker","uploads","ended","readStream","Readable","objectMode","_read","length","shift","listIncompleteUploadsQuery","on","e","emit","result","prefixes","forEach","eachSeries","upload","listParts","key","uploadId","then","parts","reduce","acc","item","isTruncated","nextKeyMarker","nextUploadIdMarker","bucketExists","removeIncompleteUpload","objectName","IsValidBucketNameError","InvalidObjectNameError","removeUploadId","during","findUploadId","query","fGetObject","filePath","getOpts","partFile","partFileStream","objStat","rename","waterfall","statObject","mkdir","dirname","etag","stat","stats","offset","createWriteStream","flags","getPartialObject","downloadStream","Error","getObject","range","expectedStatusCodes","stringify","fPutObject","metaData","callback","lstat","putObject","createReadStream","stream","Buffer","chunker","zeroPadding","uploader","copyObjectV1","arg1","arg2","arg3","arg4","arg5","srcObject","conditions","modified","unmodified","matchETag","matchEtagExcept","matchETagExcept","response","transformer","getCopyObjectTransformer","data","copyObjectV2","sourceConfig","destConfig","validate","Object","assign","getHeaders","Bucket","resHeaders","copyObjResponse","Key","LastModified","MetaData","VersionId","SourceVersionId","Etag","Size","copyObject","allArgs","arguments","listObjectsQuery","marker","listQueryOpts","Delimiter","MaxKeys","IncludeVersion","queries","sort","join","getListObjectsTransformer","listObjects","listOpts","objects","nextMarker","versionIdMarker","listObjectsV2Query","continuationToken","maxKeys","startAfter","getListObjectsV2Transformer","listObjectsV2","nextContinuationToken","removeObjects","objectsList","Array","isArray","maxEntries","entry","list","listOfList","encoder","batchResults","batchCb","value","name","versionId","deleteObjects","Delete","Quiet","builder","Builder","headless","buildObject","from","encode","removeObjectsResult","removeObjectsTransformer","flatten","getBucketPolicy","policy","getConcater","toString","setBucketPolicy","InvalidBucketPolicyError","presignedUrl","expires","reqParams","requestDate","anonymous","AnonymousRequestError","Date","getBucketRegion","url","reqOptions","getRequestOptions","checkAndRefreshCreds","accessKey","secretKey","sessionToken","pe","presignedGetObject","respHeaders","validRespHeaders","header","presignedPutObject","newPostPolicy","presignedPostPolicy","postPolicy","formData","date","dateStr","expiration","setSeconds","setExpires","policyBase64","JSON","signature","opts","portStr","port","urlStr","protocol","host","postURL","completeMultipartUpload","etags","element","Part","PartNumber","part","ETag","CompleteMultipartUpload","getCompleteMultipartTransformer","errCode","S3Error","errMessage","completeMultipartResult","maxUploads","unshift","getListMultipartTransformer","latestUpload","listNext","initiated","getTime","setBucketNotification","config","rootName","renderOpts","pretty","removeAllBucketNotification","getBucketNotification","getBucketNotificationTransformer","bucketNotification","listenBucketNotification","suffix","events","listener","start","getBucketVersioning","versionConfig","bucketVersioningTransformer","setBucketVersioning","keys","setTagging","taggingParams","tags","putOpts","tagsList","entries","Value","taggingConfig","Tagging","TagSet","Tag","requestOptions","setBucketTagging","setObjectTagging","removeTagging","removeOpts","removeBucketTagging","removeObjectTagging","getBucketTagging","getTagsTransformer","getObjectTagging","applyBucketLifecycle","policyConfig","removeBucketLifecycle","setBucketLifecycle","lifeCycleConfig","isEmpty","getBucketLifecycle","lifecycleTransformer","lifecycleConfig","setObjectLockConfig","lockConfigOpts","retentionModes","COMPLIANCE","GOVERNANCE","validUnits","DAYS","YEARS","mode","includes","unit","validity","ObjectLockEnabled","configKeys","difference","Rule","DefaultRetention","Mode","Days","Years","getObjectLockConfig","objectLockConfig","objectLockTransformer","putObjectRetention","retentionOpts","governanceBypass","retainUntilDate","params","RetainUntilDate","getObjectRetention","retentionConfig","objectRetentionTransformer","setBucketEncryption","encryptionConfig","encryptionObj","ApplyServerSideEncryptionByDefault","SSEAlgorithm","getBucketEncryption","bucketEncConfig","bucketEncryptionTransformer","removeBucketEncryption","getObjectLegalHold","legalHoldConfig","objectLegalHoldTransformer","setObjectLegalHold","setOpts","defaultOpts","status","ENABLED","DISABLED","Status","uploadPartCopy","partConfig","uploadID","partNumber","partCopyResult","uploadPartTransformer","uploadPartCopyRes","composeObject","destObjConfig","sourceObjList","me","sourceFilesLength","MAX_PARTS_COUNT","i","getStatOptions","srcConfig","statOpts","VersionID","srcObjectSizes","totalSize","totalParts","sourceObjStats","map","srcItem","Promise","all","srcObjectInfos","validatedStats","resItemStat","index","srcCopySize","MatchRange","srcStart","Start","srcEnd","End","ABS_MIN_PART_SIZE","MAX_MULTIPART_PUT_OBJECT_SIZE","MAX_PART_SIZE","MatchETag","splitPartSizeList","idx","calSize","getUploadPartConfigList","uploadPartConfigList","splitSize","splitIndex","startIndex","startIdx","endIndex","endIdx","objInfo","objConfig","partIndex","totalUploads","splitStart","upldCtrIdx","splitEnd","sourceObj","uploadPartConfig","performUploadParts","uploadList","bind","res","abortMultipartUpload","partsDone","partCopy","newUploadHeaders","initiateNewMultipartUpload","catch","error","selectObjectContent","selectOpts","expression","inputSerialization","outputSerialization","Expression","ExpressionType","expressionType","InputSerialization","OutputSerialization","requestProgress","RequestProgress","scanRange","ScanRange","selectResult","selectObjectContentTransformer","prototype","removeObject","removeBucket","listBuckets","removeBucketReplication","setBucketReplication","getBucketReplication"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/minio.js"],"sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as fs from 'node:fs'\nimport * as path from 'node:path'\nimport * as Stream from 'node:stream'\n\nimport async from 'async'\nimport BlockStream2 from 'block-stream2'\nimport _ from 'lodash'\nimport * as querystring from 'query-string'\nimport { TextEncoder } from 'web-encoding'\nimport Xml from 'xml'\nimport xml2js from 'xml2js'\n\nimport * as errors from './errors.ts'\nimport { CopyDestinationOptions, CopySourceOptions, DEFAULT_REGION } from './helpers.ts'\nimport { callbackify } from './internal/callbackify.js'\nimport { TypedClient } from './internal/client.ts'\nimport { CopyConditions } from './internal/copy-conditions.ts'\nimport {\n  calculateEvenSplits,\n  extractMetadata,\n  getScope,\n  getSourceVersionId,\n  getVersionId,\n  insertContentType,\n  isBoolean,\n  isFunction,\n  isNumber,\n  isObject,\n  isReadableStream,\n  isString,\n  isValidBucketName,\n  isValidDate,\n  isValidObjectName,\n  isValidPrefix,\n  makeDateLong,\n  PART_CONSTRAINTS,\n  partsRequired,\n  pipesetup,\n  prependXAMZMeta,\n  readableStream,\n  sanitizeETag,\n  toMd5,\n  uriEscape,\n  uriResourceEscape,\n} from './internal/helper.ts'\nimport { PostPolicy } from './internal/post-policy.ts'\nimport { LEGAL_HOLD_STATUS, RETENTION_MODES, RETENTION_VALIDITY_UNITS } from './internal/type.ts'\nimport { NotificationConfig, NotificationPoller } from './notification.js'\nimport { ObjectUploader } from './object-uploader.js'\nimport { promisify } from './promisify.js'\nimport { postPresignSignatureV4, presignSignatureV4 } from './signing.ts'\nimport * as transformers from './transformers.js'\nimport { parseSelectObjectContentResponse } from './xml-parsers.js'\n\nexport * from './helpers.ts'\nexport * from './notification.js'\nexport { CopyConditions, PostPolicy }\n\nexport class Client extends TypedClient {\n  // Set application specific information.\n  //\n  // Generates User-Agent in the following style.\n  //\n  //       MinIO (OS; ARCH) LIB/VER APP/VER\n  //\n  // __Arguments__\n  // * `appName` _string_ - Application name.\n  // * `appVersion` _string_ - Application version.\n  setAppInfo(appName, appVersion) {\n    if (!isString(appName)) {\n      throw new TypeError(`Invalid appName: ${appName}`)\n    }\n    if (appName.trim() === '') {\n      throw new errors.InvalidArgumentError('Input appName cannot be empty.')\n    }\n    if (!isString(appVersion)) {\n      throw new TypeError(`Invalid appVersion: ${appVersion}`)\n    }\n    if (appVersion.trim() === '') {\n      throw new errors.InvalidArgumentError('Input appVersion cannot be empty.')\n    }\n    this.userAgent = `${this.userAgent} ${appName}/${appVersion}`\n  }\n\n  // Calculate part size given the object size. Part size will be atleast this.partSize\n  calculatePartSize(size) {\n    if (!isNumber(size)) {\n      throw new TypeError('size should be of type \"number\"')\n    }\n    if (size > this.maxObjectSize) {\n      throw new TypeError(`size should not be more than ${this.maxObjectSize}`)\n    }\n    if (this.overRidePartSize) {\n      return this.partSize\n    }\n    var partSize = this.partSize\n    for (;;) {\n      // while(true) {...} throws linting error.\n      // If partSize is big enough to accomodate the object size, then use it.\n      if (partSize * 10000 > size) {\n        return partSize\n      }\n      // Try part sizes as 64MB, 80MB, 96MB etc.\n      partSize += 16 * 1024 * 1024\n    }\n  }\n\n  // Creates the bucket `bucketName`.\n  //\n  // __Arguments__\n  // * `bucketName` _string_ - Name of the bucket\n  // * `region` _string_ - region valid values are _us-west-1_, _us-west-2_,  _eu-west-1_, _eu-central-1_, _ap-southeast-1_, _ap-northeast-1_, _ap-southeast-2_, _sa-east-1_.\n  // * `makeOpts` _object_ - Options to create a bucket. e.g {ObjectLocking:true} (Optional)\n  // * `callback(err)` _function_ - callback function with `err` as the error argument. `err` is null if the bucket is successfully created.\n  makeBucket(bucketName, region, makeOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    // Backward Compatibility\n    if (isObject(region)) {\n      cb = makeOpts\n      makeOpts = region\n      region = ''\n    }\n    if (isFunction(region)) {\n      cb = region\n      region = ''\n      makeOpts = {}\n    }\n    if (isFunction(makeOpts)) {\n      cb = makeOpts\n      makeOpts = {}\n    }\n\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"')\n    }\n    if (!isObject(makeOpts)) {\n      throw new TypeError('makeOpts should be of type \"object\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    var payload = ''\n\n    // Region already set in constructor, validate if\n    // caller requested bucket location is same.\n    if (region && this.region) {\n      if (region !== this.region) {\n        throw new errors.InvalidArgumentError(`Configured region ${this.region}, requested ${region}`)\n      }\n    }\n    // sending makeBucket request with XML containing 'us-east-1' fails. For\n    // default region server expects the request without body\n    if (region && region !== DEFAULT_REGION) {\n      var createBucketConfiguration = []\n      createBucketConfiguration.push({\n        _attr: {\n          xmlns: 'http://s3.amazonaws.com/doc/2006-03-01/',\n        },\n      })\n      createBucketConfiguration.push({\n        LocationConstraint: region,\n      })\n      var payloadObject = {\n        CreateBucketConfiguration: createBucketConfiguration,\n      }\n      payload = Xml(payloadObject)\n    }\n    var method = 'PUT'\n    var headers = {}\n\n    if (makeOpts.ObjectLocking) {\n      headers['x-amz-bucket-object-lock-enabled'] = true\n    }\n\n    if (!region) {\n      region = DEFAULT_REGION\n    }\n\n    const processWithRetry = (err) => {\n      if (err && (region === '' || region === DEFAULT_REGION)) {\n        if (err.code === 'AuthorizationHeaderMalformed' && err.region !== '') {\n          // Retry with region returned as part of error\n          this.makeRequest({ method, bucketName, headers }, payload, [200], err.region, false, cb)\n        } else {\n          return cb && cb(err)\n        }\n      }\n      return cb && cb(err)\n    }\n    this.makeRequest({ method, bucketName, headers }, payload, [200], region, false, processWithRetry)\n  }\n\n  // Returns a stream that emits objects that are partially uploaded.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: prefix of the object names that are partially uploaded (optional, default `''`)\n  // * `recursive` _bool_: directory style listing when false, recursive listing when true (optional, default `false`)\n  //\n  // __Return Value__\n  // * `stream` _Stream_ : emits objects of the format:\n  //   * `object.key` _string_: name of the object\n  //   * `object.uploadId` _string_: upload ID of the object\n  //   * `object.size` _Integer_: size of the partially uploaded object\n  listIncompleteUploads(bucket, prefix, recursive) {\n    if (prefix === undefined) {\n      prefix = ''\n    }\n    if (recursive === undefined) {\n      recursive = false\n    }\n    if (!isValidBucketName(bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucket)\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`)\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"')\n    }\n    var delimiter = recursive ? '' : '/'\n    var keyMarker = ''\n    var uploadIdMarker = ''\n    var uploads = []\n    var ended = false\n    var readStream = Stream.Readable({ objectMode: true })\n    readStream._read = () => {\n      // push one upload info per _read()\n      if (uploads.length) {\n        return readStream.push(uploads.shift())\n      }\n      if (ended) {\n        return readStream.push(null)\n      }\n      this.listIncompleteUploadsQuery(bucket, prefix, keyMarker, uploadIdMarker, delimiter)\n        .on('error', (e) => readStream.emit('error', e))\n        .on('data', (result) => {\n          result.prefixes.forEach((prefix) => uploads.push(prefix))\n          async.eachSeries(\n            result.uploads,\n            (upload, cb) => {\n              // for each incomplete upload add the sizes of its uploaded parts\n              this.listParts(bucket, upload.key, upload.uploadId).then((parts) => {\n                upload.size = parts.reduce((acc, item) => acc + item.size, 0)\n                uploads.push(upload)\n                cb()\n              }, cb)\n            },\n            (err) => {\n              if (err) {\n                readStream.emit('error', err)\n                return\n              }\n              if (result.isTruncated) {\n                keyMarker = result.nextKeyMarker\n                uploadIdMarker = result.nextUploadIdMarker\n              } else {\n                ended = true\n              }\n              readStream._read()\n            },\n          )\n        })\n    }\n    return readStream\n  }\n\n  // To check if a bucket already exists.\n  //\n  // __Arguments__\n  // * `bucketName` _string_ : name of the bucket\n  // * `callback(err)` _function_ : `err` is `null` if the bucket exists\n  bucketExists(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    var method = 'HEAD'\n    this.makeRequest({ method, bucketName }, '', [200], '', false, (err) => {\n      if (err) {\n        if (err.code == 'NoSuchBucket' || err.code == 'NotFound') {\n          return cb(null, false)\n        }\n        return cb(err)\n      }\n      cb(null, true)\n    })\n  }\n\n  // Remove the partially uploaded object.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `callback(err)` _function_: callback function is called with non `null` value in case of error\n  removeIncompleteUpload(bucketName, objectName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.IsValidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    var removeUploadId\n    async.during(\n      (cb) => {\n        this.findUploadId(bucketName, objectName, (e, uploadId) => {\n          if (e) {\n            return cb(e)\n          }\n          removeUploadId = uploadId\n          cb(null, uploadId)\n        })\n      },\n      (cb) => {\n        var method = 'DELETE'\n        var query = `uploadId=${removeUploadId}`\n        this.makeRequest({ method, bucketName, objectName, query }, '', [204], '', false, (e) => cb(e))\n      },\n      cb,\n    )\n  }\n\n  // Callback is called with `error` in case of error or `null` in case of success\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `filePath` _string_: path to which the object data will be written to\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err)` _function_: callback is called with `err` in case of error.\n  fGetObject(bucketName, objectName, filePath, getOpts = {}, cb) {\n    // Input validation.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isString(filePath)) {\n      throw new TypeError('filePath should be of type \"string\"')\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts\n      getOpts = {}\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    // Internal data.\n    var partFile\n    var partFileStream\n    var objStat\n\n    // Rename wrapper.\n    var rename = (err) => {\n      if (err) {\n        return cb(err)\n      }\n      fs.rename(partFile, filePath, cb)\n    }\n\n    async.waterfall(\n      [\n        (cb) => this.statObject(bucketName, objectName, getOpts, cb),\n        (result, cb) => {\n          objStat = result\n          // Create any missing top level directories.\n          fs.mkdir(path.dirname(filePath), { recursive: true }, (err) => cb(err))\n        },\n        (cb) => {\n          partFile = `${filePath}.${objStat.etag}.part.minio`\n          fs.stat(partFile, (e, stats) => {\n            var offset = 0\n            if (e) {\n              partFileStream = fs.createWriteStream(partFile, { flags: 'w' })\n            } else {\n              if (objStat.size === stats.size) {\n                return rename()\n              }\n              offset = stats.size\n              partFileStream = fs.createWriteStream(partFile, { flags: 'a' })\n            }\n            this.getPartialObject(bucketName, objectName, offset, 0, getOpts, cb)\n          })\n        },\n        (downloadStream, cb) => {\n          pipesetup(downloadStream, partFileStream)\n            .on('error', (e) => cb(e))\n            .on('finish', cb)\n        },\n        (cb) => fs.stat(partFile, cb),\n        (stats, cb) => {\n          if (stats.size === objStat.size) {\n            return cb()\n          }\n          cb(new Error('Size mismatch between downloaded file and the object'))\n        },\n      ],\n      rename,\n    )\n  }\n\n  // Callback is called with readable stream of the object content.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  getObject(bucketName, objectName, getOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts\n      getOpts = {}\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    this.getPartialObject(bucketName, objectName, 0, 0, getOpts, cb)\n  }\n\n  // Callback is called with readable stream of the partial object content.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `offset` _number_: offset of the object from where the stream will start\n  // * `length` _number_: length of the object that will be read in the stream (optional, if not specified we read the rest of the file from the offset)\n  // * `getOpts` _object_: Version of the object in the form `{versionId:'my-uuid'}`. Default is `{}`. (optional)\n  // * `callback(err, stream)` _function_: callback is called with `err` in case of error. `stream` is the object content stream\n  getPartialObject(bucketName, objectName, offset, length, getOpts = {}, cb) {\n    if (isFunction(length)) {\n      cb = length\n      length = 0\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isNumber(offset)) {\n      throw new TypeError('offset should be of type \"number\"')\n    }\n    if (!isNumber(length)) {\n      throw new TypeError('length should be of type \"number\"')\n    }\n    // Backward Compatibility\n    if (isFunction(getOpts)) {\n      cb = getOpts\n      getOpts = {}\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    var range = ''\n    if (offset || length) {\n      if (offset) {\n        range = `bytes=${+offset}-`\n      } else {\n        range = 'bytes=0-'\n        offset = 0\n      }\n      if (length) {\n        range += `${+length + offset - 1}`\n      }\n    }\n\n    var headers = {}\n    if (range !== '') {\n      headers.range = range\n    }\n\n    var expectedStatusCodes = [200]\n    if (range) {\n      expectedStatusCodes.push(206)\n    }\n    var method = 'GET'\n\n    var query = querystring.stringify(getOpts)\n    this.makeRequest({ method, bucketName, objectName, headers, query }, '', expectedStatusCodes, '', true, cb)\n  }\n\n  // Uploads the object using contents from a file\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `filePath` _string_: file path of the file to be uploaded\n  // * `metaData` _Javascript Object_: metaData assosciated with the object\n  // * `callback(err, objInfo)` _function_: non null `err` indicates error, `objInfo` _object_ which contains versionId and etag.\n  fPutObject(bucketName, objectName, filePath, metaData, callback) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    if (!isString(filePath)) {\n      throw new TypeError('filePath should be of type \"string\"')\n    }\n    if (isFunction(metaData)) {\n      callback = metaData\n      metaData = {} // Set metaData empty if no metaData provided.\n    }\n    if (!isObject(metaData)) {\n      throw new TypeError('metaData should be of type \"object\"')\n    }\n\n    // Inserts correct `content-type` attribute based on metaData and filePath\n    metaData = insertContentType(metaData, filePath)\n\n    fs.lstat(filePath, (err, stat) => {\n      if (err) {\n        return callback(err)\n      }\n      return this.putObject(bucketName, objectName, fs.createReadStream(filePath), stat.size, metaData, callback)\n    })\n  }\n\n  // Uploads the object.\n  //\n  // Uploading a stream\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `stream` _Stream_: Readable stream\n  // * `size` _number_: size of the object (optional)\n  // * `callback(err, etag)` _function_: non null `err` indicates error, `etag` _string_ is the etag of the object uploaded.\n  //\n  // Uploading \"Buffer\" or \"string\"\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `string or Buffer` _string_ or _Buffer_: string or buffer\n  // * `callback(err, objInfo)` _function_: `err` is `null` in case of success and `info` will have the following object details:\n  //   * `etag` _string_: etag of the object\n  //   * `versionId` _string_: versionId of the object\n  putObject(bucketName, objectName, stream, size, metaData, callback) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    // We'll need to shift arguments to the left because of size and metaData.\n    if (isFunction(size)) {\n      callback = size\n      metaData = {}\n    } else if (isFunction(metaData)) {\n      callback = metaData\n      metaData = {}\n    }\n\n    // We'll need to shift arguments to the left because of metaData\n    // and size being optional.\n    if (isObject(size)) {\n      metaData = size\n    }\n\n    // Ensures Metadata has appropriate prefix for A3 API\n    metaData = prependXAMZMeta(metaData)\n    if (typeof stream === 'string' || stream instanceof Buffer) {\n      // Adapts the non-stream interface into a stream.\n      size = stream.length\n      stream = readableStream(stream)\n    } else if (!isReadableStream(stream)) {\n      throw new TypeError('third argument should be of type \"stream.Readable\" or \"Buffer\" or \"string\"')\n    }\n\n    if (!isFunction(callback)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    if (isNumber(size) && size < 0) {\n      throw new errors.InvalidArgumentError(`size cannot be negative, given size: ${size}`)\n    }\n\n    // Get the part size and forward that to the BlockStream. Default to the\n    // largest block size possible if necessary.\n    if (!isNumber(size)) {\n      size = this.maxObjectSize\n    }\n\n    size = this.calculatePartSize(size)\n\n    // s3 requires that all non-end chunks be at least `this.partSize`,\n    // so we chunk the stream until we hit either that size or the end before\n    // we flush it to s3.\n    let chunker = new BlockStream2({ size, zeroPadding: false })\n\n    // This is a Writable stream that can be written to in order to upload\n    // to the specified bucket and object automatically.\n    let uploader = new ObjectUploader(this, bucketName, objectName, size, metaData, callback)\n    // stream => chunker => uploader\n    pipesetup(stream, chunker, uploader)\n  }\n\n  // Copy the object.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `srcObject` _string_: path of the source object to be copied\n  // * `conditions` _CopyConditions_: copy conditions that needs to be satisfied (optional, default `null`)\n  // * `callback(err, {etag, lastModified})` _function_: non null `err` indicates error, `etag` _string_ and `listModifed` _Date_ are respectively the etag and the last modified date of the newly copied object\n  copyObjectV1(arg1, arg2, arg3, arg4, arg5) {\n    var bucketName = arg1\n    var objectName = arg2\n    var srcObject = arg3\n    var conditions, cb\n    if (typeof arg4 == 'function' && arg5 === undefined) {\n      conditions = null\n      cb = arg4\n    } else {\n      conditions = arg4\n      cb = arg5\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isString(srcObject)) {\n      throw new TypeError('srcObject should be of type \"string\"')\n    }\n    if (srcObject === '') {\n      throw new errors.InvalidPrefixError(`Empty source prefix`)\n    }\n\n    if (conditions !== null && !(conditions instanceof CopyConditions)) {\n      throw new TypeError('conditions should be of type \"CopyConditions\"')\n    }\n\n    var headers = {}\n    headers['x-amz-copy-source'] = uriResourceEscape(srcObject)\n\n    if (conditions !== null) {\n      if (conditions.modified !== '') {\n        headers['x-amz-copy-source-if-modified-since'] = conditions.modified\n      }\n      if (conditions.unmodified !== '') {\n        headers['x-amz-copy-source-if-unmodified-since'] = conditions.unmodified\n      }\n      if (conditions.matchETag !== '') {\n        headers['x-amz-copy-source-if-match'] = conditions.matchETag\n      }\n      if (conditions.matchEtagExcept !== '') {\n        headers['x-amz-copy-source-if-none-match'] = conditions.matchETagExcept\n      }\n    }\n\n    var method = 'PUT'\n    this.makeRequest({ method, bucketName, objectName, headers }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n      var transformer = transformers.getCopyObjectTransformer()\n      pipesetup(response, transformer)\n        .on('error', (e) => cb(e))\n        .on('data', (data) => cb(null, data))\n    })\n  }\n\n  /**\n   * Internal Method to perform copy of an object.\n   * @param sourceConfig __object__   instance of CopySourceOptions @link ./helpers/CopySourceOptions\n   * @param destConfig  __object__   instance of CopyDestinationOptions @link ./helpers/CopyDestinationOptions\n   * @param cb __function__ called with null if there is an error\n   * @returns Promise if no callack is passed.\n   */\n  copyObjectV2(sourceConfig, destConfig, cb) {\n    if (!(sourceConfig instanceof CopySourceOptions)) {\n      throw new errors.InvalidArgumentError('sourceConfig should of type CopySourceOptions ')\n    }\n    if (!(destConfig instanceof CopyDestinationOptions)) {\n      throw new errors.InvalidArgumentError('destConfig should of type CopyDestinationOptions ')\n    }\n    if (!destConfig.validate()) {\n      return false\n    }\n    if (!destConfig.validate()) {\n      return false\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    const headers = Object.assign({}, sourceConfig.getHeaders(), destConfig.getHeaders())\n\n    const bucketName = destConfig.Bucket\n    const objectName = destConfig.Object\n\n    const method = 'PUT'\n    this.makeRequest({ method, bucketName, objectName, headers }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n      const transformer = transformers.getCopyObjectTransformer()\n      pipesetup(response, transformer)\n        .on('error', (e) => cb(e))\n        .on('data', (data) => {\n          const resHeaders = response.headers\n\n          const copyObjResponse = {\n            Bucket: destConfig.Bucket,\n            Key: destConfig.Object,\n            LastModified: data.LastModified,\n            MetaData: extractMetadata(resHeaders),\n            VersionId: getVersionId(resHeaders),\n            SourceVersionId: getSourceVersionId(resHeaders),\n            Etag: sanitizeETag(resHeaders.etag),\n            Size: +resHeaders['content-length'],\n          }\n\n          return cb(null, copyObjResponse)\n        })\n    })\n  }\n\n  // Backward compatibility for Copy Object API.\n  copyObject(...allArgs) {\n    if (allArgs[0] instanceof CopySourceOptions && allArgs[1] instanceof CopyDestinationOptions) {\n      return this.copyObjectV2(...arguments)\n    }\n    return this.copyObjectV1(...arguments)\n  }\n\n  // list a batch of objects\n  listObjectsQuery(bucketName, prefix, marker, listQueryOpts = {}) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isString(marker)) {\n      throw new TypeError('marker should be of type \"string\"')\n    }\n    let { Delimiter, MaxKeys, IncludeVersion } = listQueryOpts\n\n    if (!isObject(listQueryOpts)) {\n      throw new TypeError('listQueryOpts should be of type \"object\"')\n    }\n\n    if (!isString(Delimiter)) {\n      throw new TypeError('Delimiter should be of type \"string\"')\n    }\n    if (!isNumber(MaxKeys)) {\n      throw new TypeError('MaxKeys should be of type \"number\"')\n    }\n\n    const queries = []\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`)\n    queries.push(`delimiter=${uriEscape(Delimiter)}`)\n    queries.push(`encoding-type=url`)\n\n    if (IncludeVersion) {\n      queries.push(`versions`)\n    }\n\n    if (marker) {\n      marker = uriEscape(marker)\n      if (IncludeVersion) {\n        queries.push(`key-marker=${marker}`)\n      } else {\n        queries.push(`marker=${marker}`)\n      }\n    }\n\n    // no need to escape maxKeys\n    if (MaxKeys) {\n      if (MaxKeys >= 1000) {\n        MaxKeys = 1000\n      }\n      queries.push(`max-keys=${MaxKeys}`)\n    }\n    queries.sort()\n    var query = ''\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`\n    }\n\n    var method = 'GET'\n    var transformer = transformers.getListObjectsTransformer()\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e)\n      }\n      pipesetup(response, transformer)\n    })\n    return transformer\n  }\n\n  // List the objects in the bucket.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n  // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n  // * `listOpts _object_: query params to list object with below keys\n  // *    listOpts.MaxKeys _int_ maximum number of keys to return\n  // *    listOpts.IncludeVersion  _bool_ true|false to include versions.\n  // __Return Value__\n  // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n  // * `obj.name` _string_: name of the object\n  // * `obj.prefix` _string_: name of the object prefix\n  // * `obj.size` _number_: size of the object\n  // * `obj.etag` _string_: etag of the object\n  // * `obj.lastModified` _Date_: modified time stamp\n  // * `obj.isDeleteMarker` _boolean_: true if it is a delete marker\n  // * `obj.versionId` _string_: versionId of the object\n  listObjects(bucketName, prefix, recursive, listOpts = {}) {\n    if (prefix === undefined) {\n      prefix = ''\n    }\n    if (recursive === undefined) {\n      recursive = false\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"')\n    }\n    if (!isObject(listOpts)) {\n      throw new TypeError('listOpts should be of type \"object\"')\n    }\n    var marker = ''\n    const listQueryOpts = {\n      Delimiter: recursive ? '' : '/', // if recursive is false set delimiter to '/'\n      MaxKeys: 1000,\n      IncludeVersion: listOpts.IncludeVersion,\n    }\n    var objects = []\n    var ended = false\n    var readStream = Stream.Readable({ objectMode: true })\n    readStream._read = () => {\n      // push one object per _read()\n      if (objects.length) {\n        readStream.push(objects.shift())\n        return\n      }\n      if (ended) {\n        return readStream.push(null)\n      }\n      // if there are no objects to push do query for the next batch of objects\n      this.listObjectsQuery(bucketName, prefix, marker, listQueryOpts)\n        .on('error', (e) => readStream.emit('error', e))\n        .on('data', (result) => {\n          if (result.isTruncated) {\n            marker = result.nextMarker || result.versionIdMarker\n          } else {\n            ended = true\n          }\n          objects = result.objects\n          readStream._read()\n        })\n    }\n    return readStream\n  }\n\n  // listObjectsV2Query - (List Objects V2) - List some or all (up to 1000) of the objects in a bucket.\n  //\n  // You can use the request parameters as selection criteria to return a subset of the objects in a bucket.\n  // request parameters :-\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: Limits the response to keys that begin with the specified prefix.\n  // * `continuation-token` _string_: Used to continue iterating over a set of objects.\n  // * `delimiter` _string_: A delimiter is a character you use to group keys.\n  // * `max-keys` _number_: Sets the maximum number of keys returned in the response body.\n  // * `start-after` _string_: Specifies the key to start after when listing objects in a bucket.\n  listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, maxKeys, startAfter) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isString(continuationToken)) {\n      throw new TypeError('continuationToken should be of type \"string\"')\n    }\n    if (!isString(delimiter)) {\n      throw new TypeError('delimiter should be of type \"string\"')\n    }\n    if (!isNumber(maxKeys)) {\n      throw new TypeError('maxKeys should be of type \"number\"')\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"')\n    }\n    var queries = []\n\n    // Call for listing objects v2 API\n    queries.push(`list-type=2`)\n    queries.push(`encoding-type=url`)\n\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`)\n    queries.push(`delimiter=${uriEscape(delimiter)}`)\n\n    if (continuationToken) {\n      continuationToken = uriEscape(continuationToken)\n      queries.push(`continuation-token=${continuationToken}`)\n    }\n    // Set start-after\n    if (startAfter) {\n      startAfter = uriEscape(startAfter)\n      queries.push(`start-after=${startAfter}`)\n    }\n    // no need to escape maxKeys\n    if (maxKeys) {\n      if (maxKeys >= 1000) {\n        maxKeys = 1000\n      }\n      queries.push(`max-keys=${maxKeys}`)\n    }\n    queries.sort()\n    var query = ''\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`\n    }\n    var method = 'GET'\n    var transformer = transformers.getListObjectsV2Transformer()\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e)\n      }\n      pipesetup(response, transformer)\n    })\n    return transformer\n  }\n\n  // List the objects in the bucket using S3 ListObjects V2\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `prefix` _string_: the prefix of the objects that should be listed (optional, default `''`)\n  // * `recursive` _bool_: `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n  // * `startAfter` _string_: Specifies the key to start after when listing objects in a bucket. (optional, default `''`)\n  //\n  // __Return Value__\n  // * `stream` _Stream_: stream emitting the objects in the bucket, the object is of the format:\n  //   * `obj.name` _string_: name of the object\n  //   * `obj.prefix` _string_: name of the object prefix\n  //   * `obj.size` _number_: size of the object\n  //   * `obj.etag` _string_: etag of the object\n  //   * `obj.lastModified` _Date_: modified time stamp\n  listObjectsV2(bucketName, prefix, recursive, startAfter) {\n    if (prefix === undefined) {\n      prefix = ''\n    }\n    if (recursive === undefined) {\n      recursive = false\n    }\n    if (startAfter === undefined) {\n      startAfter = ''\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"')\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"')\n    }\n    // if recursive is false set delimiter to '/'\n    var delimiter = recursive ? '' : '/'\n    var continuationToken = ''\n    var objects = []\n    var ended = false\n    var readStream = Stream.Readable({ objectMode: true })\n    readStream._read = () => {\n      // push one object per _read()\n      if (objects.length) {\n        readStream.push(objects.shift())\n        return\n      }\n      if (ended) {\n        return readStream.push(null)\n      }\n      // if there are no objects to push do query for the next batch of objects\n      this.listObjectsV2Query(bucketName, prefix, continuationToken, delimiter, 1000, startAfter)\n        .on('error', (e) => readStream.emit('error', e))\n        .on('data', (result) => {\n          if (result.isTruncated) {\n            continuationToken = result.nextContinuationToken\n          } else {\n            ended = true\n          }\n          objects = result.objects\n          readStream._read()\n        })\n    }\n    return readStream\n  }\n\n  // Remove all the objects residing in the objectsList.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectsList` _array_: array of objects of one of the following:\n  // *         List of Object names as array of strings which are object keys:  ['objectname1','objectname2']\n  // *         List of Object name and versionId as an object:  [{name:\"objectname\",versionId:\"my-version-id\"}]\n\n  removeObjects(bucketName, objectsList, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!Array.isArray(objectsList)) {\n      throw new errors.InvalidArgumentError('objectsList should be a list')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    const maxEntries = 1000\n    const query = 'delete'\n    const method = 'POST'\n\n    let result = objectsList.reduce(\n      (result, entry) => {\n        result.list.push(entry)\n        if (result.list.length === maxEntries) {\n          result.listOfList.push(result.list)\n          result.list = []\n        }\n        return result\n      },\n      { listOfList: [], list: [] },\n    )\n\n    if (result.list.length > 0) {\n      result.listOfList.push(result.list)\n    }\n\n    const encoder = new TextEncoder()\n    const batchResults = []\n\n    async.eachSeries(\n      result.listOfList,\n      (list, batchCb) => {\n        var objects = []\n        list.forEach(function (value) {\n          if (isObject(value)) {\n            objects.push({ Key: value.name, VersionId: value.versionId })\n          } else {\n            objects.push({ Key: value })\n          }\n        })\n        let deleteObjects = { Delete: { Quiet: true, Object: objects } }\n        const builder = new xml2js.Builder({ headless: true })\n        let payload = builder.buildObject(deleteObjects)\n        payload = Buffer.from(encoder.encode(payload))\n        const headers = {}\n\n        headers['Content-MD5'] = toMd5(payload)\n\n        let removeObjectsResult\n        this.makeRequest({ method, bucketName, query, headers }, payload, [200], '', true, (e, response) => {\n          if (e) {\n            return batchCb(e)\n          }\n          pipesetup(response, transformers.removeObjectsTransformer())\n            .on('data', (data) => {\n              removeObjectsResult = data\n            })\n            .on('error', (e) => {\n              return batchCb(e, null)\n            })\n            .on('end', () => {\n              batchResults.push(removeObjectsResult)\n              return batchCb(null, removeObjectsResult)\n            })\n        })\n      },\n      () => {\n        cb(null, _.flatten(batchResults))\n      },\n    )\n  }\n\n  // Get the policy on a bucket or an object prefix.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `callback(err, policy)` _function_: callback function\n  getBucketPolicy(bucketName, cb) {\n    // Validate arguments.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    let method = 'GET'\n    let query = 'policy'\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let policy = Buffer.from('')\n      pipesetup(response, transformers.getConcater())\n        .on('data', (data) => (policy = data))\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, policy.toString())\n        })\n    })\n  }\n\n  // Set the policy on a bucket or an object prefix.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `bucketPolicy` _string_: bucket policy (JSON stringify'ed)\n  // * `callback(err)` _function_: callback function\n  setBucketPolicy(bucketName, policy, cb) {\n    // Validate arguments.\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isString(policy)) {\n      throw new errors.InvalidBucketPolicyError(`Invalid bucket policy: ${policy} - must be \"string\"`)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    let method = 'DELETE'\n    let query = 'policy'\n\n    if (policy) {\n      method = 'PUT'\n    }\n\n    this.makeRequest({ method, bucketName, query }, policy, [204], '', false, cb)\n  }\n\n  // Generate a generic presigned URL which can be\n  // used for HTTP methods GET, PUT, HEAD and DELETE\n  //\n  // __Arguments__\n  // * `method` _string_: name of the HTTP method\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  // * `reqParams` _object_: request parameters (optional) e.g {versionId:\"10fa9946-3f64-4137-a58f-888065c0732e\"}\n  // * `requestDate` _Date_: A date object, the url will be issued at (optional)\n  presignedUrl(method, bucketName, objectName, expires, reqParams, requestDate, cb) {\n    if (this.anonymous) {\n      throw new errors.AnonymousRequestError('Presigned ' + method + ' url cannot be generated for anonymous requests')\n    }\n    if (isFunction(requestDate)) {\n      cb = requestDate\n      requestDate = new Date()\n    }\n    if (isFunction(reqParams)) {\n      cb = reqParams\n      reqParams = {}\n      requestDate = new Date()\n    }\n    if (isFunction(expires)) {\n      cb = expires\n      reqParams = {}\n      expires = 24 * 60 * 60 * 7 // 7 days in seconds\n      requestDate = new Date()\n    }\n    if (!isNumber(expires)) {\n      throw new TypeError('expires should be of type \"number\"')\n    }\n    if (!isObject(reqParams)) {\n      throw new TypeError('reqParams should be of type \"object\"')\n    }\n    if (!isValidDate(requestDate)) {\n      throw new TypeError('requestDate should be of type \"Date\" and valid')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    var query = querystring.stringify(reqParams)\n    this.getBucketRegion(bucketName, (e, region) => {\n      if (e) {\n        return cb(e)\n      }\n      // This statement is added to ensure that we send error through\n      // callback on presign failure.\n      var url\n      var reqOptions = this.getRequestOptions({ method, region, bucketName, objectName, query })\n\n      this.checkAndRefreshCreds()\n      try {\n        url = presignSignatureV4(\n          reqOptions,\n          this.accessKey,\n          this.secretKey,\n          this.sessionToken,\n          region,\n          requestDate,\n          expires,\n        )\n      } catch (pe) {\n        return cb(pe)\n      }\n      cb(null, url)\n    })\n  }\n\n  // Generate a presigned URL for GET\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  // * `respHeaders` _object_: response headers to override or request params for query (optional) e.g {versionId:\"10fa9946-3f64-4137-a58f-888065c0732e\"}\n  // * `requestDate` _Date_: A date object, the url will be issued at (optional)\n  presignedGetObject(bucketName, objectName, expires, respHeaders, requestDate, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    if (isFunction(respHeaders)) {\n      cb = respHeaders\n      respHeaders = {}\n      requestDate = new Date()\n    }\n\n    var validRespHeaders = [\n      'response-content-type',\n      'response-content-language',\n      'response-expires',\n      'response-cache-control',\n      'response-content-disposition',\n      'response-content-encoding',\n    ]\n    validRespHeaders.forEach((header) => {\n      if (respHeaders !== undefined && respHeaders[header] !== undefined && !isString(respHeaders[header])) {\n        throw new TypeError(`response header ${header} should be of type \"string\"`)\n      }\n    })\n    return this.presignedUrl('GET', bucketName, objectName, expires, respHeaders, requestDate, cb)\n  }\n\n  // Generate a presigned URL for PUT. Using this URL, the browser can upload to S3 only with the specified object name.\n  //\n  // __Arguments__\n  // * `bucketName` _string_: name of the bucket\n  // * `objectName` _string_: name of the object\n  // * `expiry` _number_: expiry in seconds (optional, default 7 days)\n  presignedPutObject(bucketName, objectName, expires, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    return this.presignedUrl('PUT', bucketName, objectName, expires, cb)\n  }\n\n  // return PostPolicy object\n  newPostPolicy() {\n    return new PostPolicy()\n  }\n\n  // presignedPostPolicy can be used in situations where we want more control on the upload than what\n  // presignedPutObject() provides. i.e Using presignedPostPolicy we will be able to put policy restrictions\n  // on the object's `name` `bucket` `expiry` `Content-Type` `Content-Disposition` `metaData`\n  presignedPostPolicy(postPolicy, cb) {\n    if (this.anonymous) {\n      throw new errors.AnonymousRequestError('Presigned POST policy cannot be generated for anonymous requests')\n    }\n    if (!isObject(postPolicy)) {\n      throw new TypeError('postPolicy should be of type \"object\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"')\n    }\n    this.getBucketRegion(postPolicy.formData.bucket, (e, region) => {\n      if (e) {\n        return cb(e)\n      }\n      var date = new Date()\n      var dateStr = makeDateLong(date)\n\n      this.checkAndRefreshCreds()\n\n      if (!postPolicy.policy.expiration) {\n        // 'expiration' is mandatory field for S3.\n        // Set default expiration date of 7 days.\n        var expires = new Date()\n        expires.setSeconds(24 * 60 * 60 * 7)\n        postPolicy.setExpires(expires)\n      }\n\n      postPolicy.policy.conditions.push(['eq', '$x-amz-date', dateStr])\n      postPolicy.formData['x-amz-date'] = dateStr\n\n      postPolicy.policy.conditions.push(['eq', '$x-amz-algorithm', 'AWS4-HMAC-SHA256'])\n      postPolicy.formData['x-amz-algorithm'] = 'AWS4-HMAC-SHA256'\n\n      postPolicy.policy.conditions.push(['eq', '$x-amz-credential', this.accessKey + '/' + getScope(region, date)])\n      postPolicy.formData['x-amz-credential'] = this.accessKey + '/' + getScope(region, date)\n\n      if (this.sessionToken) {\n        postPolicy.policy.conditions.push(['eq', '$x-amz-security-token', this.sessionToken])\n        postPolicy.formData['x-amz-security-token'] = this.sessionToken\n      }\n\n      var policyBase64 = Buffer.from(JSON.stringify(postPolicy.policy)).toString('base64')\n\n      postPolicy.formData.policy = policyBase64\n\n      var signature = postPresignSignatureV4(region, date, this.secretKey, policyBase64)\n\n      postPolicy.formData['x-amz-signature'] = signature\n      var opts = {}\n      opts.region = region\n      opts.bucketName = postPolicy.formData.bucket\n      var reqOptions = this.getRequestOptions(opts)\n      var portStr = this.port == 80 || this.port === 443 ? '' : `:${this.port.toString()}`\n      var urlStr = `${reqOptions.protocol}//${reqOptions.host}${portStr}${reqOptions.path}`\n      cb(null, { postURL: urlStr, formData: postPolicy.formData })\n    })\n  }\n\n  // Complete the multipart upload. After all the parts are uploaded issuing\n  // this call will aggregate the parts on the server into a single object.\n  completeMultipartUpload(bucketName, objectName, uploadId, etags, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"')\n    }\n    if (!isObject(etags)) {\n      throw new TypeError('etags should be of type \"Array\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"')\n    }\n\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty')\n    }\n\n    var method = 'POST'\n    var query = `uploadId=${uriEscape(uploadId)}`\n\n    var parts = []\n\n    etags.forEach((element) => {\n      parts.push({\n        Part: [\n          {\n            PartNumber: element.part,\n          },\n          {\n            ETag: element.etag,\n          },\n        ],\n      })\n    })\n\n    var payloadObject = { CompleteMultipartUpload: parts }\n    var payload = Xml(payloadObject)\n\n    this.makeRequest({ method, bucketName, objectName, query }, payload, [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n      var transformer = transformers.getCompleteMultipartTransformer()\n      pipesetup(response, transformer)\n        .on('error', (e) => cb(e))\n        .on('data', (result) => {\n          if (result.errCode) {\n            // Multipart Complete API returns an error XML after a 200 http status\n            cb(new errors.S3Error(result.errMessage))\n          } else {\n            const completeMultipartResult = {\n              etag: result.etag,\n              versionId: getVersionId(response.headers),\n            }\n            cb(null, completeMultipartResult)\n          }\n        })\n    })\n  }\n\n  // Called by listIncompleteUploads to fetch a batch of incomplete uploads.\n  listIncompleteUploadsQuery(bucketName, prefix, keyMarker, uploadIdMarker, delimiter) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isString(keyMarker)) {\n      throw new TypeError('keyMarker should be of type \"string\"')\n    }\n    if (!isString(uploadIdMarker)) {\n      throw new TypeError('uploadIdMarker should be of type \"string\"')\n    }\n    if (!isString(delimiter)) {\n      throw new TypeError('delimiter should be of type \"string\"')\n    }\n    var queries = []\n    queries.push(`prefix=${uriEscape(prefix)}`)\n    queries.push(`delimiter=${uriEscape(delimiter)}`)\n\n    if (keyMarker) {\n      keyMarker = uriEscape(keyMarker)\n      queries.push(`key-marker=${keyMarker}`)\n    }\n    if (uploadIdMarker) {\n      queries.push(`upload-id-marker=${uploadIdMarker}`)\n    }\n\n    var maxUploads = 1000\n    queries.push(`max-uploads=${maxUploads}`)\n    queries.sort()\n    queries.unshift('uploads')\n    var query = ''\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`\n    }\n    var method = 'GET'\n    var transformer = transformers.getListMultipartTransformer()\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return transformer.emit('error', e)\n      }\n      pipesetup(response, transformer)\n    })\n    return transformer\n  }\n\n  // Find uploadId of an incomplete upload.\n  findUploadId(bucketName, objectName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('cb should be of type \"function\"')\n    }\n    var latestUpload\n    var listNext = (keyMarker, uploadIdMarker) => {\n      this.listIncompleteUploadsQuery(bucketName, objectName, keyMarker, uploadIdMarker, '')\n        .on('error', (e) => cb(e))\n        .on('data', (result) => {\n          result.uploads.forEach((upload) => {\n            if (upload.key === objectName) {\n              if (!latestUpload || upload.initiated.getTime() > latestUpload.initiated.getTime()) {\n                latestUpload = upload\n                return\n              }\n            }\n          })\n          if (result.isTruncated) {\n            listNext(result.nextKeyMarker, result.nextUploadIdMarker)\n            return\n          }\n          if (latestUpload) {\n            return cb(null, latestUpload.uploadId)\n          }\n          cb(null, undefined)\n        })\n    }\n    listNext('', '')\n  }\n\n  // Remove all the notification configurations in the S3 provider\n  setBucketNotification(bucketName, config, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isObject(config)) {\n      throw new TypeError('notification config should be of type \"Object\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    var method = 'PUT'\n    var query = 'notification'\n    var builder = new xml2js.Builder({\n      rootName: 'NotificationConfiguration',\n      renderOpts: { pretty: false },\n      headless: true,\n    })\n    var payload = builder.buildObject(config)\n    this.makeRequest({ method, bucketName, query }, payload, [200], '', false, cb)\n  }\n\n  removeAllBucketNotification(bucketName, cb) {\n    this.setBucketNotification(bucketName, new NotificationConfig(), cb)\n  }\n\n  // Return the list of notification configurations stored\n  // in the S3 provider\n  getBucketNotification(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    var method = 'GET'\n    var query = 'notification'\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n      var transformer = transformers.getBucketNotificationTransformer()\n      var bucketNotification\n      pipesetup(response, transformer)\n        .on('data', (result) => (bucketNotification = result))\n        .on('error', (e) => cb(e))\n        .on('end', () => cb(null, bucketNotification))\n    })\n  }\n\n  // Listens for bucket notifications. Returns an EventEmitter.\n  listenBucketNotification(bucketName, prefix, suffix, events) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix must be of type string')\n    }\n    if (!isString(suffix)) {\n      throw new TypeError('suffix must be of type string')\n    }\n    if (!Array.isArray(events)) {\n      throw new TypeError('events must be of type Array')\n    }\n    let listener = new NotificationPoller(this, bucketName, prefix, suffix, events)\n    listener.start()\n\n    return listener\n  }\n\n  getBucketVersioning(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n    var method = 'GET'\n    var query = 'versioning'\n\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let versionConfig = Buffer.from('')\n      pipesetup(response, transformers.bucketVersioningTransformer())\n        .on('data', (data) => {\n          versionConfig = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, versionConfig)\n        })\n    })\n  }\n\n  setBucketVersioning(bucketName, versionConfig, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!Object.keys(versionConfig).length) {\n      throw new errors.InvalidArgumentError('versionConfig should be of type \"object\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    var method = 'PUT'\n    var query = 'versioning'\n    var builder = new xml2js.Builder({\n      rootName: 'VersioningConfiguration',\n      renderOpts: { pretty: false },\n      headless: true,\n    })\n    var payload = builder.buildObject(versionConfig)\n\n    this.makeRequest({ method, bucketName, query }, payload, [200], '', false, cb)\n  }\n\n  /** To set Tags on a bucket or object based on the params\n   *  __Arguments__\n   * taggingParams _object_ Which contains the following properties\n   *  bucketName _string_,\n   *  objectName _string_ (Optional),\n   *  tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   *  putOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   *  cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setTagging(taggingParams) {\n    const { bucketName, objectName, tags, putOpts = {}, cb } = taggingParams\n    const method = 'PUT'\n    let query = 'tagging'\n\n    if (putOpts && putOpts.versionId) {\n      query = `${query}&versionId=${putOpts.versionId}`\n    }\n    const tagsList = []\n    for (const [key, value] of Object.entries(tags)) {\n      tagsList.push({ Key: key, Value: value })\n    }\n    const taggingConfig = {\n      Tagging: {\n        TagSet: {\n          Tag: tagsList,\n        },\n      },\n    }\n    const encoder = new TextEncoder()\n    const headers = {}\n    const builder = new xml2js.Builder({ headless: true, renderOpts: { pretty: false } })\n    let payload = builder.buildObject(taggingConfig)\n    payload = Buffer.from(encoder.encode(payload))\n    headers['Content-MD5'] = toMd5(payload)\n    const requestOptions = { method, bucketName, query, headers }\n\n    if (objectName) {\n      requestOptions['objectName'] = objectName\n    }\n    headers['Content-MD5'] = toMd5(payload)\n\n    this.makeRequest(requestOptions, payload, [200], '', false, cb)\n  }\n\n  /** Set Tags on a Bucket\n   * __Arguments__\n   * bucketName _string_\n   * tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setBucketTagging(bucketName, tags, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isObject(tags)) {\n      throw new errors.InvalidArgumentError('tags should be of type \"object\"')\n    }\n    if (Object.keys(tags).length > 10) {\n      throw new errors.InvalidArgumentError('maximum tags allowed is 10\"')\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n\n    return this.setTagging({ bucketName, tags, cb })\n  }\n\n  /** Set Tags on an Object\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_\n   *  * tags _object_ of the form {'<tag-key-1>':'<tag-value-1>','<tag-key-2>':'<tag-value-2>'}\n   *  putOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setObjectTagging(bucketName, objectName, tags, putOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName)\n    }\n\n    if (isFunction(putOpts)) {\n      cb = putOpts\n      putOpts = {}\n    }\n\n    if (!isObject(tags)) {\n      throw new errors.InvalidArgumentError('tags should be of type \"object\"')\n    }\n    if (Object.keys(tags).length > 10) {\n      throw new errors.InvalidArgumentError('Maximum tags allowed is 10\"')\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    return this.setTagging({ bucketName, objectName, tags, putOpts, cb })\n  }\n\n  /** Remove Tags on an Bucket/Object based on params\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_ (optional)\n   * removeOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"},\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeTagging({ bucketName, objectName, removeOpts, cb }) {\n    const method = 'DELETE'\n    let query = 'tagging'\n\n    if (removeOpts && Object.keys(removeOpts).length && removeOpts.versionId) {\n      query = `${query}&versionId=${removeOpts.versionId}`\n    }\n    const requestOptions = { method, bucketName, objectName, query }\n\n    if (objectName) {\n      requestOptions['objectName'] = objectName\n    }\n    this.makeRequest(requestOptions, '', [200, 204], '', true, cb)\n  }\n\n  /** Remove Tags associated with a bucket\n   *  __Arguments__\n   * bucketName _string_\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeBucketTagging(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n    return this.removeTagging({ bucketName, cb })\n  }\n\n  /** Remove tags associated with an object\n   * __Arguments__\n   * bucketName _string_\n   * objectName _string_\n   * removeOpts _object_ (Optional) e.g. {VersionID:\"my-object-version-id\"}\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeObjectTagging(bucketName, objectName, removeOpts, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName)\n    }\n    if (isFunction(removeOpts)) {\n      cb = removeOpts\n      removeOpts = {}\n    }\n    if (removeOpts && Object.keys(removeOpts).length && !isObject(removeOpts)) {\n      throw new errors.InvalidArgumentError('removeOpts should be of type \"object\"')\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    return this.removeTagging({ bucketName, objectName, removeOpts, cb })\n  }\n\n  /** Get Tags associated with a Bucket\n   *  __Arguments__\n   * bucketName _string_\n   * `cb(error, tags)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  getBucketTagging(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n\n    const method = 'GET'\n    const query = 'tagging'\n    const requestOptions = { method, bucketName, query }\n\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      var transformer = transformers.getTagsTransformer()\n      if (e) {\n        return cb(e)\n      }\n      let tagsList\n      pipesetup(response, transformer)\n        .on('data', (result) => (tagsList = result))\n        .on('error', (e) => cb(e))\n        .on('end', () => cb(null, tagsList))\n    })\n  }\n\n  /** Get the tags associated with a bucket OR an object\n   * bucketName _string_\n   * objectName _string_ (Optional)\n   * getOpts _object_ (Optional) e.g {versionId:\"my-object-version-id\"}\n   * `cb(error, tags)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  getObjectTagging(bucketName, objectName, getOpts = {}, cb = () => false) {\n    const method = 'GET'\n    let query = 'tagging'\n\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidBucketNameError('Invalid object name: ' + objectName)\n    }\n    if (isFunction(getOpts)) {\n      cb = getOpts\n      getOpts = {}\n    }\n    if (!isObject(getOpts)) {\n      throw new errors.InvalidArgumentError('getOpts should be of type \"object\"')\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    if (getOpts && getOpts.versionId) {\n      query = `${query}&versionId=${getOpts.versionId}`\n    }\n    const requestOptions = { method, bucketName, query }\n    if (objectName) {\n      requestOptions['objectName'] = objectName\n    }\n\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      const transformer = transformers.getTagsTransformer()\n      if (e) {\n        return cb(e)\n      }\n      let tagsList\n      pipesetup(response, transformer)\n        .on('data', (result) => (tagsList = result))\n        .on('error', (e) => cb(e))\n        .on('end', () => cb(null, tagsList))\n    })\n  }\n\n  /**\n   * Apply lifecycle configuration on a bucket.\n   * bucketName _string_\n   * policyConfig _object_ a valid policy configuration object.\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  applyBucketLifecycle(bucketName, policyConfig, cb) {\n    const method = 'PUT'\n    const query = 'lifecycle'\n\n    const encoder = new TextEncoder()\n    const headers = {}\n    const builder = new xml2js.Builder({\n      rootName: 'LifecycleConfiguration',\n      headless: true,\n      renderOpts: { pretty: false },\n    })\n    let payload = builder.buildObject(policyConfig)\n    payload = Buffer.from(encoder.encode(payload))\n    const requestOptions = { method, bucketName, query, headers }\n    headers['Content-MD5'] = toMd5(payload)\n\n    this.makeRequest(requestOptions, payload, [200], '', false, cb)\n  }\n\n  /** Remove lifecycle configuration of a bucket.\n   * bucketName _string_\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  removeBucketLifecycle(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    const method = 'DELETE'\n    const query = 'lifecycle'\n    this.makeRequest({ method, bucketName, query }, '', [204], '', false, cb)\n  }\n\n  /** Set/Override lifecycle configuration on a bucket. if the configuration is empty, it removes the configuration.\n   * bucketName _string_\n   * lifeCycleConfig _object_ one of the following values: (null or '') to remove the lifecycle configuration. or a valid lifecycle configuration\n   * `cb(error)` _function_ - callback function with `err` as the error argument. `err` is null if the operation is successful.\n   */\n  setBucketLifecycle(bucketName, lifeCycleConfig = null, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (_.isEmpty(lifeCycleConfig)) {\n      this.removeBucketLifecycle(bucketName, cb)\n    } else {\n      this.applyBucketLifecycle(bucketName, lifeCycleConfig, cb)\n    }\n  }\n\n  /** Get lifecycle configuration on a bucket.\n   * bucketName _string_\n   * `cb(config)` _function_ - callback function with lifecycle configuration as the error argument.\n   */\n  getBucketLifecycle(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    const method = 'GET'\n    const query = 'lifecycle'\n    const requestOptions = { method, bucketName, query }\n\n    this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      const transformer = transformers.lifecycleTransformer()\n      if (e) {\n        return cb(e)\n      }\n      let lifecycleConfig\n      pipesetup(response, transformer)\n        .on('data', (result) => (lifecycleConfig = result))\n        .on('error', (e) => cb(e))\n        .on('end', () => cb(null, lifecycleConfig))\n    })\n  }\n\n  setObjectLockConfig(bucketName, lockConfigOpts = {}, cb) {\n    const retentionModes = [RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE]\n    const validUnits = [RETENTION_VALIDITY_UNITS.DAYS, RETENTION_VALIDITY_UNITS.YEARS]\n\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n\n    if (lockConfigOpts.mode && !retentionModes.includes(lockConfigOpts.mode)) {\n      throw new TypeError(`lockConfigOpts.mode should be one of ${retentionModes}`)\n    }\n    if (lockConfigOpts.unit && !validUnits.includes(lockConfigOpts.unit)) {\n      throw new TypeError(`lockConfigOpts.unit should be one of ${validUnits}`)\n    }\n    if (lockConfigOpts.validity && !isNumber(lockConfigOpts.validity)) {\n      throw new TypeError(`lockConfigOpts.validity should be a number`)\n    }\n\n    const method = 'PUT'\n    const query = 'object-lock'\n\n    let config = {\n      ObjectLockEnabled: 'Enabled',\n    }\n    const configKeys = Object.keys(lockConfigOpts)\n    // Check if keys are present and all keys are present.\n    if (configKeys.length > 0) {\n      if (_.difference(configKeys, ['unit', 'mode', 'validity']).length !== 0) {\n        throw new TypeError(\n          `lockConfigOpts.mode,lockConfigOpts.unit,lockConfigOpts.validity all the properties should be specified.`,\n        )\n      } else {\n        config.Rule = {\n          DefaultRetention: {},\n        }\n        if (lockConfigOpts.mode) {\n          config.Rule.DefaultRetention.Mode = lockConfigOpts.mode\n        }\n        if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.DAYS) {\n          config.Rule.DefaultRetention.Days = lockConfigOpts.validity\n        } else if (lockConfigOpts.unit === RETENTION_VALIDITY_UNITS.YEARS) {\n          config.Rule.DefaultRetention.Years = lockConfigOpts.validity\n        }\n      }\n    }\n\n    const builder = new xml2js.Builder({\n      rootName: 'ObjectLockConfiguration',\n      renderOpts: { pretty: false },\n      headless: true,\n    })\n    const payload = builder.buildObject(config)\n\n    const headers = {}\n    headers['Content-MD5'] = toMd5(payload)\n\n    this.makeRequest({ method, bucketName, query, headers }, payload, [200], '', false, cb)\n  }\n\n  getObjectLockConfig(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n    const method = 'GET'\n    const query = 'object-lock'\n\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let objectLockConfig = Buffer.from('')\n      pipesetup(response, transformers.objectLockTransformer())\n        .on('data', (data) => {\n          objectLockConfig = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, objectLockConfig)\n        })\n    })\n  }\n\n  putObjectRetention(bucketName, objectName, retentionOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isObject(retentionOpts)) {\n      throw new errors.InvalidArgumentError('retentionOpts should be of type \"object\"')\n    } else {\n      if (retentionOpts.governanceBypass && !isBoolean(retentionOpts.governanceBypass)) {\n        throw new errors.InvalidArgumentError('Invalid value for governanceBypass', retentionOpts.governanceBypass)\n      }\n      if (\n        retentionOpts.mode &&\n        ![RETENTION_MODES.COMPLIANCE, RETENTION_MODES.GOVERNANCE].includes(retentionOpts.mode)\n      ) {\n        throw new errors.InvalidArgumentError('Invalid object retention mode ', retentionOpts.mode)\n      }\n      if (retentionOpts.retainUntilDate && !isString(retentionOpts.retainUntilDate)) {\n        throw new errors.InvalidArgumentError('Invalid value for retainUntilDate', retentionOpts.retainUntilDate)\n      }\n      if (retentionOpts.versionId && !isString(retentionOpts.versionId)) {\n        throw new errors.InvalidArgumentError('Invalid value for versionId', retentionOpts.versionId)\n      }\n    }\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    const method = 'PUT'\n    let query = 'retention'\n\n    const headers = {}\n    if (retentionOpts.governanceBypass) {\n      headers['X-Amz-Bypass-Governance-Retention'] = true\n    }\n\n    const builder = new xml2js.Builder({ rootName: 'Retention', renderOpts: { pretty: false }, headless: true })\n    const params = {}\n\n    if (retentionOpts.mode) {\n      params.Mode = retentionOpts.mode\n    }\n    if (retentionOpts.retainUntilDate) {\n      params.RetainUntilDate = retentionOpts.retainUntilDate\n    }\n    if (retentionOpts.versionId) {\n      query += `&versionId=${retentionOpts.versionId}`\n    }\n\n    let payload = builder.buildObject(params)\n\n    headers['Content-MD5'] = toMd5(payload)\n    this.makeRequest({ method, bucketName, objectName, query, headers }, payload, [200, 204], '', false, cb)\n  }\n\n  getObjectRetention(bucketName, objectName, getOpts, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isObject(getOpts)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"object\"')\n    } else if (getOpts.versionId && !isString(getOpts.versionId)) {\n      throw new errors.InvalidArgumentError('VersionID should be of type \"string\"')\n    }\n    if (cb && !isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n    const method = 'GET'\n    let query = 'retention'\n    if (getOpts.versionId) {\n      query += `&versionId=${getOpts.versionId}`\n    }\n\n    this.makeRequest({ method, bucketName, objectName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let retentionConfig = Buffer.from('')\n      pipesetup(response, transformers.objectRetentionTransformer())\n        .on('data', (data) => {\n          retentionConfig = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, retentionConfig)\n        })\n    })\n  }\n\n  setBucketEncryption(bucketName, encryptionConfig, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n\n    if (isFunction(encryptionConfig)) {\n      cb = encryptionConfig\n      encryptionConfig = null\n    }\n\n    if (!_.isEmpty(encryptionConfig) && encryptionConfig.Rule.length > 1) {\n      throw new errors.InvalidArgumentError('Invalid Rule length. Only one rule is allowed.: ' + encryptionConfig.Rule)\n    }\n    if (cb && !isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    let encryptionObj = encryptionConfig\n    if (_.isEmpty(encryptionConfig)) {\n      encryptionObj = {\n        // Default MinIO Server Supported Rule\n        Rule: [\n          {\n            ApplyServerSideEncryptionByDefault: {\n              SSEAlgorithm: 'AES256',\n            },\n          },\n        ],\n      }\n    }\n\n    let method = 'PUT'\n    let query = 'encryption'\n    let builder = new xml2js.Builder({\n      rootName: 'ServerSideEncryptionConfiguration',\n      renderOpts: { pretty: false },\n      headless: true,\n    })\n    let payload = builder.buildObject(encryptionObj)\n\n    const headers = {}\n    headers['Content-MD5'] = toMd5(payload)\n\n    this.makeRequest({ method, bucketName, query, headers }, payload, [200], '', false, cb)\n  }\n\n  getBucketEncryption(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n    const method = 'GET'\n    const query = 'encryption'\n\n    this.makeRequest({ method, bucketName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let bucketEncConfig = Buffer.from('')\n      pipesetup(response, transformers.bucketEncryptionTransformer())\n        .on('data', (data) => {\n          bucketEncConfig = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, bucketEncConfig)\n        })\n    })\n  }\n  removeBucketEncryption(bucketName, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n    const method = 'DELETE'\n    const query = 'encryption'\n\n    this.makeRequest({ method, bucketName, query }, '', [204], '', false, cb)\n  }\n\n  getObjectLegalHold(bucketName, objectName, getOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    if (isFunction(getOpts)) {\n      cb = getOpts\n      getOpts = {}\n    }\n\n    if (!isObject(getOpts)) {\n      throw new TypeError('getOpts should be of type \"Object\"')\n    } else if (Object.keys(getOpts).length > 0 && getOpts.versionId && !isString(getOpts.versionId)) {\n      throw new TypeError('versionId should be of type string.:', getOpts.versionId)\n    }\n\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n\n    const method = 'GET'\n    let query = 'legal-hold'\n\n    if (getOpts.versionId) {\n      query += `&versionId=${getOpts.versionId}`\n    }\n\n    this.makeRequest({ method, bucketName, objectName, query }, '', [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let legalHoldConfig = Buffer.from('')\n      pipesetup(response, transformers.objectLegalHoldTransformer())\n        .on('data', (data) => {\n          legalHoldConfig = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, legalHoldConfig)\n        })\n    })\n  }\n\n  setObjectLegalHold(bucketName, objectName, setOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    const defaultOpts = {\n      status: LEGAL_HOLD_STATUS.ENABLED,\n    }\n    if (isFunction(setOpts)) {\n      cb = setOpts\n      setOpts = defaultOpts\n    }\n\n    if (!isObject(setOpts)) {\n      throw new TypeError('setOpts should be of type \"Object\"')\n    } else {\n      if (![LEGAL_HOLD_STATUS.ENABLED, LEGAL_HOLD_STATUS.DISABLED].includes(setOpts.status)) {\n        throw new TypeError('Invalid status: ' + setOpts.status)\n      }\n      if (setOpts.versionId && !setOpts.versionId.length) {\n        throw new TypeError('versionId should be of type string.:' + setOpts.versionId)\n      }\n    }\n\n    if (!isFunction(cb)) {\n      throw new errors.InvalidArgumentError('callback should be of type \"function\"')\n    }\n\n    if (_.isEmpty(setOpts)) {\n      setOpts = {\n        defaultOpts,\n      }\n    }\n\n    const method = 'PUT'\n    let query = 'legal-hold'\n\n    if (setOpts.versionId) {\n      query += `&versionId=${setOpts.versionId}`\n    }\n\n    let config = {\n      Status: setOpts.status,\n    }\n\n    const builder = new xml2js.Builder({ rootName: 'LegalHold', renderOpts: { pretty: false }, headless: true })\n    const payload = builder.buildObject(config)\n    const headers = {}\n    headers['Content-MD5'] = toMd5(payload)\n\n    this.makeRequest({ method, bucketName, objectName, query, headers }, payload, [200], '', false, cb)\n  }\n\n  /**\n   * Internal method to upload a part during compose object.\n   * @param partConfig __object__ contains the following.\n   *    bucketName __string__\n   *    objectName __string__\n   *    uploadID __string__\n   *    partNumber __number__\n   *    headers __object__\n   * @param cb called with null incase of error.\n   */\n  uploadPartCopy(partConfig, cb) {\n    const { bucketName, objectName, uploadID, partNumber, headers } = partConfig\n\n    const method = 'PUT'\n    let query = `uploadId=${uploadID}&partNumber=${partNumber}`\n    const requestOptions = { method, bucketName, objectName: objectName, query, headers }\n    return this.makeRequest(requestOptions, '', [200], '', true, (e, response) => {\n      let partCopyResult = Buffer.from('')\n      if (e) {\n        return cb(e)\n      }\n      pipesetup(response, transformers.uploadPartTransformer())\n        .on('data', (data) => {\n          partCopyResult = data\n        })\n        .on('error', cb)\n        .on('end', () => {\n          let uploadPartCopyRes = {\n            etag: sanitizeETag(partCopyResult.ETag),\n            key: objectName,\n            part: partNumber,\n          }\n\n          cb(null, uploadPartCopyRes)\n        })\n    })\n  }\n\n  composeObject(destObjConfig = {}, sourceObjList = [], cb) {\n    const me = this // many async flows. so store the ref.\n    const sourceFilesLength = sourceObjList.length\n\n    if (!Array.isArray(sourceObjList)) {\n      throw new errors.InvalidArgumentError('sourceConfig should an array of CopySourceOptions ')\n    }\n    if (!(destObjConfig instanceof CopyDestinationOptions)) {\n      throw new errors.InvalidArgumentError('destConfig should of type CopyDestinationOptions ')\n    }\n\n    if (sourceFilesLength < 1 || sourceFilesLength > PART_CONSTRAINTS.MAX_PARTS_COUNT) {\n      throw new errors.InvalidArgumentError(\n        `\"There must be as least one and up to ${PART_CONSTRAINTS.MAX_PARTS_COUNT} source objects.`,\n      )\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    for (let i = 0; i < sourceFilesLength; i++) {\n      if (!sourceObjList[i].validate()) {\n        return false\n      }\n    }\n\n    if (!destObjConfig.validate()) {\n      return false\n    }\n\n    const getStatOptions = (srcConfig) => {\n      let statOpts = {}\n      if (!_.isEmpty(srcConfig.VersionID)) {\n        statOpts = {\n          versionId: srcConfig.VersionID,\n        }\n      }\n      return statOpts\n    }\n    const srcObjectSizes = []\n    let totalSize = 0\n    let totalParts = 0\n\n    const sourceObjStats = sourceObjList.map((srcItem) =>\n      me.statObject(srcItem.Bucket, srcItem.Object, getStatOptions(srcItem)),\n    )\n\n    return Promise.all(sourceObjStats)\n      .then((srcObjectInfos) => {\n        const validatedStats = srcObjectInfos.map((resItemStat, index) => {\n          const srcConfig = sourceObjList[index]\n\n          let srcCopySize = resItemStat.size\n          // Check if a segment is specified, and if so, is the\n          // segment within object bounds?\n          if (srcConfig.MatchRange) {\n            // Since range is specified,\n            //    0 <= src.srcStart <= src.srcEnd\n            // so only invalid case to check is:\n            const srcStart = srcConfig.Start\n            const srcEnd = srcConfig.End\n            if (srcEnd >= srcCopySize || srcStart < 0) {\n              throw new errors.InvalidArgumentError(\n                `CopySrcOptions ${index} has invalid segment-to-copy [${srcStart}, ${srcEnd}] (size is ${srcCopySize})`,\n              )\n            }\n            srcCopySize = srcEnd - srcStart + 1\n          }\n\n          // Only the last source may be less than `absMinPartSize`\n          if (srcCopySize < PART_CONSTRAINTS.ABS_MIN_PART_SIZE && index < sourceFilesLength - 1) {\n            throw new errors.InvalidArgumentError(\n              `CopySrcOptions ${index} is too small (${srcCopySize}) and it is not the last part.`,\n            )\n          }\n\n          // Is data to copy too large?\n          totalSize += srcCopySize\n          if (totalSize > PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE) {\n            throw new errors.InvalidArgumentError(`Cannot compose an object of size ${totalSize} (> 5TiB)`)\n          }\n\n          // record source size\n          srcObjectSizes[index] = srcCopySize\n\n          // calculate parts needed for current source\n          totalParts += partsRequired(srcCopySize)\n          // Do we need more parts than we are allowed?\n          if (totalParts > PART_CONSTRAINTS.MAX_PARTS_COUNT) {\n            throw new errors.InvalidArgumentError(\n              `Your proposed compose object requires more than ${PART_CONSTRAINTS.MAX_PARTS_COUNT} parts`,\n            )\n          }\n\n          return resItemStat\n        })\n\n        if ((totalParts === 1 && totalSize <= PART_CONSTRAINTS.MAX_PART_SIZE) || totalSize === 0) {\n          return this.copyObject(sourceObjList[0], destObjConfig, cb) // use copyObjectV2\n        }\n\n        // preserve etag to avoid modification of object while copying.\n        for (let i = 0; i < sourceFilesLength; i++) {\n          sourceObjList[i].MatchETag = validatedStats[i].etag\n        }\n\n        const splitPartSizeList = validatedStats.map((resItemStat, idx) => {\n          const calSize = calculateEvenSplits(srcObjectSizes[idx], sourceObjList[idx])\n          return calSize\n        })\n\n        function getUploadPartConfigList(uploadId) {\n          const uploadPartConfigList = []\n\n          splitPartSizeList.forEach((splitSize, splitIndex) => {\n            const { startIndex: startIdx, endIndex: endIdx, objInfo: objConfig } = splitSize\n\n            let partIndex = splitIndex + 1 // part index starts from 1.\n            const totalUploads = Array.from(startIdx)\n\n            const headers = sourceObjList[splitIndex].getHeaders()\n\n            totalUploads.forEach((splitStart, upldCtrIdx) => {\n              let splitEnd = endIdx[upldCtrIdx]\n\n              const sourceObj = `${objConfig.Bucket}/${objConfig.Object}`\n              headers['x-amz-copy-source'] = `${sourceObj}`\n              headers['x-amz-copy-source-range'] = `bytes=${splitStart}-${splitEnd}`\n\n              const uploadPartConfig = {\n                bucketName: destObjConfig.Bucket,\n                objectName: destObjConfig.Object,\n                uploadID: uploadId,\n                partNumber: partIndex,\n                headers: headers,\n                sourceObj: sourceObj,\n              }\n\n              uploadPartConfigList.push(uploadPartConfig)\n            })\n          })\n\n          return uploadPartConfigList\n        }\n\n        const performUploadParts = (uploadId) => {\n          const uploadList = getUploadPartConfigList(uploadId)\n\n          async.map(uploadList, me.uploadPartCopy.bind(me), (err, res) => {\n            if (err) {\n              this.abortMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId).then(\n                () => cb(),\n                (err) => cb(err),\n              )\n              return\n            }\n            const partsDone = res.map((partCopy) => ({ etag: partCopy.etag, part: partCopy.part }))\n            return me.completeMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, uploadId, partsDone, cb)\n          })\n        }\n\n        const newUploadHeaders = destObjConfig.getHeaders()\n\n        me.initiateNewMultipartUpload(destObjConfig.Bucket, destObjConfig.Object, newUploadHeaders).then(\n          (uploadId) => {\n            performUploadParts(uploadId)\n          },\n          (err) => {\n            cb(err, null)\n          },\n        )\n      })\n      .catch((error) => {\n        cb(error, null)\n      })\n  }\n  selectObjectContent(bucketName, objectName, selectOpts = {}, cb) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!_.isEmpty(selectOpts)) {\n      if (!isString(selectOpts.expression)) {\n        throw new TypeError('sqlExpression should be of type \"string\"')\n      }\n      if (!_.isEmpty(selectOpts.inputSerialization)) {\n        if (!isObject(selectOpts.inputSerialization)) {\n          throw new TypeError('inputSerialization should be of type \"object\"')\n        }\n      } else {\n        throw new TypeError('inputSerialization is required')\n      }\n      if (!_.isEmpty(selectOpts.outputSerialization)) {\n        if (!isObject(selectOpts.outputSerialization)) {\n          throw new TypeError('outputSerialization should be of type \"object\"')\n        }\n      } else {\n        throw new TypeError('outputSerialization is required')\n      }\n    } else {\n      throw new TypeError('valid select configuration is required')\n    }\n\n    if (!isFunction(cb)) {\n      throw new TypeError('callback should be of type \"function\"')\n    }\n\n    const method = 'POST'\n    let query = `select`\n    query += '&select-type=2'\n\n    const config = [\n      {\n        Expression: selectOpts.expression,\n      },\n      {\n        ExpressionType: selectOpts.expressionType || 'SQL',\n      },\n      {\n        InputSerialization: [selectOpts.inputSerialization],\n      },\n      {\n        OutputSerialization: [selectOpts.outputSerialization],\n      },\n    ]\n\n    // Optional\n    if (selectOpts.requestProgress) {\n      config.push({ RequestProgress: selectOpts.requestProgress })\n    }\n    // Optional\n    if (selectOpts.scanRange) {\n      config.push({ ScanRange: selectOpts.scanRange })\n    }\n\n    const builder = new xml2js.Builder({\n      rootName: 'SelectObjectContentRequest',\n      renderOpts: { pretty: false },\n      headless: true,\n    })\n    const payload = builder.buildObject(config)\n\n    this.makeRequest({ method, bucketName, objectName, query }, payload, [200], '', true, (e, response) => {\n      if (e) {\n        return cb(e)\n      }\n\n      let selectResult\n      pipesetup(response, transformers.selectObjectContentTransformer())\n        .on('data', (data) => {\n          selectResult = parseSelectObjectContentResponse(data)\n        })\n        .on('error', cb)\n        .on('end', () => {\n          cb(null, selectResult)\n        })\n    })\n  }\n}\n\n// Promisify various public-facing APIs on the Client module.\nClient.prototype.makeBucket = promisify(Client.prototype.makeBucket)\nClient.prototype.bucketExists = promisify(Client.prototype.bucketExists)\n\nClient.prototype.getObject = promisify(Client.prototype.getObject)\nClient.prototype.getPartialObject = promisify(Client.prototype.getPartialObject)\nClient.prototype.fGetObject = promisify(Client.prototype.fGetObject)\nClient.prototype.putObject = promisify(Client.prototype.putObject)\nClient.prototype.fPutObject = promisify(Client.prototype.fPutObject)\nClient.prototype.copyObject = promisify(Client.prototype.copyObject)\nClient.prototype.removeObjects = promisify(Client.prototype.removeObjects)\n\nClient.prototype.presignedUrl = promisify(Client.prototype.presignedUrl)\nClient.prototype.presignedGetObject = promisify(Client.prototype.presignedGetObject)\nClient.prototype.presignedPutObject = promisify(Client.prototype.presignedPutObject)\nClient.prototype.presignedPostPolicy = promisify(Client.prototype.presignedPostPolicy)\nClient.prototype.getBucketNotification = promisify(Client.prototype.getBucketNotification)\nClient.prototype.setBucketNotification = promisify(Client.prototype.setBucketNotification)\nClient.prototype.removeAllBucketNotification = promisify(Client.prototype.removeAllBucketNotification)\nClient.prototype.getBucketPolicy = promisify(Client.prototype.getBucketPolicy)\nClient.prototype.setBucketPolicy = promisify(Client.prototype.setBucketPolicy)\nClient.prototype.removeIncompleteUpload = promisify(Client.prototype.removeIncompleteUpload)\nClient.prototype.getBucketVersioning = promisify(Client.prototype.getBucketVersioning)\nClient.prototype.setBucketVersioning = promisify(Client.prototype.setBucketVersioning)\nClient.prototype.setBucketTagging = promisify(Client.prototype.setBucketTagging)\nClient.prototype.removeBucketTagging = promisify(Client.prototype.removeBucketTagging)\nClient.prototype.getBucketTagging = promisify(Client.prototype.getBucketTagging)\nClient.prototype.setObjectTagging = promisify(Client.prototype.setObjectTagging)\nClient.prototype.removeObjectTagging = promisify(Client.prototype.removeObjectTagging)\nClient.prototype.getObjectTagging = promisify(Client.prototype.getObjectTagging)\nClient.prototype.setBucketLifecycle = promisify(Client.prototype.setBucketLifecycle)\nClient.prototype.getBucketLifecycle = promisify(Client.prototype.getBucketLifecycle)\nClient.prototype.removeBucketLifecycle = promisify(Client.prototype.removeBucketLifecycle)\nClient.prototype.setObjectLockConfig = promisify(Client.prototype.setObjectLockConfig)\nClient.prototype.getObjectLockConfig = promisify(Client.prototype.getObjectLockConfig)\nClient.prototype.putObjectRetention = promisify(Client.prototype.putObjectRetention)\nClient.prototype.getObjectRetention = promisify(Client.prototype.getObjectRetention)\nClient.prototype.setBucketEncryption = promisify(Client.prototype.setBucketEncryption)\nClient.prototype.getBucketEncryption = promisify(Client.prototype.getBucketEncryption)\nClient.prototype.removeBucketEncryption = promisify(Client.prototype.removeBucketEncryption)\nClient.prototype.setObjectLegalHold = promisify(Client.prototype.setObjectLegalHold)\nClient.prototype.getObjectLegalHold = promisify(Client.prototype.getObjectLegalHold)\nClient.prototype.composeObject = promisify(Client.prototype.composeObject)\nClient.prototype.selectObjectContent = promisify(Client.prototype.selectObjectContent)\n\n// refactored API use promise internally\nClient.prototype.removeObject = callbackify(Client.prototype.removeObject)\nClient.prototype.statObject = callbackify(Client.prototype.statObject)\nClient.prototype.removeBucket = callbackify(Client.prototype.removeBucket)\nClient.prototype.listBuckets = callbackify(Client.prototype.listBuckets)\nClient.prototype.removeBucketReplication = callbackify(Client.prototype.removeBucketReplication)\nClient.prototype.setBucketReplication = callbackify(Client.prototype.setBucketReplication)\nClient.prototype.getBucketReplication = callbackify(Client.prototype.getBucketReplication)\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE;AACd,OAAO,KAAKC,IAAI;AAChB,OAAO,KAAKC,MAAM;AAElB,OAAOC,KAAK,MAAM,OAAO;AACzB,OAAOC,YAAY,MAAM,eAAe;AACxC,OAAOC,CAAC,MAAM,QAAQ;AACtB,OAAO,KAAKC,WAAW,MAAM,cAAc;AAC3C,SAASC,WAAW,QAAQ,cAAc;AAC1C,OAAOC,GAAG,MAAM,KAAK;AACrB,OAAOC,MAAM,MAAM,QAAQ;AAE3B,OAAO,KAAKC,MAAM,MAAM,cAAa;AACrC,SAASC,sBAAsB,EAAEC,iBAAiB,EAAEC,cAAc,QAAQ,eAAc;AACxF,SAASC,WAAW,QAAQ,4BAA2B;AACvD,SAASC,WAAW,QAAQ,uBAAsB;AAClD,SAASC,cAAc,QAAQ,gCAA+B;AAC9D,SACEC,mBAAmB,EACnBC,eAAe,EACfC,QAAQ,EACRC,kBAAkB,EAClBC,YAAY,EACZC,iBAAiB,EACjBC,SAAS,EACTC,UAAU,EACVC,QAAQ,EACRC,QAAQ,EACRC,gBAAgB,EAChBC,QAAQ,EACRC,iBAAiB,EACjBC,WAAW,EACXC,iBAAiB,EACjBC,aAAa,EACbC,YAAY,EACZC,gBAAgB,EAChBC,aAAa,EACbC,SAAS,EACTC,eAAe,EACfC,cAAc,EACdC,YAAY,EACZC,KAAK,EACLC,SAAS,EACTC,iBAAiB,QACZ,uBAAsB;AAC7B,SAASC,UAAU,QAAQ,4BAA2B;AACtD,SAASC,iBAAiB,EAAEC,eAAe,EAAEC,wBAAwB,QAAQ,qBAAoB;AACjG,SAASC,kBAAkB,EAAEC,kBAAkB,QAAQ,oBAAmB;AAC1E,SAASC,cAAc,QAAQ,uBAAsB;AACrD,SAASC,SAAS,QAAQ,iBAAgB;AAC1C,SAASC,sBAAsB,EAAEC,kBAAkB,QAAQ,eAAc;AACzE,OAAO,KAAKC,YAAY,MAAM,oBAAmB;AACjD,SAASC,gCAAgC,QAAQ,mBAAkB;AAEnE,cAAc,eAAc;AAC5B,cAAc,oBAAmB;AACjC,SAAStC,cAAc,EAAE2B,UAAU;AAEnC,OAAO,MAAMY,MAAM,SAASxC,WAAW,CAAC;EACtC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAyC,UAAUA,CAACC,OAAO,EAAEC,UAAU,EAAE;IAC9B,IAAI,CAAC9B,QAAQ,CAAC6B,OAAO,CAAC,EAAE;MACtB,MAAM,IAAIE,SAAS,CAAE,oBAAmBF,OAAQ,EAAC,CAAC;IACpD;IACA,IAAIA,OAAO,CAACG,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MACzB,MAAM,IAAIlD,MAAM,CAACmD,oBAAoB,CAAC,gCAAgC,CAAC;IACzE;IACA,IAAI,CAACjC,QAAQ,CAAC8B,UAAU,CAAC,EAAE;MACzB,MAAM,IAAIC,SAAS,CAAE,uBAAsBD,UAAW,EAAC,CAAC;IAC1D;IACA,IAAIA,UAAU,CAACE,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;MAC5B,MAAM,IAAIlD,MAAM,CAACmD,oBAAoB,CAAC,mCAAmC,CAAC;IAC5E;IACA,IAAI,CAACC,SAAS,GAAI,GAAE,IAAI,CAACA,SAAU,IAAGL,OAAQ,IAAGC,UAAW,EAAC;EAC/D;;EAEA;EACAK,iBAAiBA,CAACC,IAAI,EAAE;IACtB,IAAI,CAACvC,QAAQ,CAACuC,IAAI,CAAC,EAAE;MACnB,MAAM,IAAIL,SAAS,CAAC,iCAAiC,CAAC;IACxD;IACA,IAAIK,IAAI,GAAG,IAAI,CAACC,aAAa,EAAE;MAC7B,MAAM,IAAIN,SAAS,CAAE,gCAA+B,IAAI,CAACM,aAAc,EAAC,CAAC;IAC3E;IACA,IAAI,IAAI,CAACC,gBAAgB,EAAE;MACzB,OAAO,IAAI,CAACC,QAAQ;IACtB;IACA,IAAIA,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,SAAS;MACP;MACA;MACA,IAAIA,QAAQ,GAAG,KAAK,GAAGH,IAAI,EAAE;QAC3B,OAAOG,QAAQ;MACjB;MACA;MACAA,QAAQ,IAAI,EAAE,GAAG,IAAI,GAAG,IAAI;IAC9B;EACF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,UAAUA,CAACC,UAAU,EAAEC,MAAM,EAAEC,QAAQ,GAAG,CAAC,CAAC,EAAEC,EAAE,EAAE;IAChD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA;IACA,IAAI3C,QAAQ,CAAC4C,MAAM,CAAC,EAAE;MACpBE,EAAE,GAAGD,QAAQ;MACbA,QAAQ,GAAGD,MAAM;MACjBA,MAAM,GAAG,EAAE;IACb;IACA,IAAI9C,UAAU,CAAC8C,MAAM,CAAC,EAAE;MACtBE,EAAE,GAAGF,MAAM;MACXA,MAAM,GAAG,EAAE;MACXC,QAAQ,GAAG,CAAC,CAAC;IACf;IACA,IAAI/C,UAAU,CAAC+C,QAAQ,CAAC,EAAE;MACxBC,EAAE,GAAGD,QAAQ;MACbA,QAAQ,GAAG,CAAC,CAAC;IACf;IAEA,IAAI,CAAC3C,QAAQ,CAAC0C,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIX,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAACjC,QAAQ,CAAC6C,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAIZ,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIe,OAAO,GAAG,EAAE;;IAEhB;IACA;IACA,IAAIJ,MAAM,IAAI,IAAI,CAACA,MAAM,EAAE;MACzB,IAAIA,MAAM,KAAK,IAAI,CAACA,MAAM,EAAE;QAC1B,MAAM,IAAI5D,MAAM,CAACmD,oBAAoB,CAAE,qBAAoB,IAAI,CAACS,MAAO,eAAcA,MAAO,EAAC,CAAC;MAChG;IACF;IACA;IACA;IACA,IAAIA,MAAM,IAAIA,MAAM,KAAKzD,cAAc,EAAE;MACvC,IAAI8D,yBAAyB,GAAG,EAAE;MAClCA,yBAAyB,CAACC,IAAI,CAAC;QAC7BC,KAAK,EAAE;UACLC,KAAK,EAAE;QACT;MACF,CAAC,CAAC;MACFH,yBAAyB,CAACC,IAAI,CAAC;QAC7BG,kBAAkB,EAAET;MACtB,CAAC,CAAC;MACF,IAAIU,aAAa,GAAG;QAClBC,yBAAyB,EAAEN;MAC7B,CAAC;MACDD,OAAO,GAAGlE,GAAG,CAACwE,aAAa,CAAC;IAC9B;IACA,IAAIE,MAAM,GAAG,KAAK;IAClB,IAAIC,OAAO,GAAG,CAAC,CAAC;IAEhB,IAAIZ,QAAQ,CAACa,aAAa,EAAE;MAC1BD,OAAO,CAAC,kCAAkC,CAAC,GAAG,IAAI;IACpD;IAEA,IAAI,CAACb,MAAM,EAAE;MACXA,MAAM,GAAGzD,cAAc;IACzB;IAEA,MAAMwE,gBAAgB,GAAIC,GAAG,IAAK;MAChC,IAAIA,GAAG,KAAKhB,MAAM,KAAK,EAAE,IAAIA,MAAM,KAAKzD,cAAc,CAAC,EAAE;QACvD,IAAIyE,GAAG,CAACC,IAAI,KAAK,8BAA8B,IAAID,GAAG,CAAChB,MAAM,KAAK,EAAE,EAAE;UACpE;UACA,IAAI,CAACkB,WAAW,CAAC;YAAEN,MAAM;YAAEb,UAAU;YAAEc;UAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAEY,GAAG,CAAChB,MAAM,EAAE,KAAK,EAAEE,EAAE,CAAC;QAC1F,CAAC,MAAM;UACL,OAAOA,EAAE,IAAIA,EAAE,CAACc,GAAG,CAAC;QACtB;MACF;MACA,OAAOd,EAAE,IAAIA,EAAE,CAACc,GAAG,CAAC;IACtB,CAAC;IACD,IAAI,CAACE,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEc;IAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAEJ,MAAM,EAAE,KAAK,EAAEe,gBAAgB,CAAC;EACpG;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAI,qBAAqBA,CAACC,MAAM,EAAEC,MAAM,EAAEC,SAAS,EAAE;IAC/C,IAAID,MAAM,KAAKE,SAAS,EAAE;MACxBF,MAAM,GAAG,EAAE;IACb;IACA,IAAIC,SAAS,KAAKC,SAAS,EAAE;MAC3BD,SAAS,GAAG,KAAK;IACnB;IACA,IAAI,CAAC/D,iBAAiB,CAAC6D,MAAM,CAAC,EAAE;MAC9B,MAAM,IAAIhF,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGiB,MAAM,CAAC;IAC3E;IACA,IAAI,CAAC1D,aAAa,CAAC2D,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIjF,MAAM,CAACoF,kBAAkB,CAAE,oBAAmBH,MAAO,EAAC,CAAC;IACnE;IACA,IAAI,CAACpE,SAAS,CAACqE,SAAS,CAAC,EAAE;MACzB,MAAM,IAAIjC,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAIoC,SAAS,GAAGH,SAAS,GAAG,EAAE,GAAG,GAAG;IACpC,IAAII,SAAS,GAAG,EAAE;IAClB,IAAIC,cAAc,GAAG,EAAE;IACvB,IAAIC,OAAO,GAAG,EAAE;IAChB,IAAIC,KAAK,GAAG,KAAK;IACjB,IAAIC,UAAU,GAAGlG,MAAM,CAACmG,QAAQ,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IACtDF,UAAU,CAACG,KAAK,GAAG,MAAM;MACvB;MACA,IAAIL,OAAO,CAACM,MAAM,EAAE;QAClB,OAAOJ,UAAU,CAACxB,IAAI,CAACsB,OAAO,CAACO,KAAK,CAAC,CAAC,CAAC;MACzC;MACA,IAAIN,KAAK,EAAE;QACT,OAAOC,UAAU,CAACxB,IAAI,CAAC,IAAI,CAAC;MAC9B;MACA,IAAI,CAAC8B,0BAA0B,CAAChB,MAAM,EAAEC,MAAM,EAAEK,SAAS,EAAEC,cAAc,EAAEF,SAAS,CAAC,CAClFY,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKR,UAAU,CAACS,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC,CAC/CD,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAK;QACtBA,MAAM,CAACC,QAAQ,CAACC,OAAO,CAAErB,MAAM,IAAKO,OAAO,CAACtB,IAAI,CAACe,MAAM,CAAC,CAAC;QACzDxF,KAAK,CAAC8G,UAAU,CACdH,MAAM,CAACZ,OAAO,EACd,CAACgB,MAAM,EAAE1C,EAAE,KAAK;UACd;UACA,IAAI,CAAC2C,SAAS,CAACzB,MAAM,EAAEwB,MAAM,CAACE,GAAG,EAAEF,MAAM,CAACG,QAAQ,CAAC,CAACC,IAAI,CAAEC,KAAK,IAAK;YAClEL,MAAM,CAAClD,IAAI,GAAGuD,KAAK,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAKD,GAAG,GAAGC,IAAI,CAAC1D,IAAI,EAAE,CAAC,CAAC;YAC7DkC,OAAO,CAACtB,IAAI,CAACsC,MAAM,CAAC;YACpB1C,EAAE,CAAC,CAAC;UACN,CAAC,EAAEA,EAAE,CAAC;QACR,CAAC,EACAc,GAAG,IAAK;UACP,IAAIA,GAAG,EAAE;YACPc,UAAU,CAACS,IAAI,CAAC,OAAO,EAAEvB,GAAG,CAAC;YAC7B;UACF;UACA,IAAIwB,MAAM,CAACa,WAAW,EAAE;YACtB3B,SAAS,GAAGc,MAAM,CAACc,aAAa;YAChC3B,cAAc,GAAGa,MAAM,CAACe,kBAAkB;UAC5C,CAAC,MAAM;YACL1B,KAAK,GAAG,IAAI;UACd;UACAC,UAAU,CAACG,KAAK,CAAC,CAAC;QACpB,CACF,CAAC;MACH,CAAC,CAAC;IACN,CAAC;IACD,OAAOH,UAAU;EACnB;;EAEA;EACA;EACA;EACA;EACA;EACA0B,YAAYA,CAACzD,UAAU,EAAEG,EAAE,EAAE;IAC3B,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAIuB,MAAM,GAAG,MAAM;IACnB,IAAI,CAACM,WAAW,CAAC;MAAEN,MAAM;MAAEb;IAAW,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAGiB,GAAG,IAAK;MACtE,IAAIA,GAAG,EAAE;QACP,IAAIA,GAAG,CAACC,IAAI,IAAI,cAAc,IAAID,GAAG,CAACC,IAAI,IAAI,UAAU,EAAE;UACxD,OAAOf,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC;QACxB;QACA,OAAOA,EAAE,CAACc,GAAG,CAAC;MAChB;MACAd,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;IAChB,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAuD,sBAAsBA,CAAC1D,UAAU,EAAE2D,UAAU,EAAExD,EAAE,EAAE;IACjD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAACuH,sBAAsB,CAAC,uBAAuB,GAAG5D,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACxG,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAIwE,cAAc;IAClBhI,KAAK,CAACiI,MAAM,CACT5D,EAAE,IAAK;MACN,IAAI,CAAC6D,YAAY,CAAChE,UAAU,EAAE2D,UAAU,EAAE,CAACpB,CAAC,EAAES,QAAQ,KAAK;QACzD,IAAIT,CAAC,EAAE;UACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;QACd;QACAuB,cAAc,GAAGd,QAAQ;QACzB7C,EAAE,CAAC,IAAI,EAAE6C,QAAQ,CAAC;MACpB,CAAC,CAAC;IACJ,CAAC,EACA7C,EAAE,IAAK;MACN,IAAIU,MAAM,GAAG,QAAQ;MACrB,IAAIoD,KAAK,GAAI,YAAWH,cAAe,EAAC;MACxC,IAAI,CAAC3C,WAAW,CAAC;QAAEN,MAAM;QAAEb,UAAU;QAAE2D,UAAU;QAAEM;MAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAG1B,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC;IACjG,CAAC,EACDpC,EACF,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA+D,UAAUA,CAAClE,UAAU,EAAE2D,UAAU,EAAEQ,QAAQ,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAEjE,EAAE,EAAE;IAC7D;IACA,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACpG,QAAQ,CAAC4G,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAI7E,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA;IACA,IAAInC,UAAU,CAACiH,OAAO,CAAC,EAAE;MACvBjE,EAAE,GAAGiE,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,CAACjH,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;;IAEA;IACA,IAAI+E,QAAQ;IACZ,IAAIC,cAAc;IAClB,IAAIC,OAAO;;IAEX;IACA,IAAIC,MAAM,GAAIvD,GAAG,IAAK;MACpB,IAAIA,GAAG,EAAE;QACP,OAAOd,EAAE,CAACc,GAAG,CAAC;MAChB;MACAtF,EAAE,CAAC6I,MAAM,CAACH,QAAQ,EAAEF,QAAQ,EAAEhE,EAAE,CAAC;IACnC,CAAC;IAEDrE,KAAK,CAAC2I,SAAS,CACb,CACGtE,EAAE,IAAK,IAAI,CAACuE,UAAU,CAAC1E,UAAU,EAAE2D,UAAU,EAAES,OAAO,EAAEjE,EAAE,CAAC,EAC5D,CAACsC,MAAM,EAAEtC,EAAE,KAAK;MACdoE,OAAO,GAAG9B,MAAM;MAChB;MACA9G,EAAE,CAACgJ,KAAK,CAAC/I,IAAI,CAACgJ,OAAO,CAACT,QAAQ,CAAC,EAAE;QAAE5C,SAAS,EAAE;MAAK,CAAC,EAAGN,GAAG,IAAKd,EAAE,CAACc,GAAG,CAAC,CAAC;IACzE,CAAC,EACAd,EAAE,IAAK;MACNkE,QAAQ,GAAI,GAAEF,QAAS,IAAGI,OAAO,CAACM,IAAK,aAAY;MACnDlJ,EAAE,CAACmJ,IAAI,CAACT,QAAQ,EAAE,CAAC9B,CAAC,EAAEwC,KAAK,KAAK;QAC9B,IAAIC,MAAM,GAAG,CAAC;QACd,IAAIzC,CAAC,EAAE;UACL+B,cAAc,GAAG3I,EAAE,CAACsJ,iBAAiB,CAACZ,QAAQ,EAAE;YAAEa,KAAK,EAAE;UAAI,CAAC,CAAC;QACjE,CAAC,MAAM;UACL,IAAIX,OAAO,CAAC5E,IAAI,KAAKoF,KAAK,CAACpF,IAAI,EAAE;YAC/B,OAAO6E,MAAM,CAAC,CAAC;UACjB;UACAQ,MAAM,GAAGD,KAAK,CAACpF,IAAI;UACnB2E,cAAc,GAAG3I,EAAE,CAACsJ,iBAAiB,CAACZ,QAAQ,EAAE;YAAEa,KAAK,EAAE;UAAI,CAAC,CAAC;QACjE;QACA,IAAI,CAACC,gBAAgB,CAACnF,UAAU,EAAE2D,UAAU,EAAEqB,MAAM,EAAE,CAAC,EAAEZ,OAAO,EAAEjE,EAAE,CAAC;MACvE,CAAC,CAAC;IACJ,CAAC,EACD,CAACiF,cAAc,EAAEjF,EAAE,KAAK;MACtBpC,SAAS,CAACqH,cAAc,EAAEd,cAAc,CAAC,CACtChC,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,QAAQ,EAAEnC,EAAE,CAAC;IACrB,CAAC,EACAA,EAAE,IAAKxE,EAAE,CAACmJ,IAAI,CAACT,QAAQ,EAAElE,EAAE,CAAC,EAC7B,CAAC4E,KAAK,EAAE5E,EAAE,KAAK;MACb,IAAI4E,KAAK,CAACpF,IAAI,KAAK4E,OAAO,CAAC5E,IAAI,EAAE;QAC/B,OAAOQ,EAAE,CAAC,CAAC;MACb;MACAA,EAAE,CAAC,IAAIkF,KAAK,CAAC,sDAAsD,CAAC,CAAC;IACvE,CAAC,CACF,EACDb,MACF,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACAc,SAASA,CAACtF,UAAU,EAAE2D,UAAU,EAAES,OAAO,GAAG,CAAC,CAAC,EAAEjE,EAAE,EAAE;IAClD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA;IACA,IAAIxG,UAAU,CAACiH,OAAO,CAAC,EAAE;MACvBjE,EAAE,GAAGiE,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,CAACjH,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAAC6F,gBAAgB,CAACnF,UAAU,EAAE2D,UAAU,EAAE,CAAC,EAAE,CAAC,EAAES,OAAO,EAAEjE,EAAE,CAAC;EAClE;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAgF,gBAAgBA,CAACnF,UAAU,EAAE2D,UAAU,EAAEqB,MAAM,EAAE7C,MAAM,EAAEiC,OAAO,GAAG,CAAC,CAAC,EAAEjE,EAAE,EAAE;IACzE,IAAIhD,UAAU,CAACgF,MAAM,CAAC,EAAE;MACtBhC,EAAE,GAAGgC,MAAM;MACXA,MAAM,GAAG,CAAC;IACZ;IACA,IAAI,CAAC3E,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACvG,QAAQ,CAAC4H,MAAM,CAAC,EAAE;MACrB,MAAM,IAAI1F,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAAClC,QAAQ,CAAC+E,MAAM,CAAC,EAAE;MACrB,MAAM,IAAI7C,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA;IACA,IAAInC,UAAU,CAACiH,OAAO,CAAC,EAAE;MACvBjE,EAAE,GAAGiE,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,CAACjH,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIiG,KAAK,GAAG,EAAE;IACd,IAAIP,MAAM,IAAI7C,MAAM,EAAE;MACpB,IAAI6C,MAAM,EAAE;QACVO,KAAK,GAAI,SAAQ,CAACP,MAAO,GAAE;MAC7B,CAAC,MAAM;QACLO,KAAK,GAAG,UAAU;QAClBP,MAAM,GAAG,CAAC;MACZ;MACA,IAAI7C,MAAM,EAAE;QACVoD,KAAK,IAAK,GAAE,CAACpD,MAAM,GAAG6C,MAAM,GAAG,CAAE,EAAC;MACpC;IACF;IAEA,IAAIlE,OAAO,GAAG,CAAC,CAAC;IAChB,IAAIyE,KAAK,KAAK,EAAE,EAAE;MAChBzE,OAAO,CAACyE,KAAK,GAAGA,KAAK;IACvB;IAEA,IAAIC,mBAAmB,GAAG,CAAC,GAAG,CAAC;IAC/B,IAAID,KAAK,EAAE;MACTC,mBAAmB,CAACjF,IAAI,CAAC,GAAG,CAAC;IAC/B;IACA,IAAIM,MAAM,GAAG,KAAK;IAElB,IAAIoD,KAAK,GAAGhI,WAAW,CAACwJ,SAAS,CAACrB,OAAO,CAAC;IAC1C,IAAI,CAACjD,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAE7C,OAAO;MAAEmD;IAAM,CAAC,EAAE,EAAE,EAAEuB,mBAAmB,EAAE,EAAE,EAAE,IAAI,EAAErF,EAAE,CAAC;EAC7G;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAuF,UAAUA,CAAC1F,UAAU,EAAE2D,UAAU,EAAEQ,QAAQ,EAAEwB,QAAQ,EAAEC,QAAQ,EAAE;IAC/D,IAAI,CAACpI,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IAEA,IAAI,CAACpG,QAAQ,CAAC4G,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAI7E,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAInC,UAAU,CAACwI,QAAQ,CAAC,EAAE;MACxBC,QAAQ,GAAGD,QAAQ;MACnBA,QAAQ,GAAG,CAAC,CAAC,EAAC;IAChB;IACA,IAAI,CAACtI,QAAQ,CAACsI,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAIrG,SAAS,CAAC,qCAAqC,CAAC;IAC5D;;IAEA;IACAqG,QAAQ,GAAG1I,iBAAiB,CAAC0I,QAAQ,EAAExB,QAAQ,CAAC;IAEhDxI,EAAE,CAACkK,KAAK,CAAC1B,QAAQ,EAAE,CAAClD,GAAG,EAAE6D,IAAI,KAAK;MAChC,IAAI7D,GAAG,EAAE;QACP,OAAO2E,QAAQ,CAAC3E,GAAG,CAAC;MACtB;MACA,OAAO,IAAI,CAAC6E,SAAS,CAAC9F,UAAU,EAAE2D,UAAU,EAAEhI,EAAE,CAACoK,gBAAgB,CAAC5B,QAAQ,CAAC,EAAEW,IAAI,CAACnF,IAAI,EAAEgG,QAAQ,EAAEC,QAAQ,CAAC;IAC7G,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAE,SAASA,CAAC9F,UAAU,EAAE2D,UAAU,EAAEqC,MAAM,EAAErG,IAAI,EAAEgG,QAAQ,EAAEC,QAAQ,EAAE;IAClE,IAAI,CAACpI,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;;IAEA;IACA,IAAIxG,UAAU,CAACwC,IAAI,CAAC,EAAE;MACpBiG,QAAQ,GAAGjG,IAAI;MACfgG,QAAQ,GAAG,CAAC,CAAC;IACf,CAAC,MAAM,IAAIxI,UAAU,CAACwI,QAAQ,CAAC,EAAE;MAC/BC,QAAQ,GAAGD,QAAQ;MACnBA,QAAQ,GAAG,CAAC,CAAC;IACf;;IAEA;IACA;IACA,IAAItI,QAAQ,CAACsC,IAAI,CAAC,EAAE;MAClBgG,QAAQ,GAAGhG,IAAI;IACjB;;IAEA;IACAgG,QAAQ,GAAG3H,eAAe,CAAC2H,QAAQ,CAAC;IACpC,IAAI,OAAOK,MAAM,KAAK,QAAQ,IAAIA,MAAM,YAAYC,MAAM,EAAE;MAC1D;MACAtG,IAAI,GAAGqG,MAAM,CAAC7D,MAAM;MACpB6D,MAAM,GAAG/H,cAAc,CAAC+H,MAAM,CAAC;IACjC,CAAC,MAAM,IAAI,CAAC1I,gBAAgB,CAAC0I,MAAM,CAAC,EAAE;MACpC,MAAM,IAAI1G,SAAS,CAAC,4EAA4E,CAAC;IACnG;IAEA,IAAI,CAACnC,UAAU,CAACyI,QAAQ,CAAC,EAAE;MACzB,MAAM,IAAItG,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIlC,QAAQ,CAACuC,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EAAE;MAC9B,MAAM,IAAItD,MAAM,CAACmD,oBAAoB,CAAE,wCAAuCG,IAAK,EAAC,CAAC;IACvF;;IAEA;IACA;IACA,IAAI,CAACvC,QAAQ,CAACuC,IAAI,CAAC,EAAE;MACnBA,IAAI,GAAG,IAAI,CAACC,aAAa;IAC3B;IAEAD,IAAI,GAAG,IAAI,CAACD,iBAAiB,CAACC,IAAI,CAAC;;IAEnC;IACA;IACA;IACA,IAAIuG,OAAO,GAAG,IAAInK,YAAY,CAAC;MAAE4D,IAAI;MAAEwG,WAAW,EAAE;IAAM,CAAC,CAAC;;IAE5D;IACA;IACA,IAAIC,QAAQ,GAAG,IAAIxH,cAAc,CAAC,IAAI,EAAEoB,UAAU,EAAE2D,UAAU,EAAEhE,IAAI,EAAEgG,QAAQ,EAAEC,QAAQ,CAAC;IACzF;IACA7H,SAAS,CAACiI,MAAM,EAAEE,OAAO,EAAEE,QAAQ,CAAC;EACtC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,YAAYA,CAACC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACzC,IAAI1G,UAAU,GAAGsG,IAAI;IACrB,IAAI3C,UAAU,GAAG4C,IAAI;IACrB,IAAII,SAAS,GAAGH,IAAI;IACpB,IAAII,UAAU,EAAEzG,EAAE;IAClB,IAAI,OAAOsG,IAAI,IAAI,UAAU,IAAIC,IAAI,KAAKlF,SAAS,EAAE;MACnDoF,UAAU,GAAG,IAAI;MACjBzG,EAAE,GAAGsG,IAAI;IACX,CAAC,MAAM;MACLG,UAAU,GAAGH,IAAI;MACjBtG,EAAE,GAAGuG,IAAI;IACX;IACA,IAAI,CAAClJ,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACpG,QAAQ,CAACoJ,SAAS,CAAC,EAAE;MACxB,MAAM,IAAIrH,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAIqH,SAAS,KAAK,EAAE,EAAE;MACpB,MAAM,IAAItK,MAAM,CAACoF,kBAAkB,CAAE,qBAAoB,CAAC;IAC5D;IAEA,IAAImF,UAAU,KAAK,IAAI,IAAI,EAAEA,UAAU,YAAYjK,cAAc,CAAC,EAAE;MAClE,MAAM,IAAI2C,SAAS,CAAC,+CAA+C,CAAC;IACtE;IAEA,IAAIwB,OAAO,GAAG,CAAC,CAAC;IAChBA,OAAO,CAAC,mBAAmB,CAAC,GAAGzC,iBAAiB,CAACsI,SAAS,CAAC;IAE3D,IAAIC,UAAU,KAAK,IAAI,EAAE;MACvB,IAAIA,UAAU,CAACC,QAAQ,KAAK,EAAE,EAAE;QAC9B/F,OAAO,CAAC,qCAAqC,CAAC,GAAG8F,UAAU,CAACC,QAAQ;MACtE;MACA,IAAID,UAAU,CAACE,UAAU,KAAK,EAAE,EAAE;QAChChG,OAAO,CAAC,uCAAuC,CAAC,GAAG8F,UAAU,CAACE,UAAU;MAC1E;MACA,IAAIF,UAAU,CAACG,SAAS,KAAK,EAAE,EAAE;QAC/BjG,OAAO,CAAC,4BAA4B,CAAC,GAAG8F,UAAU,CAACG,SAAS;MAC9D;MACA,IAAIH,UAAU,CAACI,eAAe,KAAK,EAAE,EAAE;QACrClG,OAAO,CAAC,iCAAiC,CAAC,GAAG8F,UAAU,CAACK,eAAe;MACzE;IACF;IAEA,IAAIpG,MAAM,GAAG,KAAK;IAClB,IAAI,CAACM,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAE7C;IAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACyB,CAAC,EAAE2E,QAAQ,KAAK;MAClG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAI4E,WAAW,GAAGnI,YAAY,CAACoI,wBAAwB,CAAC,CAAC;MACzDrJ,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAKlH,EAAE,CAAC,IAAI,EAAEkH,IAAI,CAAC,CAAC;IACzC,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,YAAYA,CAACC,YAAY,EAAEC,UAAU,EAAErH,EAAE,EAAE;IACzC,IAAI,EAAEoH,YAAY,YAAYhL,iBAAiB,CAAC,EAAE;MAChD,MAAM,IAAIF,MAAM,CAACmD,oBAAoB,CAAC,gDAAgD,CAAC;IACzF;IACA,IAAI,EAAEgI,UAAU,YAAYlL,sBAAsB,CAAC,EAAE;MACnD,MAAM,IAAID,MAAM,CAACmD,oBAAoB,CAAC,mDAAmD,CAAC;IAC5F;IACA,IAAI,CAACgI,UAAU,CAACC,QAAQ,CAAC,CAAC,EAAE;MAC1B,OAAO,KAAK;IACd;IACA,IAAI,CAACD,UAAU,CAACC,QAAQ,CAAC,CAAC,EAAE;MAC1B,OAAO,KAAK;IACd;IACA,IAAI,CAACtK,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,MAAMwB,OAAO,GAAG4G,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEJ,YAAY,CAACK,UAAU,CAAC,CAAC,EAAEJ,UAAU,CAACI,UAAU,CAAC,CAAC,CAAC;IAErF,MAAM5H,UAAU,GAAGwH,UAAU,CAACK,MAAM;IACpC,MAAMlE,UAAU,GAAG6D,UAAU,CAACE,MAAM;IAEpC,MAAM7G,MAAM,GAAG,KAAK;IACpB,IAAI,CAACM,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAE7C;IAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACyB,CAAC,EAAE2E,QAAQ,KAAK;MAClG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,MAAM4E,WAAW,GAAGnI,YAAY,CAACoI,wBAAwB,CAAC,CAAC;MAC3DrJ,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpB,MAAMS,UAAU,GAAGZ,QAAQ,CAACpG,OAAO;QAEnC,MAAMiH,eAAe,GAAG;UACtBF,MAAM,EAAEL,UAAU,CAACK,MAAM;UACzBG,GAAG,EAAER,UAAU,CAACE,MAAM;UACtBO,YAAY,EAAEZ,IAAI,CAACY,YAAY;UAC/BC,QAAQ,EAAErL,eAAe,CAACiL,UAAU,CAAC;UACrCK,SAAS,EAAEnL,YAAY,CAAC8K,UAAU,CAAC;UACnCM,eAAe,EAAErL,kBAAkB,CAAC+K,UAAU,CAAC;UAC/CO,IAAI,EAAEnK,YAAY,CAAC4J,UAAU,CAACjD,IAAI,CAAC;UACnCyD,IAAI,EAAE,CAACR,UAAU,CAAC,gBAAgB;QACpC,CAAC;QAED,OAAO3H,EAAE,CAAC,IAAI,EAAE4H,eAAe,CAAC;MAClC,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;;EAEA;EACAQ,UAAUA,CAAC,GAAGC,OAAO,EAAE;IACrB,IAAIA,OAAO,CAAC,CAAC,CAAC,YAAYjM,iBAAiB,IAAIiM,OAAO,CAAC,CAAC,CAAC,YAAYlM,sBAAsB,EAAE;MAC3F,OAAO,IAAI,CAACgL,YAAY,CAAC,GAAGmB,SAAS,CAAC;IACxC;IACA,OAAO,IAAI,CAACpC,YAAY,CAAC,GAAGoC,SAAS,CAAC;EACxC;;EAEA;EACAC,gBAAgBA,CAAC1I,UAAU,EAAEsB,MAAM,EAAEqH,MAAM,EAAEC,aAAa,GAAG,CAAC,CAAC,EAAE;IAC/D,IAAI,CAACpL,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACzC,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAAC/B,QAAQ,CAACoL,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIrJ,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI;MAAEuJ,SAAS;MAAEC,OAAO;MAAEC;IAAe,CAAC,GAAGH,aAAa;IAE1D,IAAI,CAACvL,QAAQ,CAACuL,aAAa,CAAC,EAAE;MAC5B,MAAM,IAAItJ,SAAS,CAAC,0CAA0C,CAAC;IACjE;IAEA,IAAI,CAAC/B,QAAQ,CAACsL,SAAS,CAAC,EAAE;MACxB,MAAM,IAAIvJ,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAI,CAAClC,QAAQ,CAAC0L,OAAO,CAAC,EAAE;MACtB,MAAM,IAAIxJ,SAAS,CAAC,oCAAoC,CAAC;IAC3D;IAEA,MAAM0J,OAAO,GAAG,EAAE;IAClB;IACAA,OAAO,CAACzI,IAAI,CAAE,UAASnC,SAAS,CAACkD,MAAM,CAAE,EAAC,CAAC;IAC3C0H,OAAO,CAACzI,IAAI,CAAE,aAAYnC,SAAS,CAACyK,SAAS,CAAE,EAAC,CAAC;IACjDG,OAAO,CAACzI,IAAI,CAAE,mBAAkB,CAAC;IAEjC,IAAIwI,cAAc,EAAE;MAClBC,OAAO,CAACzI,IAAI,CAAE,UAAS,CAAC;IAC1B;IAEA,IAAIoI,MAAM,EAAE;MACVA,MAAM,GAAGvK,SAAS,CAACuK,MAAM,CAAC;MAC1B,IAAII,cAAc,EAAE;QAClBC,OAAO,CAACzI,IAAI,CAAE,cAAaoI,MAAO,EAAC,CAAC;MACtC,CAAC,MAAM;QACLK,OAAO,CAACzI,IAAI,CAAE,UAASoI,MAAO,EAAC,CAAC;MAClC;IACF;;IAEA;IACA,IAAIG,OAAO,EAAE;MACX,IAAIA,OAAO,IAAI,IAAI,EAAE;QACnBA,OAAO,GAAG,IAAI;MAChB;MACAE,OAAO,CAACzI,IAAI,CAAE,YAAWuI,OAAQ,EAAC,CAAC;IACrC;IACAE,OAAO,CAACC,IAAI,CAAC,CAAC;IACd,IAAIhF,KAAK,GAAG,EAAE;IACd,IAAI+E,OAAO,CAAC7G,MAAM,GAAG,CAAC,EAAE;MACtB8B,KAAK,GAAI,GAAE+E,OAAO,CAACE,IAAI,CAAC,GAAG,CAAE,EAAC;IAChC;IAEA,IAAIrI,MAAM,GAAG,KAAK;IAClB,IAAIsG,WAAW,GAAGnI,YAAY,CAACmK,yBAAyB,CAAC,CAAC;IAC1D,IAAI,CAAChI,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAO4E,WAAW,CAAC3E,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC;MACrC;MACAxE,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC;IAClC,CAAC,CAAC;IACF,OAAOA,WAAW;EACpB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAiC,WAAWA,CAACpJ,UAAU,EAAEsB,MAAM,EAAEC,SAAS,EAAE8H,QAAQ,GAAG,CAAC,CAAC,EAAE;IACxD,IAAI/H,MAAM,KAAKE,SAAS,EAAE;MACxBF,MAAM,GAAG,EAAE;IACb;IACA,IAAIC,SAAS,KAAKC,SAAS,EAAE;MAC3BD,SAAS,GAAG,KAAK;IACnB;IACA,IAAI,CAAC/D,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACrC,aAAa,CAAC2D,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIjF,MAAM,CAACoF,kBAAkB,CAAE,oBAAmBH,MAAO,EAAC,CAAC;IACnE;IACA,IAAI,CAAC/D,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAACpC,SAAS,CAACqE,SAAS,CAAC,EAAE;MACzB,MAAM,IAAIjC,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAACjC,QAAQ,CAACgM,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAI/J,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAIqJ,MAAM,GAAG,EAAE;IACf,MAAMC,aAAa,GAAG;MACpBC,SAAS,EAAEtH,SAAS,GAAG,EAAE,GAAG,GAAG;MAAE;MACjCuH,OAAO,EAAE,IAAI;MACbC,cAAc,EAAEM,QAAQ,CAACN;IAC3B,CAAC;IACD,IAAIO,OAAO,GAAG,EAAE;IAChB,IAAIxH,KAAK,GAAG,KAAK;IACjB,IAAIC,UAAU,GAAGlG,MAAM,CAACmG,QAAQ,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IACtDF,UAAU,CAACG,KAAK,GAAG,MAAM;MACvB;MACA,IAAIoH,OAAO,CAACnH,MAAM,EAAE;QAClBJ,UAAU,CAACxB,IAAI,CAAC+I,OAAO,CAAClH,KAAK,CAAC,CAAC,CAAC;QAChC;MACF;MACA,IAAIN,KAAK,EAAE;QACT,OAAOC,UAAU,CAACxB,IAAI,CAAC,IAAI,CAAC;MAC9B;MACA;MACA,IAAI,CAACmI,gBAAgB,CAAC1I,UAAU,EAAEsB,MAAM,EAAEqH,MAAM,EAAEC,aAAa,CAAC,CAC7DtG,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKR,UAAU,CAACS,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC,CAC/CD,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAK;QACtB,IAAIA,MAAM,CAACa,WAAW,EAAE;UACtBqF,MAAM,GAAGlG,MAAM,CAAC8G,UAAU,IAAI9G,MAAM,CAAC+G,eAAe;QACtD,CAAC,MAAM;UACL1H,KAAK,GAAG,IAAI;QACd;QACAwH,OAAO,GAAG7G,MAAM,CAAC6G,OAAO;QACxBvH,UAAU,CAACG,KAAK,CAAC,CAAC;MACpB,CAAC,CAAC;IACN,CAAC;IACD,OAAOH,UAAU;EACnB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA0H,kBAAkBA,CAACzJ,UAAU,EAAEsB,MAAM,EAAEoI,iBAAiB,EAAEhI,SAAS,EAAEiI,OAAO,EAAEC,UAAU,EAAE;IACxF,IAAI,CAACpM,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACzC,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAAC/B,QAAQ,CAACmM,iBAAiB,CAAC,EAAE;MAChC,MAAM,IAAIpK,SAAS,CAAC,8CAA8C,CAAC;IACrE;IACA,IAAI,CAAC/B,QAAQ,CAACmE,SAAS,CAAC,EAAE;MACxB,MAAM,IAAIpC,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAI,CAAClC,QAAQ,CAACuM,OAAO,CAAC,EAAE;MACtB,MAAM,IAAIrK,SAAS,CAAC,oCAAoC,CAAC;IAC3D;IACA,IAAI,CAAC/B,QAAQ,CAACqM,UAAU,CAAC,EAAE;MACzB,MAAM,IAAItK,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI0J,OAAO,GAAG,EAAE;;IAEhB;IACAA,OAAO,CAACzI,IAAI,CAAE,aAAY,CAAC;IAC3ByI,OAAO,CAACzI,IAAI,CAAE,mBAAkB,CAAC;;IAEjC;IACAyI,OAAO,CAACzI,IAAI,CAAE,UAASnC,SAAS,CAACkD,MAAM,CAAE,EAAC,CAAC;IAC3C0H,OAAO,CAACzI,IAAI,CAAE,aAAYnC,SAAS,CAACsD,SAAS,CAAE,EAAC,CAAC;IAEjD,IAAIgI,iBAAiB,EAAE;MACrBA,iBAAiB,GAAGtL,SAAS,CAACsL,iBAAiB,CAAC;MAChDV,OAAO,CAACzI,IAAI,CAAE,sBAAqBmJ,iBAAkB,EAAC,CAAC;IACzD;IACA;IACA,IAAIE,UAAU,EAAE;MACdA,UAAU,GAAGxL,SAAS,CAACwL,UAAU,CAAC;MAClCZ,OAAO,CAACzI,IAAI,CAAE,eAAcqJ,UAAW,EAAC,CAAC;IAC3C;IACA;IACA,IAAID,OAAO,EAAE;MACX,IAAIA,OAAO,IAAI,IAAI,EAAE;QACnBA,OAAO,GAAG,IAAI;MAChB;MACAX,OAAO,CAACzI,IAAI,CAAE,YAAWoJ,OAAQ,EAAC,CAAC;IACrC;IACAX,OAAO,CAACC,IAAI,CAAC,CAAC;IACd,IAAIhF,KAAK,GAAG,EAAE;IACd,IAAI+E,OAAO,CAAC7G,MAAM,GAAG,CAAC,EAAE;MACtB8B,KAAK,GAAI,GAAE+E,OAAO,CAACE,IAAI,CAAC,GAAG,CAAE,EAAC;IAChC;IACA,IAAIrI,MAAM,GAAG,KAAK;IAClB,IAAIsG,WAAW,GAAGnI,YAAY,CAAC6K,2BAA2B,CAAC,CAAC;IAC5D,IAAI,CAAC1I,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAO4E,WAAW,CAAC3E,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC;MACrC;MACAxE,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC;IAClC,CAAC,CAAC;IACF,OAAOA,WAAW;EACpB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA2C,aAAaA,CAAC9J,UAAU,EAAEsB,MAAM,EAAEC,SAAS,EAAEqI,UAAU,EAAE;IACvD,IAAItI,MAAM,KAAKE,SAAS,EAAE;MACxBF,MAAM,GAAG,EAAE;IACb;IACA,IAAIC,SAAS,KAAKC,SAAS,EAAE;MAC3BD,SAAS,GAAG,KAAK;IACnB;IACA,IAAIqI,UAAU,KAAKpI,SAAS,EAAE;MAC5BoI,UAAU,GAAG,EAAE;IACjB;IACA,IAAI,CAACpM,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACrC,aAAa,CAAC2D,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIjF,MAAM,CAACoF,kBAAkB,CAAE,oBAAmBH,MAAO,EAAC,CAAC;IACnE;IACA,IAAI,CAAC/D,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAACpC,SAAS,CAACqE,SAAS,CAAC,EAAE;MACzB,MAAM,IAAIjC,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAAC/B,QAAQ,CAACqM,UAAU,CAAC,EAAE;MACzB,MAAM,IAAItK,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA;IACA,IAAIoC,SAAS,GAAGH,SAAS,GAAG,EAAE,GAAG,GAAG;IACpC,IAAImI,iBAAiB,GAAG,EAAE;IAC1B,IAAIJ,OAAO,GAAG,EAAE;IAChB,IAAIxH,KAAK,GAAG,KAAK;IACjB,IAAIC,UAAU,GAAGlG,MAAM,CAACmG,QAAQ,CAAC;MAAEC,UAAU,EAAE;IAAK,CAAC,CAAC;IACtDF,UAAU,CAACG,KAAK,GAAG,MAAM;MACvB;MACA,IAAIoH,OAAO,CAACnH,MAAM,EAAE;QAClBJ,UAAU,CAACxB,IAAI,CAAC+I,OAAO,CAAClH,KAAK,CAAC,CAAC,CAAC;QAChC;MACF;MACA,IAAIN,KAAK,EAAE;QACT,OAAOC,UAAU,CAACxB,IAAI,CAAC,IAAI,CAAC;MAC9B;MACA;MACA,IAAI,CAACkJ,kBAAkB,CAACzJ,UAAU,EAAEsB,MAAM,EAAEoI,iBAAiB,EAAEhI,SAAS,EAAE,IAAI,EAAEkI,UAAU,CAAC,CACxFtH,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKR,UAAU,CAACS,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC,CAAC,CAC/CD,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAK;QACtB,IAAIA,MAAM,CAACa,WAAW,EAAE;UACtBoG,iBAAiB,GAAGjH,MAAM,CAACsH,qBAAqB;QAClD,CAAC,MAAM;UACLjI,KAAK,GAAG,IAAI;QACd;QACAwH,OAAO,GAAG7G,MAAM,CAAC6G,OAAO;QACxBvH,UAAU,CAACG,KAAK,CAAC,CAAC;MACpB,CAAC,CAAC;IACN,CAAC;IACD,OAAOH,UAAU;EACnB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEAiI,aAAaA,CAAChK,UAAU,EAAEiK,WAAW,EAAE9J,EAAE,EAAE;IACzC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACkK,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,EAAE;MAC/B,MAAM,IAAI5N,MAAM,CAACmD,oBAAoB,CAAC,8BAA8B,CAAC;IACvE;IACA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,MAAM8K,UAAU,GAAG,IAAI;IACvB,MAAMnG,KAAK,GAAG,QAAQ;IACtB,MAAMpD,MAAM,GAAG,MAAM;IAErB,IAAI4B,MAAM,GAAGwH,WAAW,CAAC9G,MAAM,CAC7B,CAACV,MAAM,EAAE4H,KAAK,KAAK;MACjB5H,MAAM,CAAC6H,IAAI,CAAC/J,IAAI,CAAC8J,KAAK,CAAC;MACvB,IAAI5H,MAAM,CAAC6H,IAAI,CAACnI,MAAM,KAAKiI,UAAU,EAAE;QACrC3H,MAAM,CAAC8H,UAAU,CAAChK,IAAI,CAACkC,MAAM,CAAC6H,IAAI,CAAC;QACnC7H,MAAM,CAAC6H,IAAI,GAAG,EAAE;MAClB;MACA,OAAO7H,MAAM;IACf,CAAC,EACD;MAAE8H,UAAU,EAAE,EAAE;MAAED,IAAI,EAAE;IAAG,CAC7B,CAAC;IAED,IAAI7H,MAAM,CAAC6H,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE;MAC1BM,MAAM,CAAC8H,UAAU,CAAChK,IAAI,CAACkC,MAAM,CAAC6H,IAAI,CAAC;IACrC;IAEA,MAAME,OAAO,GAAG,IAAItO,WAAW,CAAC,CAAC;IACjC,MAAMuO,YAAY,GAAG,EAAE;IAEvB3O,KAAK,CAAC8G,UAAU,CACdH,MAAM,CAAC8H,UAAU,EACjB,CAACD,IAAI,EAAEI,OAAO,KAAK;MACjB,IAAIpB,OAAO,GAAG,EAAE;MAChBgB,IAAI,CAAC3H,OAAO,CAAC,UAAUgI,KAAK,EAAE;QAC5B,IAAItN,QAAQ,CAACsN,KAAK,CAAC,EAAE;UACnBrB,OAAO,CAAC/I,IAAI,CAAC;YAAEyH,GAAG,EAAE2C,KAAK,CAACC,IAAI;YAAEzC,SAAS,EAAEwC,KAAK,CAACE;UAAU,CAAC,CAAC;QAC/D,CAAC,MAAM;UACLvB,OAAO,CAAC/I,IAAI,CAAC;YAAEyH,GAAG,EAAE2C;UAAM,CAAC,CAAC;QAC9B;MACF,CAAC,CAAC;MACF,IAAIG,aAAa,GAAG;QAAEC,MAAM,EAAE;UAAEC,KAAK,EAAE,IAAI;UAAEtD,MAAM,EAAE4B;QAAQ;MAAE,CAAC;MAChE,MAAM2B,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;QAAEC,QAAQ,EAAE;MAAK,CAAC,CAAC;MACtD,IAAI9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACN,aAAa,CAAC;MAChDzK,OAAO,GAAG4F,MAAM,CAACoF,IAAI,CAACb,OAAO,CAACc,MAAM,CAACjL,OAAO,CAAC,CAAC;MAC9C,MAAMS,OAAO,GAAG,CAAC,CAAC;MAElBA,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;MAEvC,IAAIkL,mBAAmB;MACvB,IAAI,CAACpK,WAAW,CAAC;QAAEN,MAAM;QAAEb,UAAU;QAAEiE,KAAK;QAAEnD;MAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACkC,CAAC,EAAE2E,QAAQ,KAAK;QAClG,IAAI3E,CAAC,EAAE;UACL,OAAOmI,OAAO,CAACnI,CAAC,CAAC;QACnB;QACAxE,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACwM,wBAAwB,CAAC,CAAC,CAAC,CACzDlJ,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;UACpBkE,mBAAmB,GAAGlE,IAAI;QAC5B,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAK;UAClB,OAAOmI,OAAO,CAACnI,CAAC,EAAE,IAAI,CAAC;QACzB,CAAC,CAAC,CACDD,EAAE,CAAC,KAAK,EAAE,MAAM;UACfmI,YAAY,CAAClK,IAAI,CAACgL,mBAAmB,CAAC;UACtC,OAAOb,OAAO,CAAC,IAAI,EAAEa,mBAAmB,CAAC;QAC3C,CAAC,CAAC;MACN,CAAC,CAAC;IACJ,CAAC,EACD,MAAM;MACJpL,EAAE,CAAC,IAAI,EAAEnE,CAAC,CAACyP,OAAO,CAAChB,YAAY,CAAC,CAAC;IACnC,CACF,CAAC;EACH;;EAEA;EACA;EACA;EACA;EACA;EACAiB,eAAeA,CAAC1L,UAAU,EAAEG,EAAE,EAAE;IAC9B;IACA,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIuB,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,QAAQ;IACpB,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAIoJ,MAAM,GAAG1F,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MAC5BtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAAC4M,WAAW,CAAC,CAAC,CAAC,CAC5CtJ,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAMsE,MAAM,GAAGtE,IAAK,CAAC,CACrC/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEwL,MAAM,CAACE,QAAQ,CAAC,CAAC,CAAC;MAC7B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAC,eAAeA,CAAC9L,UAAU,EAAE2L,MAAM,EAAExL,EAAE,EAAE;IACtC;IACA,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACzC,QAAQ,CAACoO,MAAM,CAAC,EAAE;MACrB,MAAM,IAAItP,MAAM,CAAC0P,wBAAwB,CAAE,0BAAyBJ,MAAO,qBAAoB,CAAC;IAClG;IACA,IAAI,CAACxO,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIuB,MAAM,GAAG,QAAQ;IACrB,IAAIoD,KAAK,GAAG,QAAQ;IAEpB,IAAI0H,MAAM,EAAE;MACV9K,MAAM,GAAG,KAAK;IAChB;IAEA,IAAI,CAACM,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE0H,MAAM,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAExL,EAAE,CAAC;EAC/E;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA6L,YAAYA,CAACnL,MAAM,EAAEb,UAAU,EAAE2D,UAAU,EAAEsI,OAAO,EAAEC,SAAS,EAAEC,WAAW,EAAEhM,EAAE,EAAE;IAChF,IAAI,IAAI,CAACiM,SAAS,EAAE;MAClB,MAAM,IAAI/P,MAAM,CAACgQ,qBAAqB,CAAC,YAAY,GAAGxL,MAAM,GAAG,iDAAiD,CAAC;IACnH;IACA,IAAI1D,UAAU,CAACgP,WAAW,CAAC,EAAE;MAC3BhM,EAAE,GAAGgM,WAAW;MAChBA,WAAW,GAAG,IAAIG,IAAI,CAAC,CAAC;IAC1B;IACA,IAAInP,UAAU,CAAC+O,SAAS,CAAC,EAAE;MACzB/L,EAAE,GAAG+L,SAAS;MACdA,SAAS,GAAG,CAAC,CAAC;MACdC,WAAW,GAAG,IAAIG,IAAI,CAAC,CAAC;IAC1B;IACA,IAAInP,UAAU,CAAC8O,OAAO,CAAC,EAAE;MACvB9L,EAAE,GAAG8L,OAAO;MACZC,SAAS,GAAG,CAAC,CAAC;MACdD,OAAO,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAC;MAC3BE,WAAW,GAAG,IAAIG,IAAI,CAAC,CAAC;IAC1B;IACA,IAAI,CAAClP,QAAQ,CAAC6O,OAAO,CAAC,EAAE;MACtB,MAAM,IAAI3M,SAAS,CAAC,oCAAoC,CAAC;IAC3D;IACA,IAAI,CAACjC,QAAQ,CAAC6O,SAAS,CAAC,EAAE;MACxB,MAAM,IAAI5M,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAI,CAAC7B,WAAW,CAAC0O,WAAW,CAAC,EAAE;MAC7B,MAAM,IAAI7M,SAAS,CAAC,gDAAgD,CAAC;IACvE;IACA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI2E,KAAK,GAAGhI,WAAW,CAACwJ,SAAS,CAACyG,SAAS,CAAC;IAC5C,IAAI,CAACK,eAAe,CAACvM,UAAU,EAAE,CAACuC,CAAC,EAAEtC,MAAM,KAAK;MAC9C,IAAIsC,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA;MACA;MACA,IAAIiK,GAAG;MACP,IAAIC,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAAC;QAAE7L,MAAM;QAAEZ,MAAM;QAAED,UAAU;QAAE2D,UAAU;QAAEM;MAAM,CAAC,CAAC;MAE1F,IAAI,CAAC0I,oBAAoB,CAAC,CAAC;MAC3B,IAAI;QACFH,GAAG,GAAGzN,kBAAkB,CACtB0N,UAAU,EACV,IAAI,CAACG,SAAS,EACd,IAAI,CAACC,SAAS,EACd,IAAI,CAACC,YAAY,EACjB7M,MAAM,EACNkM,WAAW,EACXF,OACF,CAAC;MACH,CAAC,CAAC,OAAOc,EAAE,EAAE;QACX,OAAO5M,EAAE,CAAC4M,EAAE,CAAC;MACf;MACA5M,EAAE,CAAC,IAAI,EAAEqM,GAAG,CAAC;IACf,CAAC,CAAC;EACJ;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAQ,kBAAkBA,CAAChN,UAAU,EAAE2D,UAAU,EAAEsI,OAAO,EAAEgB,WAAW,EAAEd,WAAW,EAAEhM,EAAE,EAAE;IAChF,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IAEA,IAAIxG,UAAU,CAAC8P,WAAW,CAAC,EAAE;MAC3B9M,EAAE,GAAG8M,WAAW;MAChBA,WAAW,GAAG,CAAC,CAAC;MAChBd,WAAW,GAAG,IAAIG,IAAI,CAAC,CAAC;IAC1B;IAEA,IAAIY,gBAAgB,GAAG,CACrB,uBAAuB,EACvB,2BAA2B,EAC3B,kBAAkB,EAClB,wBAAwB,EACxB,8BAA8B,EAC9B,2BAA2B,CAC5B;IACDA,gBAAgB,CAACvK,OAAO,CAAEwK,MAAM,IAAK;MACnC,IAAIF,WAAW,KAAKzL,SAAS,IAAIyL,WAAW,CAACE,MAAM,CAAC,KAAK3L,SAAS,IAAI,CAACjE,QAAQ,CAAC0P,WAAW,CAACE,MAAM,CAAC,CAAC,EAAE;QACpG,MAAM,IAAI7N,SAAS,CAAE,mBAAkB6N,MAAO,6BAA4B,CAAC;MAC7E;IACF,CAAC,CAAC;IACF,OAAO,IAAI,CAACnB,YAAY,CAAC,KAAK,EAAEhM,UAAU,EAAE2D,UAAU,EAAEsI,OAAO,EAAEgB,WAAW,EAAEd,WAAW,EAAEhM,EAAE,CAAC;EAChG;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAiN,kBAAkBA,CAACpN,UAAU,EAAE2D,UAAU,EAAEsI,OAAO,EAAE9L,EAAE,EAAE;IACtD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,OAAO,IAAI,CAACqI,YAAY,CAAC,KAAK,EAAEhM,UAAU,EAAE2D,UAAU,EAAEsI,OAAO,EAAE9L,EAAE,CAAC;EACtE;;EAEA;EACAkN,aAAaA,CAAA,EAAG;IACd,OAAO,IAAI/O,UAAU,CAAC,CAAC;EACzB;;EAEA;EACA;EACA;EACAgP,mBAAmBA,CAACC,UAAU,EAAEpN,EAAE,EAAE;IAClC,IAAI,IAAI,CAACiM,SAAS,EAAE;MAClB,MAAM,IAAI/P,MAAM,CAACgQ,qBAAqB,CAAC,kEAAkE,CAAC;IAC5G;IACA,IAAI,CAAChP,QAAQ,CAACkQ,UAAU,CAAC,EAAE;MACzB,MAAM,IAAIjO,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,iCAAiC,CAAC;IACxD;IACA,IAAI,CAACiN,eAAe,CAACgB,UAAU,CAACC,QAAQ,CAACnM,MAAM,EAAE,CAACkB,CAAC,EAAEtC,MAAM,KAAK;MAC9D,IAAIsC,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAIkL,IAAI,GAAG,IAAInB,IAAI,CAAC,CAAC;MACrB,IAAIoB,OAAO,GAAG9P,YAAY,CAAC6P,IAAI,CAAC;MAEhC,IAAI,CAACd,oBAAoB,CAAC,CAAC;MAE3B,IAAI,CAACY,UAAU,CAAC5B,MAAM,CAACgC,UAAU,EAAE;QACjC;QACA;QACA,IAAI1B,OAAO,GAAG,IAAIK,IAAI,CAAC,CAAC;QACxBL,OAAO,CAAC2B,UAAU,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;QACpCL,UAAU,CAACM,UAAU,CAAC5B,OAAO,CAAC;MAChC;MAEAsB,UAAU,CAAC5B,MAAM,CAAC/E,UAAU,CAACrG,IAAI,CAAC,CAAC,IAAI,EAAE,aAAa,EAAEmN,OAAO,CAAC,CAAC;MACjEH,UAAU,CAACC,QAAQ,CAAC,YAAY,CAAC,GAAGE,OAAO;MAE3CH,UAAU,CAAC5B,MAAM,CAAC/E,UAAU,CAACrG,IAAI,CAAC,CAAC,IAAI,EAAE,kBAAkB,EAAE,kBAAkB,CAAC,CAAC;MACjFgN,UAAU,CAACC,QAAQ,CAAC,iBAAiB,CAAC,GAAG,kBAAkB;MAE3DD,UAAU,CAAC5B,MAAM,CAAC/E,UAAU,CAACrG,IAAI,CAAC,CAAC,IAAI,EAAE,mBAAmB,EAAE,IAAI,CAACqM,SAAS,GAAG,GAAG,GAAG9P,QAAQ,CAACmD,MAAM,EAAEwN,IAAI,CAAC,CAAC,CAAC;MAC7GF,UAAU,CAACC,QAAQ,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAACZ,SAAS,GAAG,GAAG,GAAG9P,QAAQ,CAACmD,MAAM,EAAEwN,IAAI,CAAC;MAEvF,IAAI,IAAI,CAACX,YAAY,EAAE;QACrBS,UAAU,CAAC5B,MAAM,CAAC/E,UAAU,CAACrG,IAAI,CAAC,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,CAACuM,YAAY,CAAC,CAAC;QACrFS,UAAU,CAACC,QAAQ,CAAC,sBAAsB,CAAC,GAAG,IAAI,CAACV,YAAY;MACjE;MAEA,IAAIgB,YAAY,GAAG7H,MAAM,CAACoF,IAAI,CAAC0C,IAAI,CAACtI,SAAS,CAAC8H,UAAU,CAAC5B,MAAM,CAAC,CAAC,CAACE,QAAQ,CAAC,QAAQ,CAAC;MAEpF0B,UAAU,CAACC,QAAQ,CAAC7B,MAAM,GAAGmC,YAAY;MAEzC,IAAIE,SAAS,GAAGlP,sBAAsB,CAACmB,MAAM,EAAEwN,IAAI,EAAE,IAAI,CAACZ,SAAS,EAAEiB,YAAY,CAAC;MAElFP,UAAU,CAACC,QAAQ,CAAC,iBAAiB,CAAC,GAAGQ,SAAS;MAClD,IAAIC,IAAI,GAAG,CAAC,CAAC;MACbA,IAAI,CAAChO,MAAM,GAAGA,MAAM;MACpBgO,IAAI,CAACjO,UAAU,GAAGuN,UAAU,CAACC,QAAQ,CAACnM,MAAM;MAC5C,IAAIoL,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAACuB,IAAI,CAAC;MAC7C,IAAIC,OAAO,GAAG,IAAI,CAACC,IAAI,IAAI,EAAE,IAAI,IAAI,CAACA,IAAI,KAAK,GAAG,GAAG,EAAE,GAAI,IAAG,IAAI,CAACA,IAAI,CAACtC,QAAQ,CAAC,CAAE,EAAC;MACpF,IAAIuC,MAAM,GAAI,GAAE3B,UAAU,CAAC4B,QAAS,KAAI5B,UAAU,CAAC6B,IAAK,GAAEJ,OAAQ,GAAEzB,UAAU,CAAC7Q,IAAK,EAAC;MACrFuE,EAAE,CAAC,IAAI,EAAE;QAAEoO,OAAO,EAAEH,MAAM;QAAEZ,QAAQ,EAAED,UAAU,CAACC;MAAS,CAAC,CAAC;IAC9D,CAAC,CAAC;EACJ;;EAEA;EACA;EACAgB,uBAAuBA,CAACxO,UAAU,EAAE2D,UAAU,EAAEX,QAAQ,EAAEyL,KAAK,EAAEtO,EAAE,EAAE;IACnE,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACpG,QAAQ,CAACyF,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAI1D,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAI,CAACjC,QAAQ,CAACoR,KAAK,CAAC,EAAE;MACpB,MAAM,IAAInP,SAAS,CAAC,iCAAiC,CAAC;IACxD;IACA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,iCAAiC,CAAC;IACxD;IAEA,IAAI,CAAC0D,QAAQ,EAAE;MACb,MAAM,IAAI3G,MAAM,CAACmD,oBAAoB,CAAC,0BAA0B,CAAC;IACnE;IAEA,IAAIqB,MAAM,GAAG,MAAM;IACnB,IAAIoD,KAAK,GAAI,YAAW7F,SAAS,CAAC4E,QAAQ,CAAE,EAAC;IAE7C,IAAIE,KAAK,GAAG,EAAE;IAEduL,KAAK,CAAC9L,OAAO,CAAE+L,OAAO,IAAK;MACzBxL,KAAK,CAAC3C,IAAI,CAAC;QACToO,IAAI,EAAE,CACJ;UACEC,UAAU,EAAEF,OAAO,CAACG;QACtB,CAAC,EACD;UACEC,IAAI,EAAEJ,OAAO,CAAC7J;QAChB,CAAC;MAEL,CAAC,CAAC;IACJ,CAAC,CAAC;IAEF,IAAIlE,aAAa,GAAG;MAAEoO,uBAAuB,EAAE7L;IAAM,CAAC;IACtD,IAAI7C,OAAO,GAAGlE,GAAG,CAACwE,aAAa,CAAC;IAEhC,IAAI,CAACQ,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM;IAAM,CAAC,EAAE5D,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACkC,CAAC,EAAE2E,QAAQ,KAAK;MACrG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAI4E,WAAW,GAAGnI,YAAY,CAACgQ,+BAA+B,CAAC,CAAC;MAChEjR,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAK;QACtB,IAAIA,MAAM,CAACwM,OAAO,EAAE;UAClB;UACA9O,EAAE,CAAC,IAAI9D,MAAM,CAAC6S,OAAO,CAACzM,MAAM,CAAC0M,UAAU,CAAC,CAAC;QAC3C,CAAC,MAAM;UACL,MAAMC,uBAAuB,GAAG;YAC9BvK,IAAI,EAAEpC,MAAM,CAACoC,IAAI;YACjBgG,SAAS,EAAE7N,YAAY,CAACkK,QAAQ,CAACpG,OAAO;UAC1C,CAAC;UACDX,EAAE,CAAC,IAAI,EAAEiP,uBAAuB,CAAC;QACnC;MACF,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;;EAEA;EACA/M,0BAA0BA,CAACrC,UAAU,EAAEsB,MAAM,EAAEK,SAAS,EAAEC,cAAc,EAAEF,SAAS,EAAE;IACnF,IAAI,CAAClE,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACzC,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,IAAI,CAAC/B,QAAQ,CAACoE,SAAS,CAAC,EAAE;MACxB,MAAM,IAAIrC,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAI,CAAC/B,QAAQ,CAACqE,cAAc,CAAC,EAAE;MAC7B,MAAM,IAAItC,SAAS,CAAC,2CAA2C,CAAC;IAClE;IACA,IAAI,CAAC/B,QAAQ,CAACmE,SAAS,CAAC,EAAE;MACxB,MAAM,IAAIpC,SAAS,CAAC,sCAAsC,CAAC;IAC7D;IACA,IAAI0J,OAAO,GAAG,EAAE;IAChBA,OAAO,CAACzI,IAAI,CAAE,UAASnC,SAAS,CAACkD,MAAM,CAAE,EAAC,CAAC;IAC3C0H,OAAO,CAACzI,IAAI,CAAE,aAAYnC,SAAS,CAACsD,SAAS,CAAE,EAAC,CAAC;IAEjD,IAAIC,SAAS,EAAE;MACbA,SAAS,GAAGvD,SAAS,CAACuD,SAAS,CAAC;MAChCqH,OAAO,CAACzI,IAAI,CAAE,cAAaoB,SAAU,EAAC,CAAC;IACzC;IACA,IAAIC,cAAc,EAAE;MAClBoH,OAAO,CAACzI,IAAI,CAAE,oBAAmBqB,cAAe,EAAC,CAAC;IACpD;IAEA,IAAIyN,UAAU,GAAG,IAAI;IACrBrG,OAAO,CAACzI,IAAI,CAAE,eAAc8O,UAAW,EAAC,CAAC;IACzCrG,OAAO,CAACC,IAAI,CAAC,CAAC;IACdD,OAAO,CAACsG,OAAO,CAAC,SAAS,CAAC;IAC1B,IAAIrL,KAAK,GAAG,EAAE;IACd,IAAI+E,OAAO,CAAC7G,MAAM,GAAG,CAAC,EAAE;MACtB8B,KAAK,GAAI,GAAE+E,OAAO,CAACE,IAAI,CAAC,GAAG,CAAE,EAAC;IAChC;IACA,IAAIrI,MAAM,GAAG,KAAK;IAClB,IAAIsG,WAAW,GAAGnI,YAAY,CAACuQ,2BAA2B,CAAC,CAAC;IAC5D,IAAI,CAACpO,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAO4E,WAAW,CAAC3E,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC;MACrC;MACAxE,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC;IAClC,CAAC,CAAC;IACF,OAAOA,WAAW;EACpB;;EAEA;EACAnD,YAAYA,CAAChE,UAAU,EAAE2D,UAAU,EAAExD,EAAE,EAAE;IACvC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACxG,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,iCAAiC,CAAC;IACxD;IACA,IAAIkQ,YAAY;IAChB,IAAIC,QAAQ,GAAGA,CAAC9N,SAAS,EAAEC,cAAc,KAAK;MAC5C,IAAI,CAACS,0BAA0B,CAACrC,UAAU,EAAE2D,UAAU,EAAEhC,SAAS,EAAEC,cAAc,EAAE,EAAE,CAAC,CACnFU,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAK;QACtBA,MAAM,CAACZ,OAAO,CAACc,OAAO,CAAEE,MAAM,IAAK;UACjC,IAAIA,MAAM,CAACE,GAAG,KAAKY,UAAU,EAAE;YAC7B,IAAI,CAAC6L,YAAY,IAAI3M,MAAM,CAAC6M,SAAS,CAACC,OAAO,CAAC,CAAC,GAAGH,YAAY,CAACE,SAAS,CAACC,OAAO,CAAC,CAAC,EAAE;cAClFH,YAAY,GAAG3M,MAAM;cACrB;YACF;UACF;QACF,CAAC,CAAC;QACF,IAAIJ,MAAM,CAACa,WAAW,EAAE;UACtBmM,QAAQ,CAAChN,MAAM,CAACc,aAAa,EAAEd,MAAM,CAACe,kBAAkB,CAAC;UACzD;QACF;QACA,IAAIgM,YAAY,EAAE;UAChB,OAAOrP,EAAE,CAAC,IAAI,EAAEqP,YAAY,CAACxM,QAAQ,CAAC;QACxC;QACA7C,EAAE,CAAC,IAAI,EAAEqB,SAAS,CAAC;MACrB,CAAC,CAAC;IACN,CAAC;IACDiO,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC;EAClB;;EAEA;EACAG,qBAAqBA,CAAC5P,UAAU,EAAE6P,MAAM,EAAE1P,EAAE,EAAE;IAC5C,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC3C,QAAQ,CAACwS,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIvQ,SAAS,CAAC,gDAAgD,CAAC;IACvE;IACA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAIuB,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,cAAc;IAC1B,IAAIgH,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAC/B4E,QAAQ,EAAE,2BAA2B;MACrCC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAC7B7E,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAI9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACyE,MAAM,CAAC;IACzC,IAAI,CAAC1O,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE5D,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EAChF;EAEA8P,2BAA2BA,CAACjQ,UAAU,EAAEG,EAAE,EAAE;IAC1C,IAAI,CAACyP,qBAAqB,CAAC5P,UAAU,EAAE,IAAItB,kBAAkB,CAAC,CAAC,EAAEyB,EAAE,CAAC;EACtE;;EAEA;EACA;EACA+P,qBAAqBA,CAAClQ,UAAU,EAAEG,EAAE,EAAE;IACpC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,IAAIuB,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,cAAc;IAC1B,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAI4E,WAAW,GAAGnI,YAAY,CAACmR,gCAAgC,CAAC,CAAC;MACjE,IAAIC,kBAAkB;MACtBrS,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAM2N,kBAAkB,GAAG3N,MAAO,CAAC,CACrDH,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,KAAK,EAAE,MAAMnC,EAAE,CAAC,IAAI,EAAEiQ,kBAAkB,CAAC,CAAC;IAClD,CAAC,CAAC;EACJ;;EAEA;EACAC,wBAAwBA,CAACrQ,UAAU,EAAEsB,MAAM,EAAEgP,MAAM,EAAEC,MAAM,EAAE;IAC3D,IAAI,CAAC/S,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACzC,QAAQ,CAAC+D,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhC,SAAS,CAAC,+BAA+B,CAAC;IACtD;IACA,IAAI,CAAC/B,QAAQ,CAAC+S,MAAM,CAAC,EAAE;MACrB,MAAM,IAAIhR,SAAS,CAAC,+BAA+B,CAAC;IACtD;IACA,IAAI,CAAC4K,KAAK,CAACC,OAAO,CAACoG,MAAM,CAAC,EAAE;MAC1B,MAAM,IAAIjR,SAAS,CAAC,8BAA8B,CAAC;IACrD;IACA,IAAIkR,QAAQ,GAAG,IAAI7R,kBAAkB,CAAC,IAAI,EAAEqB,UAAU,EAAEsB,MAAM,EAAEgP,MAAM,EAAEC,MAAM,CAAC;IAC/EC,QAAQ,CAACC,KAAK,CAAC,CAAC;IAEhB,OAAOD,QAAQ;EACjB;EAEAE,mBAAmBA,CAAC1Q,UAAU,EAAEG,EAAE,EAAE;IAClC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IACA,IAAIqB,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,YAAY;IAExB,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAIoO,aAAa,GAAG1K,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACnCtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAAC4R,2BAA2B,CAAC,CAAC,CAAC,CAC5DtO,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpBsJ,aAAa,GAAGtJ,IAAI;MACtB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEwQ,aAAa,CAAC;MACzB,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAE,mBAAmBA,CAAC7Q,UAAU,EAAE2Q,aAAa,EAAExQ,EAAE,EAAE;IACjD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC0H,MAAM,CAACoJ,IAAI,CAACH,aAAa,CAAC,CAACxO,MAAM,EAAE;MACtC,MAAM,IAAI9F,MAAM,CAACmD,oBAAoB,CAAC,0CAA0C,CAAC;IACnF;IACA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIuB,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,YAAY;IACxB,IAAIgH,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAC/B4E,QAAQ,EAAE,yBAAyB;MACnCC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAC7B7E,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAI9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACuF,aAAa,CAAC;IAEhD,IAAI,CAACxP,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE5D,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EAChF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4Q,UAAUA,CAACC,aAAa,EAAE;IACxB,MAAM;MAAEhR,UAAU;MAAE2D,UAAU;MAAEsN,IAAI;MAAEC,OAAO,GAAG,CAAC,CAAC;MAAE/Q;IAAG,CAAC,GAAG6Q,aAAa;IACxE,MAAMnQ,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,SAAS;IAErB,IAAIiN,OAAO,IAAIA,OAAO,CAACrG,SAAS,EAAE;MAChC5G,KAAK,GAAI,GAAEA,KAAM,cAAaiN,OAAO,CAACrG,SAAU,EAAC;IACnD;IACA,MAAMsG,QAAQ,GAAG,EAAE;IACnB,KAAK,MAAM,CAACpO,GAAG,EAAE4H,KAAK,CAAC,IAAIjD,MAAM,CAAC0J,OAAO,CAACH,IAAI,CAAC,EAAE;MAC/CE,QAAQ,CAAC5Q,IAAI,CAAC;QAAEyH,GAAG,EAAEjF,GAAG;QAAEsO,KAAK,EAAE1G;MAAM,CAAC,CAAC;IAC3C;IACA,MAAM2G,aAAa,GAAG;MACpBC,OAAO,EAAE;QACPC,MAAM,EAAE;UACNC,GAAG,EAAEN;QACP;MACF;IACF,CAAC;IACD,MAAM3G,OAAO,GAAG,IAAItO,WAAW,CAAC,CAAC;IACjC,MAAM4E,OAAO,GAAG,CAAC,CAAC;IAClB,MAAMmK,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAAEC,QAAQ,EAAE,IAAI;MAAE4E,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM;IAAE,CAAC,CAAC;IACrF,IAAI3P,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACkG,aAAa,CAAC;IAChDjR,OAAO,GAAG4F,MAAM,CAACoF,IAAI,CAACb,OAAO,CAACc,MAAM,CAACjL,OAAO,CAAC,CAAC;IAC9CS,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IACvC,MAAMqR,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAEiE,KAAK;MAAEnD;IAAQ,CAAC;IAE7D,IAAI6C,UAAU,EAAE;MACd+N,cAAc,CAAC,YAAY,CAAC,GAAG/N,UAAU;IAC3C;IACA7C,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IAEvC,IAAI,CAACc,WAAW,CAACuQ,cAAc,EAAErR,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EACjE;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEwR,gBAAgBA,CAAC3R,UAAU,EAAEiR,IAAI,EAAE9Q,EAAE,EAAE;IACrC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC3C,QAAQ,CAAC4T,IAAI,CAAC,EAAE;MACnB,MAAM,IAAI5U,MAAM,CAACmD,oBAAoB,CAAC,iCAAiC,CAAC;IAC1E;IACA,IAAIkI,MAAM,CAACoJ,IAAI,CAACG,IAAI,CAAC,CAAC9O,MAAM,GAAG,EAAE,EAAE;MACjC,MAAM,IAAI9F,MAAM,CAACmD,oBAAoB,CAAC,6BAA6B,CAAC;IACtE;IACA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IAEA,OAAO,IAAI,CAACuR,UAAU,CAAC;MAAE/Q,UAAU;MAAEiR,IAAI;MAAE9Q;IAAG,CAAC,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEyR,gBAAgBA,CAAC5R,UAAU,EAAE2D,UAAU,EAAEsN,IAAI,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE/Q,EAAE,EAAE;IAC/D,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGuD,UAAU,CAAC;IAC/E;IAEA,IAAIxG,UAAU,CAAC+T,OAAO,CAAC,EAAE;MACvB/Q,EAAE,GAAG+Q,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,CAAC7T,QAAQ,CAAC4T,IAAI,CAAC,EAAE;MACnB,MAAM,IAAI5U,MAAM,CAACmD,oBAAoB,CAAC,iCAAiC,CAAC;IAC1E;IACA,IAAIkI,MAAM,CAACoJ,IAAI,CAACG,IAAI,CAAC,CAAC9O,MAAM,GAAG,EAAE,EAAE;MACjC,MAAM,IAAI9F,MAAM,CAACmD,oBAAoB,CAAC,6BAA6B,CAAC;IACtE;IAEA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,OAAO,IAAI,CAACyR,UAAU,CAAC;MAAE/Q,UAAU;MAAE2D,UAAU;MAAEsN,IAAI;MAAEC,OAAO;MAAE/Q;IAAG,CAAC,CAAC;EACvE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE0R,aAAaA,CAAC;IAAE7R,UAAU;IAAE2D,UAAU;IAAEmO,UAAU;IAAE3R;EAAG,CAAC,EAAE;IACxD,MAAMU,MAAM,GAAG,QAAQ;IACvB,IAAIoD,KAAK,GAAG,SAAS;IAErB,IAAI6N,UAAU,IAAIpK,MAAM,CAACoJ,IAAI,CAACgB,UAAU,CAAC,CAAC3P,MAAM,IAAI2P,UAAU,CAACjH,SAAS,EAAE;MACxE5G,KAAK,GAAI,GAAEA,KAAM,cAAa6N,UAAU,CAACjH,SAAU,EAAC;IACtD;IACA,MAAM6G,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM;IAAM,CAAC;IAEhE,IAAIN,UAAU,EAAE;MACd+N,cAAc,CAAC,YAAY,CAAC,GAAG/N,UAAU;IAC3C;IACA,IAAI,CAACxC,WAAW,CAACuQ,cAAc,EAAE,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAEvR,EAAE,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;EACE4R,mBAAmBA,CAAC/R,UAAU,EAAEG,EAAE,EAAE;IAClC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IACA,OAAO,IAAI,CAACuS,aAAa,CAAC;MAAE7R,UAAU;MAAEG;IAAG,CAAC,CAAC;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE6R,mBAAmBA,CAAChS,UAAU,EAAE2D,UAAU,EAAEmO,UAAU,EAAE3R,EAAE,EAAE;IAC1D,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGuD,UAAU,CAAC;IAC/E;IACA,IAAIxG,UAAU,CAAC2U,UAAU,CAAC,EAAE;MAC1B3R,EAAE,GAAG2R,UAAU;MACfA,UAAU,GAAG,CAAC,CAAC;IACjB;IACA,IAAIA,UAAU,IAAIpK,MAAM,CAACoJ,IAAI,CAACgB,UAAU,CAAC,CAAC3P,MAAM,IAAI,CAAC9E,QAAQ,CAACyU,UAAU,CAAC,EAAE;MACzE,MAAM,IAAIzV,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IAEA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,OAAO,IAAI,CAACuS,aAAa,CAAC;MAAE7R,UAAU;MAAE2D,UAAU;MAAEmO,UAAU;MAAE3R;IAAG,CAAC,CAAC;EACvE;;EAEA;AACF;AACA;AACA;AACA;EACE8R,gBAAgBA,CAACjS,UAAU,EAAEG,EAAE,EAAE;IAC/B,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IAEA,MAAMa,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,SAAS;IACvB,MAAMyN,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC;IAEpD,IAAI,CAAC9C,WAAW,CAACuQ,cAAc,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACnP,CAAC,EAAE2E,QAAQ,KAAK;MACrE,IAAIC,WAAW,GAAGnI,YAAY,CAACkT,kBAAkB,CAAC,CAAC;MACnD,IAAI3P,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAI4O,QAAQ;MACZpT,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAM0O,QAAQ,GAAG1O,MAAO,CAAC,CAC3CH,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,KAAK,EAAE,MAAMnC,EAAE,CAAC,IAAI,EAAEgR,QAAQ,CAAC,CAAC;IACxC,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEgB,gBAAgBA,CAACnS,UAAU,EAAE2D,UAAU,EAAES,OAAO,GAAG,CAAC,CAAC,EAAEjE,EAAE,GAAGA,CAAA,KAAM,KAAK,EAAE;IACvE,MAAMU,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,SAAS;IAErB,IAAI,CAACzG,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGuD,UAAU,CAAC;IAC/E;IACA,IAAIxG,UAAU,CAACiH,OAAO,CAAC,EAAE;MACvBjE,EAAE,GAAGiE,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IACA,IAAI,CAAC/G,QAAQ,CAAC+G,OAAO,CAAC,EAAE;MACtB,MAAM,IAAI/H,MAAM,CAACmD,oBAAoB,CAAC,oCAAoC,CAAC;IAC7E;IACA,IAAI,CAACrC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAI8E,OAAO,IAAIA,OAAO,CAACyG,SAAS,EAAE;MAChC5G,KAAK,GAAI,GAAEA,KAAM,cAAaG,OAAO,CAACyG,SAAU,EAAC;IACnD;IACA,MAAM6G,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC;IACpD,IAAIN,UAAU,EAAE;MACd+N,cAAc,CAAC,YAAY,CAAC,GAAG/N,UAAU;IAC3C;IAEA,IAAI,CAACxC,WAAW,CAACuQ,cAAc,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACnP,CAAC,EAAE2E,QAAQ,KAAK;MACrE,MAAMC,WAAW,GAAGnI,YAAY,CAACkT,kBAAkB,CAAC,CAAC;MACrD,IAAI3P,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAI4O,QAAQ;MACZpT,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAM0O,QAAQ,GAAG1O,MAAO,CAAC,CAC3CH,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,KAAK,EAAE,MAAMnC,EAAE,CAAC,IAAI,EAAEgR,QAAQ,CAAC,CAAC;IACxC,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEiB,oBAAoBA,CAACpS,UAAU,EAAEqS,YAAY,EAAElS,EAAE,EAAE;IACjD,MAAMU,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,WAAW;IAEzB,MAAMuG,OAAO,GAAG,IAAItO,WAAW,CAAC,CAAC;IACjC,MAAM4E,OAAO,GAAG,CAAC,CAAC;IAClB,MAAMmK,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MACjC4E,QAAQ,EAAE,wBAAwB;MAClC3E,QAAQ,EAAE,IAAI;MACd4E,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM;IAC9B,CAAC,CAAC;IACF,IAAI3P,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACiH,YAAY,CAAC;IAC/ChS,OAAO,GAAG4F,MAAM,CAACoF,IAAI,CAACb,OAAO,CAACc,MAAM,CAACjL,OAAO,CAAC,CAAC;IAC9C,MAAMqR,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAEiE,KAAK;MAAEnD;IAAQ,CAAC;IAC7DA,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IAEvC,IAAI,CAACc,WAAW,CAACuQ,cAAc,EAAErR,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EACjE;;EAEA;AACF;AACA;AACA;EACEmS,qBAAqBA,CAACtS,UAAU,EAAEG,EAAE,EAAE;IACpC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,MAAMa,MAAM,GAAG,QAAQ;IACvB,MAAMoD,KAAK,GAAG,WAAW;IACzB,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE9D,EAAE,CAAC;EAC3E;;EAEA;AACF;AACA;AACA;AACA;EACEoS,kBAAkBA,CAACvS,UAAU,EAAEwS,eAAe,GAAG,IAAI,EAAErS,EAAE,EAAE;IACzD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAIhE,CAAC,CAACyW,OAAO,CAACD,eAAe,CAAC,EAAE;MAC9B,IAAI,CAACF,qBAAqB,CAACtS,UAAU,EAAEG,EAAE,CAAC;IAC5C,CAAC,MAAM;MACL,IAAI,CAACiS,oBAAoB,CAACpS,UAAU,EAAEwS,eAAe,EAAErS,EAAE,CAAC;IAC5D;EACF;;EAEA;AACF;AACA;AACA;EACEuS,kBAAkBA,CAAC1S,UAAU,EAAEG,EAAE,EAAE;IACjC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,MAAMa,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,WAAW;IACzB,MAAMyN,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC;IAEpD,IAAI,CAAC9C,WAAW,CAACuQ,cAAc,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACnP,CAAC,EAAE2E,QAAQ,KAAK;MACrE,MAAMC,WAAW,GAAGnI,YAAY,CAAC2T,oBAAoB,CAAC,CAAC;MACvD,IAAIpQ,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACA,IAAIqQ,eAAe;MACnB7U,SAAS,CAACmJ,QAAQ,EAAEC,WAAW,CAAC,CAC7B7E,EAAE,CAAC,MAAM,EAAGG,MAAM,IAAMmQ,eAAe,GAAGnQ,MAAO,CAAC,CAClDH,EAAE,CAAC,OAAO,EAAGC,CAAC,IAAKpC,EAAE,CAACoC,CAAC,CAAC,CAAC,CACzBD,EAAE,CAAC,KAAK,EAAE,MAAMnC,EAAE,CAAC,IAAI,EAAEyS,eAAe,CAAC,CAAC;IAC/C,CAAC,CAAC;EACJ;EAEAC,mBAAmBA,CAAC7S,UAAU,EAAE8S,cAAc,GAAG,CAAC,CAAC,EAAE3S,EAAE,EAAE;IACvD,MAAM4S,cAAc,GAAG,CAACvU,eAAe,CAACwU,UAAU,EAAExU,eAAe,CAACyU,UAAU,CAAC;IAC/E,MAAMC,UAAU,GAAG,CAACzU,wBAAwB,CAAC0U,IAAI,EAAE1U,wBAAwB,CAAC2U,KAAK,CAAC;IAElF,IAAI,CAAC5V,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IAEA,IAAI8S,cAAc,CAACO,IAAI,IAAI,CAACN,cAAc,CAACO,QAAQ,CAACR,cAAc,CAACO,IAAI,CAAC,EAAE;MACxE,MAAM,IAAI/T,SAAS,CAAE,wCAAuCyT,cAAe,EAAC,CAAC;IAC/E;IACA,IAAID,cAAc,CAACS,IAAI,IAAI,CAACL,UAAU,CAACI,QAAQ,CAACR,cAAc,CAACS,IAAI,CAAC,EAAE;MACpE,MAAM,IAAIjU,SAAS,CAAE,wCAAuC4T,UAAW,EAAC,CAAC;IAC3E;IACA,IAAIJ,cAAc,CAACU,QAAQ,IAAI,CAACpW,QAAQ,CAAC0V,cAAc,CAACU,QAAQ,CAAC,EAAE;MACjE,MAAM,IAAIlU,SAAS,CAAE,4CAA2C,CAAC;IACnE;IAEA,MAAMuB,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,aAAa;IAE3B,IAAI4L,MAAM,GAAG;MACX4D,iBAAiB,EAAE;IACrB,CAAC;IACD,MAAMC,UAAU,GAAGhM,MAAM,CAACoJ,IAAI,CAACgC,cAAc,CAAC;IAC9C;IACA,IAAIY,UAAU,CAACvR,MAAM,GAAG,CAAC,EAAE;MACzB,IAAInG,CAAC,CAAC2X,UAAU,CAACD,UAAU,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC,CAACvR,MAAM,KAAK,CAAC,EAAE;QACvE,MAAM,IAAI7C,SAAS,CAChB,yGACH,CAAC;MACH,CAAC,MAAM;QACLuQ,MAAM,CAAC+D,IAAI,GAAG;UACZC,gBAAgB,EAAE,CAAC;QACrB,CAAC;QACD,IAAIf,cAAc,CAACO,IAAI,EAAE;UACvBxD,MAAM,CAAC+D,IAAI,CAACC,gBAAgB,CAACC,IAAI,GAAGhB,cAAc,CAACO,IAAI;QACzD;QACA,IAAIP,cAAc,CAACS,IAAI,KAAK9U,wBAAwB,CAAC0U,IAAI,EAAE;UACzDtD,MAAM,CAAC+D,IAAI,CAACC,gBAAgB,CAACE,IAAI,GAAGjB,cAAc,CAACU,QAAQ;QAC7D,CAAC,MAAM,IAAIV,cAAc,CAACS,IAAI,KAAK9U,wBAAwB,CAAC2U,KAAK,EAAE;UACjEvD,MAAM,CAAC+D,IAAI,CAACC,gBAAgB,CAACG,KAAK,GAAGlB,cAAc,CAACU,QAAQ;QAC9D;MACF;IACF;IAEA,MAAMvI,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MACjC4E,QAAQ,EAAE,yBAAyB;MACnCC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAC7B7E,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,MAAM9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACyE,MAAM,CAAC;IAE3C,MAAM/O,OAAO,GAAG,CAAC,CAAC;IAClBA,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IAEvC,IAAI,CAACc,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE,KAAK;MAAEnD;IAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EACzF;EAEA8T,mBAAmBA,CAACjU,UAAU,EAAEG,EAAE,EAAE;IAClC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IACA,MAAMqB,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,aAAa;IAE3B,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAI2R,gBAAgB,GAAGjO,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACtCtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACmV,qBAAqB,CAAC,CAAC,CAAC,CACtD7R,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpB6M,gBAAgB,GAAG7M,IAAI;MACzB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAE+T,gBAAgB,CAAC;MAC5B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAE,kBAAkBA,CAACpU,UAAU,EAAE2D,UAAU,EAAE0Q,aAAa,GAAG,CAAC,CAAC,EAAElU,EAAE,EAAE;IACjE,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACtG,QAAQ,CAACgX,aAAa,CAAC,EAAE;MAC5B,MAAM,IAAIhY,MAAM,CAACmD,oBAAoB,CAAC,0CAA0C,CAAC;IACnF,CAAC,MAAM;MACL,IAAI6U,aAAa,CAACC,gBAAgB,IAAI,CAACpX,SAAS,CAACmX,aAAa,CAACC,gBAAgB,CAAC,EAAE;QAChF,MAAM,IAAIjY,MAAM,CAACmD,oBAAoB,CAAC,oCAAoC,EAAE6U,aAAa,CAACC,gBAAgB,CAAC;MAC7G;MACA,IACED,aAAa,CAAChB,IAAI,IAClB,CAAC,CAAC7U,eAAe,CAACwU,UAAU,EAAExU,eAAe,CAACyU,UAAU,CAAC,CAACK,QAAQ,CAACe,aAAa,CAAChB,IAAI,CAAC,EACtF;QACA,MAAM,IAAIhX,MAAM,CAACmD,oBAAoB,CAAC,gCAAgC,EAAE6U,aAAa,CAAChB,IAAI,CAAC;MAC7F;MACA,IAAIgB,aAAa,CAACE,eAAe,IAAI,CAAChX,QAAQ,CAAC8W,aAAa,CAACE,eAAe,CAAC,EAAE;QAC7E,MAAM,IAAIlY,MAAM,CAACmD,oBAAoB,CAAC,mCAAmC,EAAE6U,aAAa,CAACE,eAAe,CAAC;MAC3G;MACA,IAAIF,aAAa,CAACxJ,SAAS,IAAI,CAACtN,QAAQ,CAAC8W,aAAa,CAACxJ,SAAS,CAAC,EAAE;QACjE,MAAM,IAAIxO,MAAM,CAACmD,oBAAoB,CAAC,6BAA6B,EAAE6U,aAAa,CAACxJ,SAAS,CAAC;MAC/F;IACF;IACA,IAAI,CAAC1N,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,MAAMuB,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,WAAW;IAEvB,MAAMnD,OAAO,GAAG,CAAC,CAAC;IAClB,IAAIuT,aAAa,CAACC,gBAAgB,EAAE;MAClCxT,OAAO,CAAC,mCAAmC,CAAC,GAAG,IAAI;IACrD;IAEA,MAAMmK,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAAE4E,QAAQ,EAAE,WAAW;MAAEC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAAE7E,QAAQ,EAAE;IAAK,CAAC,CAAC;IAC5G,MAAMqJ,MAAM,GAAG,CAAC,CAAC;IAEjB,IAAIH,aAAa,CAAChB,IAAI,EAAE;MACtBmB,MAAM,CAACV,IAAI,GAAGO,aAAa,CAAChB,IAAI;IAClC;IACA,IAAIgB,aAAa,CAACE,eAAe,EAAE;MACjCC,MAAM,CAACC,eAAe,GAAGJ,aAAa,CAACE,eAAe;IACxD;IACA,IAAIF,aAAa,CAACxJ,SAAS,EAAE;MAC3B5G,KAAK,IAAK,cAAaoQ,aAAa,CAACxJ,SAAU,EAAC;IAClD;IAEA,IAAIxK,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACoJ,MAAM,CAAC;IAEzC1T,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IACvC,IAAI,CAACc,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM,KAAK;MAAEnD;IAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EAC1G;EAEAuU,kBAAkBA,CAAC1U,UAAU,EAAE2D,UAAU,EAAES,OAAO,EAAEjE,EAAE,EAAE;IACtD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACtG,QAAQ,CAAC+G,OAAO,CAAC,EAAE;MACtB,MAAM,IAAI/H,MAAM,CAACmD,oBAAoB,CAAC,qCAAqC,CAAC;IAC9E,CAAC,MAAM,IAAI4E,OAAO,CAACyG,SAAS,IAAI,CAACtN,QAAQ,CAAC6G,OAAO,CAACyG,SAAS,CAAC,EAAE;MAC5D,MAAM,IAAIxO,MAAM,CAACmD,oBAAoB,CAAC,sCAAsC,CAAC;IAC/E;IACA,IAAIW,EAAE,IAAI,CAAChD,UAAU,CAACgD,EAAE,CAAC,EAAE;MACzB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IACA,MAAMqB,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,WAAW;IACvB,IAAIG,OAAO,CAACyG,SAAS,EAAE;MACrB5G,KAAK,IAAK,cAAaG,OAAO,CAACyG,SAAU,EAAC;IAC5C;IAEA,IAAI,CAAC1J,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MAChG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAIoS,eAAe,GAAG1O,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACrCtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAAC4V,0BAA0B,CAAC,CAAC,CAAC,CAC3DtS,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpBsN,eAAe,GAAGtN,IAAI;MACxB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEwU,eAAe,CAAC;MAC3B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAE,mBAAmBA,CAAC7U,UAAU,EAAE8U,gBAAgB,EAAE3U,EAAE,EAAE;IACpD,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IAEA,IAAI7C,UAAU,CAAC2X,gBAAgB,CAAC,EAAE;MAChC3U,EAAE,GAAG2U,gBAAgB;MACrBA,gBAAgB,GAAG,IAAI;IACzB;IAEA,IAAI,CAAC9Y,CAAC,CAACyW,OAAO,CAACqC,gBAAgB,CAAC,IAAIA,gBAAgB,CAAClB,IAAI,CAACzR,MAAM,GAAG,CAAC,EAAE;MACpE,MAAM,IAAI9F,MAAM,CAACmD,oBAAoB,CAAC,kDAAkD,GAAGsV,gBAAgB,CAAClB,IAAI,CAAC;IACnH;IACA,IAAIzT,EAAE,IAAI,CAAChD,UAAU,CAACgD,EAAE,CAAC,EAAE;MACzB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,IAAIyV,aAAa,GAAGD,gBAAgB;IACpC,IAAI9Y,CAAC,CAACyW,OAAO,CAACqC,gBAAgB,CAAC,EAAE;MAC/BC,aAAa,GAAG;QACd;QACAnB,IAAI,EAAE,CACJ;UACEoB,kCAAkC,EAAE;YAClCC,YAAY,EAAE;UAChB;QACF,CAAC;MAEL,CAAC;IACH;IAEA,IAAIpU,MAAM,GAAG,KAAK;IAClB,IAAIoD,KAAK,GAAG,YAAY;IACxB,IAAIgH,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAC/B4E,QAAQ,EAAE,mCAAmC;MAC7CC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAC7B7E,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,IAAI9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAAC2J,aAAa,CAAC;IAEhD,MAAMjU,OAAO,GAAG,CAAC,CAAC;IAClBA,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IAEvC,IAAI,CAACc,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE,KAAK;MAAEnD;IAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EACzF;EAEA+U,mBAAmBA,CAAClV,UAAU,EAAEG,EAAE,EAAE;IAClC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IACA,MAAMqB,MAAM,GAAG,KAAK;IACpB,MAAMoD,KAAK,GAAG,YAAY;IAE1B,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MACpF,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAI4S,eAAe,GAAGlP,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACrCtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACoW,2BAA2B,CAAC,CAAC,CAAC,CAC5D9S,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpB8N,eAAe,GAAG9N,IAAI;MACxB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEgV,eAAe,CAAC;MAC3B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EACAE,sBAAsBA,CAACrV,UAAU,EAAEG,EAAE,EAAE;IACrC,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAAC7C,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IACA,MAAMqB,MAAM,GAAG,QAAQ;IACvB,MAAMoD,KAAK,GAAG,YAAY;IAE1B,IAAI,CAAC9C,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAEiE;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE9D,EAAE,CAAC;EAC3E;EAEAmV,kBAAkBA,CAACtV,UAAU,EAAE2D,UAAU,EAAES,OAAO,GAAG,CAAC,CAAC,EAAEjE,EAAE,EAAE;IAC3D,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IAEA,IAAIxG,UAAU,CAACiH,OAAO,CAAC,EAAE;MACvBjE,EAAE,GAAGiE,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,CAAC/G,QAAQ,CAAC+G,OAAO,CAAC,EAAE;MACtB,MAAM,IAAI9E,SAAS,CAAC,oCAAoC,CAAC;IAC3D,CAAC,MAAM,IAAIoI,MAAM,CAACoJ,IAAI,CAAC1M,OAAO,CAAC,CAACjC,MAAM,GAAG,CAAC,IAAIiC,OAAO,CAACyG,SAAS,IAAI,CAACtN,QAAQ,CAAC6G,OAAO,CAACyG,SAAS,CAAC,EAAE;MAC/F,MAAM,IAAIvL,SAAS,CAAC,sCAAsC,EAAE8E,OAAO,CAACyG,SAAS,CAAC;IAChF;IAEA,IAAI,CAAC1N,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IAEA,MAAMqB,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,YAAY;IAExB,IAAIG,OAAO,CAACyG,SAAS,EAAE;MACrB5G,KAAK,IAAK,cAAaG,OAAO,CAACyG,SAAU,EAAC;IAC5C;IAEA,IAAI,CAAC1J,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM;IAAM,CAAC,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAAC1B,CAAC,EAAE2E,QAAQ,KAAK;MAChG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAIgT,eAAe,GAAGtP,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACrCtN,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACwW,0BAA0B,CAAC,CAAC,CAAC,CAC3DlT,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpBkO,eAAe,GAAGlO,IAAI;MACxB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEoV,eAAe,CAAC;MAC3B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAE,kBAAkBA,CAACzV,UAAU,EAAE2D,UAAU,EAAE+R,OAAO,GAAG,CAAC,CAAC,EAAEvV,EAAE,EAAE;IAC3D,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAC,uBAAuB,GAAGJ,UAAU,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IAEA,MAAMgS,WAAW,GAAG;MAClBC,MAAM,EAAErX,iBAAiB,CAACsX;IAC5B,CAAC;IACD,IAAI1Y,UAAU,CAACuY,OAAO,CAAC,EAAE;MACvBvV,EAAE,GAAGuV,OAAO;MACZA,OAAO,GAAGC,WAAW;IACvB;IAEA,IAAI,CAACtY,QAAQ,CAACqY,OAAO,CAAC,EAAE;MACtB,MAAM,IAAIpW,SAAS,CAAC,oCAAoC,CAAC;IAC3D,CAAC,MAAM;MACL,IAAI,CAAC,CAACf,iBAAiB,CAACsX,OAAO,EAAEtX,iBAAiB,CAACuX,QAAQ,CAAC,CAACxC,QAAQ,CAACoC,OAAO,CAACE,MAAM,CAAC,EAAE;QACrF,MAAM,IAAItW,SAAS,CAAC,kBAAkB,GAAGoW,OAAO,CAACE,MAAM,CAAC;MAC1D;MACA,IAAIF,OAAO,CAAC7K,SAAS,IAAI,CAAC6K,OAAO,CAAC7K,SAAS,CAAC1I,MAAM,EAAE;QAClD,MAAM,IAAI7C,SAAS,CAAC,sCAAsC,GAAGoW,OAAO,CAAC7K,SAAS,CAAC;MACjF;IACF;IAEA,IAAI,CAAC1N,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAI9D,MAAM,CAACmD,oBAAoB,CAAC,uCAAuC,CAAC;IAChF;IAEA,IAAIxD,CAAC,CAACyW,OAAO,CAACiD,OAAO,CAAC,EAAE;MACtBA,OAAO,GAAG;QACRC;MACF,CAAC;IACH;IAEA,MAAM9U,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAG,YAAY;IAExB,IAAIyR,OAAO,CAAC7K,SAAS,EAAE;MACrB5G,KAAK,IAAK,cAAayR,OAAO,CAAC7K,SAAU,EAAC;IAC5C;IAEA,IAAIgF,MAAM,GAAG;MACXkG,MAAM,EAAEL,OAAO,CAACE;IAClB,CAAC;IAED,MAAM3K,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MAAE4E,QAAQ,EAAE,WAAW;MAAEC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAAE7E,QAAQ,EAAE;IAAK,CAAC,CAAC;IAC5G,MAAM9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACyE,MAAM,CAAC;IAC3C,MAAM/O,OAAO,GAAG,CAAC,CAAC;IAClBA,OAAO,CAAC,aAAa,CAAC,GAAG3C,KAAK,CAACkC,OAAO,CAAC;IAEvC,IAAI,CAACc,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM,KAAK;MAAEnD;IAAQ,CAAC,EAAET,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,KAAK,EAAEF,EAAE,CAAC;EACrG;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6V,cAAcA,CAACC,UAAU,EAAE9V,EAAE,EAAE;IAC7B,MAAM;MAAEH,UAAU;MAAE2D,UAAU;MAAEuS,QAAQ;MAAEC,UAAU;MAAErV;IAAQ,CAAC,GAAGmV,UAAU;IAE5E,MAAMpV,MAAM,GAAG,KAAK;IACpB,IAAIoD,KAAK,GAAI,YAAWiS,QAAS,eAAcC,UAAW,EAAC;IAC3D,MAAMzE,cAAc,GAAG;MAAE7Q,MAAM;MAAEb,UAAU;MAAE2D,UAAU,EAAEA,UAAU;MAAEM,KAAK;MAAEnD;IAAQ,CAAC;IACrF,OAAO,IAAI,CAACK,WAAW,CAACuQ,cAAc,EAAE,EAAE,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACnP,CAAC,EAAE2E,QAAQ,KAAK;MAC5E,IAAIkP,cAAc,GAAGnQ,MAAM,CAACoF,IAAI,CAAC,EAAE,CAAC;MACpC,IAAI9I,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MACAxE,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACqX,qBAAqB,CAAC,CAAC,CAAC,CACtD/T,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpB+O,cAAc,GAAG/O,IAAI;MACvB,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACf,IAAIgU,iBAAiB,GAAG;UACtBzR,IAAI,EAAE3G,YAAY,CAACkY,cAAc,CAACtH,IAAI,CAAC;UACvC/L,GAAG,EAAEY,UAAU;UACfkL,IAAI,EAAEsH;QACR,CAAC;QAEDhW,EAAE,CAAC,IAAI,EAAEmW,iBAAiB,CAAC;MAC7B,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;EAEAC,aAAaA,CAACC,aAAa,GAAG,CAAC,CAAC,EAAEC,aAAa,GAAG,EAAE,EAAEtW,EAAE,EAAE;IACxD,MAAMuW,EAAE,GAAG,IAAI,EAAC;IAChB,MAAMC,iBAAiB,GAAGF,aAAa,CAACtU,MAAM;IAE9C,IAAI,CAAC+H,KAAK,CAACC,OAAO,CAACsM,aAAa,CAAC,EAAE;MACjC,MAAM,IAAIpa,MAAM,CAACmD,oBAAoB,CAAC,oDAAoD,CAAC;IAC7F;IACA,IAAI,EAAEgX,aAAa,YAAYla,sBAAsB,CAAC,EAAE;MACtD,MAAM,IAAID,MAAM,CAACmD,oBAAoB,CAAC,mDAAmD,CAAC;IAC5F;IAEA,IAAImX,iBAAiB,GAAG,CAAC,IAAIA,iBAAiB,GAAG9Y,gBAAgB,CAAC+Y,eAAe,EAAE;MACjF,MAAM,IAAIva,MAAM,CAACmD,oBAAoB,CAClC,yCAAwC3B,gBAAgB,CAAC+Y,eAAgB,kBAC5E,CAAC;IACH;IAEA,IAAI,CAACzZ,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,KAAK,IAAIuX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,iBAAiB,EAAEE,CAAC,EAAE,EAAE;MAC1C,IAAI,CAACJ,aAAa,CAACI,CAAC,CAAC,CAACpP,QAAQ,CAAC,CAAC,EAAE;QAChC,OAAO,KAAK;MACd;IACF;IAEA,IAAI,CAAC+O,aAAa,CAAC/O,QAAQ,CAAC,CAAC,EAAE;MAC7B,OAAO,KAAK;IACd;IAEA,MAAMqP,cAAc,GAAIC,SAAS,IAAK;MACpC,IAAIC,QAAQ,GAAG,CAAC,CAAC;MACjB,IAAI,CAAChb,CAAC,CAACyW,OAAO,CAACsE,SAAS,CAACE,SAAS,CAAC,EAAE;QACnCD,QAAQ,GAAG;UACTnM,SAAS,EAAEkM,SAAS,CAACE;QACvB,CAAC;MACH;MACA,OAAOD,QAAQ;IACjB,CAAC;IACD,MAAME,cAAc,GAAG,EAAE;IACzB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIC,UAAU,GAAG,CAAC;IAElB,MAAMC,cAAc,GAAGZ,aAAa,CAACa,GAAG,CAAEC,OAAO,IAC/Cb,EAAE,CAAChS,UAAU,CAAC6S,OAAO,CAAC1P,MAAM,EAAE0P,OAAO,CAAC7P,MAAM,EAAEoP,cAAc,CAACS,OAAO,CAAC,CACvE,CAAC;IAED,OAAOC,OAAO,CAACC,GAAG,CAACJ,cAAc,CAAC,CAC/BpU,IAAI,CAAEyU,cAAc,IAAK;MACxB,MAAMC,cAAc,GAAGD,cAAc,CAACJ,GAAG,CAAC,CAACM,WAAW,EAAEC,KAAK,KAAK;QAChE,MAAMd,SAAS,GAAGN,aAAa,CAACoB,KAAK,CAAC;QAEtC,IAAIC,WAAW,GAAGF,WAAW,CAACjY,IAAI;QAClC;QACA;QACA,IAAIoX,SAAS,CAACgB,UAAU,EAAE;UACxB;UACA;UACA;UACA,MAAMC,QAAQ,GAAGjB,SAAS,CAACkB,KAAK;UAChC,MAAMC,MAAM,GAAGnB,SAAS,CAACoB,GAAG;UAC5B,IAAID,MAAM,IAAIJ,WAAW,IAAIE,QAAQ,GAAG,CAAC,EAAE;YACzC,MAAM,IAAI3b,MAAM,CAACmD,oBAAoB,CAClC,kBAAiBqY,KAAM,iCAAgCG,QAAS,KAAIE,MAAO,cAAaJ,WAAY,GACvG,CAAC;UACH;UACAA,WAAW,GAAGI,MAAM,GAAGF,QAAQ,GAAG,CAAC;QACrC;;QAEA;QACA,IAAIF,WAAW,GAAGja,gBAAgB,CAACua,iBAAiB,IAAIP,KAAK,GAAGlB,iBAAiB,GAAG,CAAC,EAAE;UACrF,MAAM,IAAIta,MAAM,CAACmD,oBAAoB,CAClC,kBAAiBqY,KAAM,kBAAiBC,WAAY,gCACvD,CAAC;QACH;;QAEA;QACAX,SAAS,IAAIW,WAAW;QACxB,IAAIX,SAAS,GAAGtZ,gBAAgB,CAACwa,6BAA6B,EAAE;UAC9D,MAAM,IAAIhc,MAAM,CAACmD,oBAAoB,CAAE,oCAAmC2X,SAAU,WAAU,CAAC;QACjG;;QAEA;QACAD,cAAc,CAACW,KAAK,CAAC,GAAGC,WAAW;;QAEnC;QACAV,UAAU,IAAItZ,aAAa,CAACga,WAAW,CAAC;QACxC;QACA,IAAIV,UAAU,GAAGvZ,gBAAgB,CAAC+Y,eAAe,EAAE;UACjD,MAAM,IAAIva,MAAM,CAACmD,oBAAoB,CAClC,mDAAkD3B,gBAAgB,CAAC+Y,eAAgB,QACtF,CAAC;QACH;QAEA,OAAOgB,WAAW;MACpB,CAAC,CAAC;MAEF,IAAKR,UAAU,KAAK,CAAC,IAAID,SAAS,IAAItZ,gBAAgB,CAACya,aAAa,IAAKnB,SAAS,KAAK,CAAC,EAAE;QACxF,OAAO,IAAI,CAAC5O,UAAU,CAACkO,aAAa,CAAC,CAAC,CAAC,EAAED,aAAa,EAAErW,EAAE,CAAC,EAAC;MAC9D;;MAEA;MACA,KAAK,IAAI0W,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,iBAAiB,EAAEE,CAAC,EAAE,EAAE;QAC1CJ,aAAa,CAACI,CAAC,CAAC,CAAC0B,SAAS,GAAGZ,cAAc,CAACd,CAAC,CAAC,CAAChS,IAAI;MACrD;MAEA,MAAM2T,iBAAiB,GAAGb,cAAc,CAACL,GAAG,CAAC,CAACM,WAAW,EAAEa,GAAG,KAAK;QACjE,MAAMC,OAAO,GAAG9b,mBAAmB,CAACsa,cAAc,CAACuB,GAAG,CAAC,EAAEhC,aAAa,CAACgC,GAAG,CAAC,CAAC;QAC5E,OAAOC,OAAO;MAChB,CAAC,CAAC;MAEF,SAASC,uBAAuBA,CAAC3V,QAAQ,EAAE;QACzC,MAAM4V,oBAAoB,GAAG,EAAE;QAE/BJ,iBAAiB,CAAC7V,OAAO,CAAC,CAACkW,SAAS,EAAEC,UAAU,KAAK;UACnD,MAAM;YAAEC,UAAU,EAAEC,QAAQ;YAAEC,QAAQ,EAAEC,MAAM;YAAEC,OAAO,EAAEC;UAAU,CAAC,GAAGP,SAAS;UAEhF,IAAIQ,SAAS,GAAGP,UAAU,GAAG,CAAC,EAAC;UAC/B,MAAMQ,YAAY,GAAGpP,KAAK,CAACmB,IAAI,CAAC2N,QAAQ,CAAC;UAEzC,MAAMlY,OAAO,GAAG2V,aAAa,CAACqC,UAAU,CAAC,CAAClR,UAAU,CAAC,CAAC;UAEtD0R,YAAY,CAAC3W,OAAO,CAAC,CAAC4W,UAAU,EAAEC,UAAU,KAAK;YAC/C,IAAIC,QAAQ,GAAGP,MAAM,CAACM,UAAU,CAAC;YAEjC,MAAME,SAAS,GAAI,GAAEN,SAAS,CAACvR,MAAO,IAAGuR,SAAS,CAAC1R,MAAO,EAAC;YAC3D5G,OAAO,CAAC,mBAAmB,CAAC,GAAI,GAAE4Y,SAAU,EAAC;YAC7C5Y,OAAO,CAAC,yBAAyB,CAAC,GAAI,SAAQyY,UAAW,IAAGE,QAAS,EAAC;YAEtE,MAAME,gBAAgB,GAAG;cACvB3Z,UAAU,EAAEwW,aAAa,CAAC3O,MAAM;cAChClE,UAAU,EAAE6S,aAAa,CAAC9O,MAAM;cAChCwO,QAAQ,EAAElT,QAAQ;cAClBmT,UAAU,EAAEkD,SAAS;cACrBvY,OAAO,EAAEA,OAAO;cAChB4Y,SAAS,EAAEA;YACb,CAAC;YAEDd,oBAAoB,CAACrY,IAAI,CAACoZ,gBAAgB,CAAC;UAC7C,CAAC,CAAC;QACJ,CAAC,CAAC;QAEF,OAAOf,oBAAoB;MAC7B;MAEA,MAAMgB,kBAAkB,GAAI5W,QAAQ,IAAK;QACvC,MAAM6W,UAAU,GAAGlB,uBAAuB,CAAC3V,QAAQ,CAAC;QAEpDlH,KAAK,CAACwb,GAAG,CAACuC,UAAU,EAAEnD,EAAE,CAACV,cAAc,CAAC8D,IAAI,CAACpD,EAAE,CAAC,EAAE,CAACzV,GAAG,EAAE8Y,GAAG,KAAK;UAC9D,IAAI9Y,GAAG,EAAE;YACP,IAAI,CAAC+Y,oBAAoB,CAACxD,aAAa,CAAC3O,MAAM,EAAE2O,aAAa,CAAC9O,MAAM,EAAE1E,QAAQ,CAAC,CAACC,IAAI,CAClF,MAAM9C,EAAE,CAAC,CAAC,EACTc,GAAG,IAAKd,EAAE,CAACc,GAAG,CACjB,CAAC;YACD;UACF;UACA,MAAMgZ,SAAS,GAAGF,GAAG,CAACzC,GAAG,CAAE4C,QAAQ,KAAM;YAAErV,IAAI,EAAEqV,QAAQ,CAACrV,IAAI;YAAEgK,IAAI,EAAEqL,QAAQ,CAACrL;UAAK,CAAC,CAAC,CAAC;UACvF,OAAO6H,EAAE,CAAClI,uBAAuB,CAACgI,aAAa,CAAC3O,MAAM,EAAE2O,aAAa,CAAC9O,MAAM,EAAE1E,QAAQ,EAAEiX,SAAS,EAAE9Z,EAAE,CAAC;QACxG,CAAC,CAAC;MACJ,CAAC;MAED,MAAMga,gBAAgB,GAAG3D,aAAa,CAAC5O,UAAU,CAAC,CAAC;MAEnD8O,EAAE,CAAC0D,0BAA0B,CAAC5D,aAAa,CAAC3O,MAAM,EAAE2O,aAAa,CAAC9O,MAAM,EAAEyS,gBAAgB,CAAC,CAAClX,IAAI,CAC7FD,QAAQ,IAAK;QACZ4W,kBAAkB,CAAC5W,QAAQ,CAAC;MAC9B,CAAC,EACA/B,GAAG,IAAK;QACPd,EAAE,CAACc,GAAG,EAAE,IAAI,CAAC;MACf,CACF,CAAC;IACH,CAAC,CAAC,CACDoZ,KAAK,CAAEC,KAAK,IAAK;MAChBna,EAAE,CAACma,KAAK,EAAE,IAAI,CAAC;IACjB,CAAC,CAAC;EACN;EACAC,mBAAmBA,CAACva,UAAU,EAAE2D,UAAU,EAAE6W,UAAU,GAAG,CAAC,CAAC,EAAEra,EAAE,EAAE;IAC/D,IAAI,CAAC3C,iBAAiB,CAACwC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAI3D,MAAM,CAAC+D,sBAAsB,CAAE,wBAAuBJ,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAACtC,iBAAiB,CAACiG,UAAU,CAAC,EAAE;MAClC,MAAM,IAAItH,MAAM,CAACwH,sBAAsB,CAAE,wBAAuBF,UAAW,EAAC,CAAC;IAC/E;IACA,IAAI,CAAC3H,CAAC,CAACyW,OAAO,CAAC+H,UAAU,CAAC,EAAE;MAC1B,IAAI,CAACjd,QAAQ,CAACid,UAAU,CAACC,UAAU,CAAC,EAAE;QACpC,MAAM,IAAInb,SAAS,CAAC,0CAA0C,CAAC;MACjE;MACA,IAAI,CAACtD,CAAC,CAACyW,OAAO,CAAC+H,UAAU,CAACE,kBAAkB,CAAC,EAAE;QAC7C,IAAI,CAACrd,QAAQ,CAACmd,UAAU,CAACE,kBAAkB,CAAC,EAAE;UAC5C,MAAM,IAAIpb,SAAS,CAAC,+CAA+C,CAAC;QACtE;MACF,CAAC,MAAM;QACL,MAAM,IAAIA,SAAS,CAAC,gCAAgC,CAAC;MACvD;MACA,IAAI,CAACtD,CAAC,CAACyW,OAAO,CAAC+H,UAAU,CAACG,mBAAmB,CAAC,EAAE;QAC9C,IAAI,CAACtd,QAAQ,CAACmd,UAAU,CAACG,mBAAmB,CAAC,EAAE;UAC7C,MAAM,IAAIrb,SAAS,CAAC,gDAAgD,CAAC;QACvE;MACF,CAAC,MAAM;QACL,MAAM,IAAIA,SAAS,CAAC,iCAAiC,CAAC;MACxD;IACF,CAAC,MAAM;MACL,MAAM,IAAIA,SAAS,CAAC,wCAAwC,CAAC;IAC/D;IAEA,IAAI,CAACnC,UAAU,CAACgD,EAAE,CAAC,EAAE;MACnB,MAAM,IAAIb,SAAS,CAAC,uCAAuC,CAAC;IAC9D;IAEA,MAAMuB,MAAM,GAAG,MAAM;IACrB,IAAIoD,KAAK,GAAI,QAAO;IACpBA,KAAK,IAAI,gBAAgB;IAEzB,MAAM4L,MAAM,GAAG,CACb;MACE+K,UAAU,EAAEJ,UAAU,CAACC;IACzB,CAAC,EACD;MACEI,cAAc,EAAEL,UAAU,CAACM,cAAc,IAAI;IAC/C,CAAC,EACD;MACEC,kBAAkB,EAAE,CAACP,UAAU,CAACE,kBAAkB;IACpD,CAAC,EACD;MACEM,mBAAmB,EAAE,CAACR,UAAU,CAACG,mBAAmB;IACtD,CAAC,CACF;;IAED;IACA,IAAIH,UAAU,CAACS,eAAe,EAAE;MAC9BpL,MAAM,CAACtP,IAAI,CAAC;QAAE2a,eAAe,EAAEV,UAAU,CAACS;MAAgB,CAAC,CAAC;IAC9D;IACA;IACA,IAAIT,UAAU,CAACW,SAAS,EAAE;MACxBtL,MAAM,CAACtP,IAAI,CAAC;QAAE6a,SAAS,EAAEZ,UAAU,CAACW;MAAU,CAAC,CAAC;IAClD;IAEA,MAAMlQ,OAAO,GAAG,IAAI7O,MAAM,CAAC8O,OAAO,CAAC;MACjC4E,QAAQ,EAAE,4BAA4B;MACtCC,UAAU,EAAE;QAAEC,MAAM,EAAE;MAAM,CAAC;MAC7B7E,QAAQ,EAAE;IACZ,CAAC,CAAC;IACF,MAAM9K,OAAO,GAAG4K,OAAO,CAACG,WAAW,CAACyE,MAAM,CAAC;IAE3C,IAAI,CAAC1O,WAAW,CAAC;MAAEN,MAAM;MAAEb,UAAU;MAAE2D,UAAU;MAAEM;IAAM,CAAC,EAAE5D,OAAO,EAAE,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,CAACkC,CAAC,EAAE2E,QAAQ,KAAK;MACrG,IAAI3E,CAAC,EAAE;QACL,OAAOpC,EAAE,CAACoC,CAAC,CAAC;MACd;MAEA,IAAI8Y,YAAY;MAChBtd,SAAS,CAACmJ,QAAQ,EAAElI,YAAY,CAACsc,8BAA8B,CAAC,CAAC,CAAC,CAC/DhZ,EAAE,CAAC,MAAM,EAAG+E,IAAI,IAAK;QACpBgU,YAAY,GAAGpc,gCAAgC,CAACoI,IAAI,CAAC;MACvD,CAAC,CAAC,CACD/E,EAAE,CAAC,OAAO,EAAEnC,EAAE,CAAC,CACfmC,EAAE,CAAC,KAAK,EAAE,MAAM;QACfnC,EAAE,CAAC,IAAI,EAAEkb,YAAY,CAAC;MACxB,CAAC,CAAC;IACN,CAAC,CAAC;EACJ;AACF;;AAEA;AACAnc,MAAM,CAACqc,SAAS,CAACxb,UAAU,GAAGlB,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACxb,UAAU,CAAC;AACpEb,MAAM,CAACqc,SAAS,CAAC9X,YAAY,GAAG5E,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC9X,YAAY,CAAC;AAExEvE,MAAM,CAACqc,SAAS,CAACjW,SAAS,GAAGzG,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACjW,SAAS,CAAC;AAClEpG,MAAM,CAACqc,SAAS,CAACpW,gBAAgB,GAAGtG,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACpW,gBAAgB,CAAC;AAChFjG,MAAM,CAACqc,SAAS,CAACrX,UAAU,GAAGrF,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACrX,UAAU,CAAC;AACpEhF,MAAM,CAACqc,SAAS,CAACzV,SAAS,GAAGjH,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACzV,SAAS,CAAC;AAClE5G,MAAM,CAACqc,SAAS,CAAC7V,UAAU,GAAG7G,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7V,UAAU,CAAC;AACpExG,MAAM,CAACqc,SAAS,CAAChT,UAAU,GAAG1J,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAChT,UAAU,CAAC;AACpErJ,MAAM,CAACqc,SAAS,CAACvR,aAAa,GAAGnL,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACvR,aAAa,CAAC;AAE1E9K,MAAM,CAACqc,SAAS,CAACvP,YAAY,GAAGnN,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACvP,YAAY,CAAC;AACxE9M,MAAM,CAACqc,SAAS,CAACvO,kBAAkB,GAAGnO,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACvO,kBAAkB,CAAC;AACpF9N,MAAM,CAACqc,SAAS,CAACnO,kBAAkB,GAAGvO,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACnO,kBAAkB,CAAC;AACpFlO,MAAM,CAACqc,SAAS,CAACjO,mBAAmB,GAAGzO,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACjO,mBAAmB,CAAC;AACtFpO,MAAM,CAACqc,SAAS,CAACrL,qBAAqB,GAAGrR,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACrL,qBAAqB,CAAC;AAC1FhR,MAAM,CAACqc,SAAS,CAAC3L,qBAAqB,GAAG/Q,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC3L,qBAAqB,CAAC;AAC1F1Q,MAAM,CAACqc,SAAS,CAACtL,2BAA2B,GAAGpR,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACtL,2BAA2B,CAAC;AACtG/Q,MAAM,CAACqc,SAAS,CAAC7P,eAAe,GAAG7M,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7P,eAAe,CAAC;AAC9ExM,MAAM,CAACqc,SAAS,CAACzP,eAAe,GAAGjN,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACzP,eAAe,CAAC;AAC9E5M,MAAM,CAACqc,SAAS,CAAC7X,sBAAsB,GAAG7E,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7X,sBAAsB,CAAC;AAC5FxE,MAAM,CAACqc,SAAS,CAAC7K,mBAAmB,GAAG7R,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7K,mBAAmB,CAAC;AACtFxR,MAAM,CAACqc,SAAS,CAAC1K,mBAAmB,GAAGhS,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC1K,mBAAmB,CAAC;AACtF3R,MAAM,CAACqc,SAAS,CAAC5J,gBAAgB,GAAG9S,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC5J,gBAAgB,CAAC;AAChFzS,MAAM,CAACqc,SAAS,CAACxJ,mBAAmB,GAAGlT,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACxJ,mBAAmB,CAAC;AACtF7S,MAAM,CAACqc,SAAS,CAACtJ,gBAAgB,GAAGpT,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACtJ,gBAAgB,CAAC;AAChF/S,MAAM,CAACqc,SAAS,CAAC3J,gBAAgB,GAAG/S,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC3J,gBAAgB,CAAC;AAChF1S,MAAM,CAACqc,SAAS,CAACvJ,mBAAmB,GAAGnT,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACvJ,mBAAmB,CAAC;AACtF9S,MAAM,CAACqc,SAAS,CAACpJ,gBAAgB,GAAGtT,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACpJ,gBAAgB,CAAC;AAChFjT,MAAM,CAACqc,SAAS,CAAChJ,kBAAkB,GAAG1T,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAChJ,kBAAkB,CAAC;AACpFrT,MAAM,CAACqc,SAAS,CAAC7I,kBAAkB,GAAG7T,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7I,kBAAkB,CAAC;AACpFxT,MAAM,CAACqc,SAAS,CAACjJ,qBAAqB,GAAGzT,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACjJ,qBAAqB,CAAC;AAC1FpT,MAAM,CAACqc,SAAS,CAAC1I,mBAAmB,GAAGhU,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC1I,mBAAmB,CAAC;AACtF3T,MAAM,CAACqc,SAAS,CAACtH,mBAAmB,GAAGpV,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACtH,mBAAmB,CAAC;AACtF/U,MAAM,CAACqc,SAAS,CAACnH,kBAAkB,GAAGvV,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACnH,kBAAkB,CAAC;AACpFlV,MAAM,CAACqc,SAAS,CAAC7G,kBAAkB,GAAG7V,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC7G,kBAAkB,CAAC;AACpFxV,MAAM,CAACqc,SAAS,CAAC1G,mBAAmB,GAAGhW,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC1G,mBAAmB,CAAC;AACtF3V,MAAM,CAACqc,SAAS,CAACrG,mBAAmB,GAAGrW,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACrG,mBAAmB,CAAC;AACtFhW,MAAM,CAACqc,SAAS,CAAClG,sBAAsB,GAAGxW,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAClG,sBAAsB,CAAC;AAC5FnW,MAAM,CAACqc,SAAS,CAAC9F,kBAAkB,GAAG5W,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAC9F,kBAAkB,CAAC;AACpFvW,MAAM,CAACqc,SAAS,CAACjG,kBAAkB,GAAGzW,SAAS,CAACK,MAAM,CAACqc,SAAS,CAACjG,kBAAkB,CAAC;AACpFpW,MAAM,CAACqc,SAAS,CAAChF,aAAa,GAAG1X,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAChF,aAAa,CAAC;AAC1ErX,MAAM,CAACqc,SAAS,CAAChB,mBAAmB,GAAG1b,SAAS,CAACK,MAAM,CAACqc,SAAS,CAAChB,mBAAmB,CAAC;;AAEtF;AACArb,MAAM,CAACqc,SAAS,CAACC,YAAY,GAAG/e,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACC,YAAY,CAAC;AAC1Etc,MAAM,CAACqc,SAAS,CAAC7W,UAAU,GAAGjI,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAAC7W,UAAU,CAAC;AACtExF,MAAM,CAACqc,SAAS,CAACE,YAAY,GAAGhf,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACE,YAAY,CAAC;AAC1Evc,MAAM,CAACqc,SAAS,CAACG,WAAW,GAAGjf,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACG,WAAW,CAAC;AACxExc,MAAM,CAACqc,SAAS,CAACI,uBAAuB,GAAGlf,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACI,uBAAuB,CAAC;AAChGzc,MAAM,CAACqc,SAAS,CAACK,oBAAoB,GAAGnf,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACK,oBAAoB,CAAC;AAC1F1c,MAAM,CAACqc,SAAS,CAACM,oBAAoB,GAAGpf,WAAW,CAACyC,MAAM,CAACqc,SAAS,CAACM,oBAAoB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}