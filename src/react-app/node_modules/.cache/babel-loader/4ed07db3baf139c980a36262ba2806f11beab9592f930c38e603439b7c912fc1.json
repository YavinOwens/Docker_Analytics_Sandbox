{"ast":null,"code":"/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as crypto from \"crypto\";\nimport * as stream from \"stream\";\nimport { XMLParser } from 'fast-xml-parser';\nimport ipaddr from 'ipaddr.js';\nimport _ from 'lodash';\nimport * as mime from 'mime-types';\nimport { ENCRYPTION_TYPES } from \"./type.mjs\";\nconst MetaDataHeaderPrefix = 'x-amz-meta-';\n\n/**\n * All characters in string which are NOT unreserved should be percent encoded.\n * Unreserved characters are : ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * Reference https://tools.ietf.org/html/rfc3986#section-2.2\n */\nexport function uriEscape(string) {\n  return string.split('').reduce((acc, elem) => {\n    const buf = Buffer.from(elem);\n    if (buf.length === 1) {\n      // length 1 indicates that elem is not a unicode character.\n      // Check if it is an unreserved characer.\n      if ('A' <= elem && elem <= 'Z' || 'a' <= elem && elem <= 'z' || '0' <= elem && elem <= '9' || elem === '_' || elem === '.' || elem === '~' || elem === '-') {\n        // Unreserved characer should not be encoded.\n        acc = acc + elem;\n        return acc;\n      }\n    }\n    // elem needs encoding - i.e elem should be encoded if it's not unreserved\n    // character or if it's a unicode character.\n    for (const char of buf) {\n      acc = acc + '%' + char.toString(16).toUpperCase();\n    }\n    return acc;\n  }, '');\n}\nexport function uriResourceEscape(string) {\n  return uriEscape(string).replace(/%2F/g, '/');\n}\nexport function getScope(region, date, serviceName = 's3') {\n  return `${makeDateShort(date)}/${region}/${serviceName}/aws4_request`;\n}\n\n/**\n * isAmazonEndpoint - true if endpoint is 's3.amazonaws.com' or 's3.cn-north-1.amazonaws.com.cn'\n */\nexport function isAmazonEndpoint(endpoint) {\n  return endpoint === 's3.amazonaws.com' || endpoint === 's3.cn-north-1.amazonaws.com.cn';\n}\n\n/**\n * isVirtualHostStyle - verify if bucket name is support with virtual\n * hosts. bucketNames with periods should be always treated as path\n * style if the protocol is 'https:', this is due to SSL wildcard\n * limitation. For all other buckets and Amazon S3 endpoint we will\n * default to virtual host style.\n */\nexport function isVirtualHostStyle(endpoint, protocol, bucket, pathStyle) {\n  if (protocol === 'https:' && bucket.includes('.')) {\n    return false;\n  }\n  return isAmazonEndpoint(endpoint) || !pathStyle;\n}\nexport function isValidIP(ip) {\n  return ipaddr.isValid(ip);\n}\n\n/**\n * @returns if endpoint is valid domain.\n */\nexport function isValidEndpoint(endpoint) {\n  return isValidDomain(endpoint) || isValidIP(endpoint);\n}\n\n/**\n * @returns if input host is a valid domain.\n */\nexport function isValidDomain(host) {\n  if (!isString(host)) {\n    return false;\n  }\n  // See RFC 1035, RFC 3696.\n  if (host.length === 0 || host.length > 255) {\n    return false;\n  }\n  // Host cannot start or end with a '-'\n  if (host[0] === '-' || host.slice(-1) === '-') {\n    return false;\n  }\n  // Host cannot start or end with a '_'\n  if (host[0] === '_' || host.slice(-1) === '_') {\n    return false;\n  }\n  // Host cannot start with a '.'\n  if (host[0] === '.') {\n    return false;\n  }\n  const alphaNumerics = '`~!@#$%^&*()+={}[]|\\\\\"\\';:><?/';\n  // All non alphanumeric characters are invalid.\n  for (const char of alphaNumerics) {\n    if (host.includes(char)) {\n      return false;\n    }\n  }\n  // No need to regexp match, since the list is non-exhaustive.\n  // We let it be valid and fail later.\n  return true;\n}\n\n/**\n * Probes contentType using file extensions.\n *\n * @example\n * ```\n * // return 'image/png'\n * probeContentType('file.png')\n * ```\n */\nexport function probeContentType(path) {\n  let contentType = mime.lookup(path);\n  if (!contentType) {\n    contentType = 'application/octet-stream';\n  }\n  return contentType;\n}\n\n/**\n * is input port valid.\n */\nexport function isValidPort(port) {\n  // verify if port is a number.\n  if (!isNumber(port)) {\n    return false;\n  }\n\n  // port `0` is valid and special case\n  return 0 <= port && port <= 65535;\n}\nexport function isValidBucketName(bucket) {\n  if (!isString(bucket)) {\n    return false;\n  }\n\n  // bucket length should be less than and no more than 63\n  // characters long.\n  if (bucket.length < 3 || bucket.length > 63) {\n    return false;\n  }\n  // bucket with successive periods is invalid.\n  if (bucket.includes('..')) {\n    return false;\n  }\n  // bucket cannot have ip address style.\n  if (/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/.test(bucket)) {\n    return false;\n  }\n  // bucket should begin with alphabet/number and end with alphabet/number,\n  // with alphabet/number/.- in the middle.\n  if (/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(bucket)) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * check if objectName is a valid object name\n */\nexport function isValidObjectName(objectName) {\n  if (!isValidPrefix(objectName)) {\n    return false;\n  }\n  return objectName.length !== 0;\n}\n\n/**\n * check if prefix is valid\n */\nexport function isValidPrefix(prefix) {\n  if (!isString(prefix)) {\n    return false;\n  }\n  if (prefix.length > 1024) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * check if typeof arg number\n */\nexport function isNumber(arg) {\n  return typeof arg === 'number';\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * check if typeof arg function\n */\nexport function isFunction(arg) {\n  return typeof arg === 'function';\n}\n\n/**\n * check if typeof arg string\n */\nexport function isString(arg) {\n  return typeof arg === 'string';\n}\n\n/**\n * check if typeof arg object\n */\nexport function isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\n/**\n * check if object is readable stream\n */\nexport function isReadableStream(arg) {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  return isObject(arg) && isFunction(arg._read);\n}\n\n/**\n * check if arg is boolean\n */\nexport function isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexport function isEmpty(o) {\n  return _.isEmpty(o);\n}\nexport function isEmptyObject(o) {\n  return Object.values(o).filter(x => x !== undefined).length !== 0;\n}\nexport function isDefined(o) {\n  return o !== null && o !== undefined;\n}\n\n/**\n * check if arg is a valid date\n */\nexport function isValidDate(arg) {\n  // @ts-expect-error checknew Date(Math.NaN)\n  return arg instanceof Date && !isNaN(arg);\n}\n\n/**\n * Create a Date string with format: 'YYYYMMDDTHHmmss' + Z\n */\nexport function makeDateLong(date) {\n  date = date || new Date();\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  const s = date.toISOString();\n  return s.slice(0, 4) + s.slice(5, 7) + s.slice(8, 13) + s.slice(14, 16) + s.slice(17, 19) + 'Z';\n}\n\n/**\n * Create a Date string with format: 'YYYYMMDD'\n */\nexport function makeDateShort(date) {\n  date = date || new Date();\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  const s = date.toISOString();\n  return s.slice(0, 4) + s.slice(5, 7) + s.slice(8, 10);\n}\n\n/**\n * pipesetup sets up pipe() from left to right os streams array\n * pipesetup will also make sure that error emitted at any of the upstream Stream\n * will be emitted at the last stream. This makes error handling simple\n */\nexport function pipesetup(...streams) {\n  // @ts-expect-error ts can't narrow this\n  return streams.reduce((src, dst) => {\n    src.on('error', err => dst.emit('error', err));\n    return src.pipe(dst);\n  });\n}\n\n/**\n * return a Readable stream that emits data\n */\nexport function readableStream(data) {\n  const s = new stream.Readable();\n  s._read = () => {};\n  s.push(data);\n  s.push(null);\n  return s;\n}\n\n/**\n * Process metadata to insert appropriate value to `content-type` attribute\n */\nexport function insertContentType(metaData, filePath) {\n  // check if content-type attribute present in metaData\n  for (const key in metaData) {\n    if (key.toLowerCase() === 'content-type') {\n      return metaData;\n    }\n  }\n\n  // if `content-type` attribute is not present in metadata, then infer it from the extension in filePath\n  return {\n    ...metaData,\n    'content-type': probeContentType(filePath)\n  };\n}\n\n/**\n * Function prepends metadata with the appropriate prefix if it is not already on\n */\nexport function prependXAMZMeta(metaData) {\n  if (!metaData) {\n    return {};\n  }\n  return _.mapKeys(metaData, (value, key) => {\n    if (isAmzHeader(key) || isSupportedHeader(key) || isStorageClassHeader(key)) {\n      return key;\n    }\n    return MetaDataHeaderPrefix + key;\n  });\n}\n\n/**\n * Checks if it is a valid header according to the AmazonS3 API\n */\nexport function isAmzHeader(key) {\n  const temp = key.toLowerCase();\n  return temp.startsWith(MetaDataHeaderPrefix) || temp === 'x-amz-acl' || temp.startsWith('x-amz-server-side-encryption-') || temp === 'x-amz-server-side-encryption';\n}\n\n/**\n * Checks if it is a supported Header\n */\nexport function isSupportedHeader(key) {\n  const supported_headers = ['content-type', 'cache-control', 'content-encoding', 'content-disposition', 'content-language', 'x-amz-website-redirect-location'];\n  return supported_headers.includes(key.toLowerCase());\n}\n\n/**\n * Checks if it is a storage header\n */\nexport function isStorageClassHeader(key) {\n  return key.toLowerCase() === 'x-amz-storage-class';\n}\nexport function extractMetadata(headers) {\n  return _.mapKeys(_.pickBy(headers, (value, key) => isSupportedHeader(key) || isStorageClassHeader(key) || isAmzHeader(key)), (value, key) => {\n    const lower = key.toLowerCase();\n    if (lower.startsWith(MetaDataHeaderPrefix)) {\n      return lower.slice(MetaDataHeaderPrefix.length);\n    }\n    return key;\n  });\n}\nexport function getVersionId(headers = {}) {\n  return headers['x-amz-version-id'] || null;\n}\nexport function getSourceVersionId(headers = {}) {\n  return headers['x-amz-copy-source-version-id'] || null;\n}\nexport function sanitizeETag(etag = '') {\n  const replaceChars = {\n    '\"': '',\n    '&quot;': '',\n    '&#34;': '',\n    '&QUOT;': '',\n    '&#x00022': ''\n  };\n  return etag.replace(/^(\"|&quot;|&#34;)|(\"|&quot;|&#34;)$/g, m => replaceChars[m]);\n}\nexport function toMd5(payload) {\n  // use string from browser and buffer from nodejs\n  // browser support is tested only against minio server\n  return crypto.createHash('md5').update(Buffer.from(payload)).digest().toString('base64');\n}\nexport function toSha256(payload) {\n  return crypto.createHash('sha256').update(payload).digest('hex');\n}\n\n/**\n * toArray returns a single element array with param being the element,\n * if param is just a string, and returns 'param' back if it is an array\n * So, it makes sure param is always an array\n */\nexport function toArray(param) {\n  if (!Array.isArray(param)) {\n    return [param];\n  }\n  return param;\n}\nexport function sanitizeObjectKey(objectName) {\n  // + symbol characters are not decoded as spaces in JS. so replace them first and decode to get the correct result.\n  const asStrName = (objectName ? objectName.toString() : '').replace(/\\+/g, ' ');\n  return decodeURIComponent(asStrName);\n}\nexport function sanitizeSize(size) {\n  return size ? Number.parseInt(size) : undefined;\n}\nexport const PART_CONSTRAINTS = {\n  // absMinPartSize - absolute minimum part size (5 MiB)\n  ABS_MIN_PART_SIZE: 1024 * 1024 * 5,\n  // MIN_PART_SIZE - minimum part size 16MiB per object after which\n  MIN_PART_SIZE: 1024 * 1024 * 16,\n  // MAX_PARTS_COUNT - maximum number of parts for a single multipart session.\n  MAX_PARTS_COUNT: 10000,\n  // MAX_PART_SIZE - maximum part size 5GiB for a single multipart upload\n  // operation.\n  MAX_PART_SIZE: 1024 * 1024 * 1024 * 5,\n  // MAX_SINGLE_PUT_OBJECT_SIZE - maximum size 5GiB of object per PUT\n  // operation.\n  MAX_SINGLE_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 5,\n  // MAX_MULTIPART_PUT_OBJECT_SIZE - maximum size 5TiB of object for\n  // Multipart operation.\n  MAX_MULTIPART_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 1024 * 5\n};\nconst GENERIC_SSE_HEADER = 'X-Amz-Server-Side-Encryption';\nconst ENCRYPTION_HEADERS = {\n  // sseGenericHeader is the AWS SSE header used for SSE-S3 and SSE-KMS.\n  sseGenericHeader: GENERIC_SSE_HEADER,\n  // sseKmsKeyID is the AWS SSE-KMS key id.\n  sseKmsKeyID: GENERIC_SSE_HEADER + '-Aws-Kms-Key-Id'\n};\n\n/**\n * Return Encryption headers\n * @param encConfig\n * @returns an object with key value pairs that can be used in headers.\n */\nexport function getEncryptionHeaders(encConfig) {\n  const encType = encConfig.type;\n  if (!isEmpty(encType)) {\n    if (encType === ENCRYPTION_TYPES.SSEC) {\n      return {\n        [ENCRYPTION_HEADERS.sseGenericHeader]: 'AES256'\n      };\n    } else if (encType === ENCRYPTION_TYPES.KMS) {\n      return {\n        [ENCRYPTION_HEADERS.sseGenericHeader]: encConfig.SSEAlgorithm,\n        [ENCRYPTION_HEADERS.sseKmsKeyID]: encConfig.KMSMasterKeyID\n      };\n    }\n  }\n  return {};\n}\nexport function partsRequired(size) {\n  const maxPartSize = PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE / (PART_CONSTRAINTS.MAX_PARTS_COUNT - 1);\n  let requiredPartSize = size / maxPartSize;\n  if (size % maxPartSize > 0) {\n    requiredPartSize++;\n  }\n  requiredPartSize = Math.trunc(requiredPartSize);\n  return requiredPartSize;\n}\n\n/**\n * calculateEvenSplits - computes splits for a source and returns\n * start and end index slices. Splits happen evenly to be sure that no\n * part is less than 5MiB, as that could fail the multipart request if\n * it is not the last part.\n */\nexport function calculateEvenSplits(size, objInfo) {\n  if (size === 0) {\n    return null;\n  }\n  const reqParts = partsRequired(size);\n  const startIndexParts = [];\n  const endIndexParts = [];\n  let start = objInfo.Start;\n  if (isEmpty(start) || start === -1) {\n    start = 0;\n  }\n  const divisorValue = Math.trunc(size / reqParts);\n  const reminderValue = size % reqParts;\n  let nextStart = start;\n  for (let i = 0; i < reqParts; i++) {\n    let curPartSize = divisorValue;\n    if (i < reminderValue) {\n      curPartSize++;\n    }\n    const currentStart = nextStart;\n    const currentEnd = currentStart + curPartSize - 1;\n    nextStart = currentEnd + 1;\n    startIndexParts.push(currentStart);\n    endIndexParts.push(currentEnd);\n  }\n  return {\n    startIndex: startIndexParts,\n    endIndex: endIndexParts,\n    objInfo: objInfo\n  };\n}\nconst fxp = new XMLParser();\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parseXml(xml) {\n  const result = fxp.parse(xml);\n  if (result.Error) {\n    throw result.Error;\n  }\n  return result;\n}","map":{"version":3,"names":["crypto","stream","XMLParser","ipaddr","_","mime","ENCRYPTION_TYPES","MetaDataHeaderPrefix","uriEscape","string","split","reduce","acc","elem","buf","Buffer","from","length","char","toString","toUpperCase","uriResourceEscape","replace","getScope","region","date","serviceName","makeDateShort","isAmazonEndpoint","endpoint","isVirtualHostStyle","protocol","bucket","pathStyle","includes","isValidIP","ip","isValid","isValidEndpoint","isValidDomain","host","isString","slice","alphaNumerics","probeContentType","path","contentType","lookup","isValidPort","port","isNumber","isValidBucketName","test","isValidObjectName","objectName","isValidPrefix","prefix","arg","isFunction","isObject","isReadableStream","_read","isBoolean","isEmpty","o","isEmptyObject","Object","values","filter","x","undefined","isDefined","isValidDate","Date","isNaN","makeDateLong","s","toISOString","pipesetup","streams","src","dst","on","err","emit","pipe","readableStream","data","Readable","push","insertContentType","metaData","filePath","key","toLowerCase","prependXAMZMeta","mapKeys","value","isAmzHeader","isSupportedHeader","isStorageClassHeader","temp","startsWith","supported_headers","extractMetadata","headers","pickBy","lower","getVersionId","getSourceVersionId","sanitizeETag","etag","replaceChars","m","toMd5","payload","createHash","update","digest","toSha256","toArray","param","Array","isArray","sanitizeObjectKey","asStrName","decodeURIComponent","sanitizeSize","size","Number","parseInt","PART_CONSTRAINTS","ABS_MIN_PART_SIZE","MIN_PART_SIZE","MAX_PARTS_COUNT","MAX_PART_SIZE","MAX_SINGLE_PUT_OBJECT_SIZE","MAX_MULTIPART_PUT_OBJECT_SIZE","GENERIC_SSE_HEADER","ENCRYPTION_HEADERS","sseGenericHeader","sseKmsKeyID","getEncryptionHeaders","encConfig","encType","type","SSEC","KMS","SSEAlgorithm","KMSMasterKeyID","partsRequired","maxPartSize","requiredPartSize","Math","trunc","calculateEvenSplits","objInfo","reqParts","startIndexParts","endIndexParts","start","Start","divisorValue","reminderValue","nextStart","i","curPartSize","currentStart","currentEnd","startIndex","endIndex","fxp","parseXml","xml","result","parse","Error"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/internal/helper.ts"],"sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as crypto from 'node:crypto'\nimport * as stream from 'node:stream'\n\nimport { XMLParser } from 'fast-xml-parser'\nimport ipaddr from 'ipaddr.js'\nimport _ from 'lodash'\nimport * as mime from 'mime-types'\n\nimport type { Binary, Encryption, ObjectMetaData, RequestHeaders, ResponseHeader } from './type.ts'\nimport { ENCRYPTION_TYPES } from './type.ts'\n\nconst MetaDataHeaderPrefix = 'x-amz-meta-'\n\n/**\n * All characters in string which are NOT unreserved should be percent encoded.\n * Unreserved characters are : ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * Reference https://tools.ietf.org/html/rfc3986#section-2.2\n */\nexport function uriEscape(string: string) {\n  return string.split('').reduce((acc: string, elem: string) => {\n    const buf = Buffer.from(elem)\n    if (buf.length === 1) {\n      // length 1 indicates that elem is not a unicode character.\n      // Check if it is an unreserved characer.\n      if (\n        ('A' <= elem && elem <= 'Z') ||\n        ('a' <= elem && elem <= 'z') ||\n        ('0' <= elem && elem <= '9') ||\n        elem === '_' ||\n        elem === '.' ||\n        elem === '~' ||\n        elem === '-'\n      ) {\n        // Unreserved characer should not be encoded.\n        acc = acc + elem\n        return acc\n      }\n    }\n    // elem needs encoding - i.e elem should be encoded if it's not unreserved\n    // character or if it's a unicode character.\n    for (const char of buf) {\n      acc = acc + '%' + char.toString(16).toUpperCase()\n    }\n    return acc\n  }, '')\n}\n\nexport function uriResourceEscape(string: string) {\n  return uriEscape(string).replace(/%2F/g, '/')\n}\n\nexport function getScope(region: string, date: Date, serviceName = 's3') {\n  return `${makeDateShort(date)}/${region}/${serviceName}/aws4_request`\n}\n\n/**\n * isAmazonEndpoint - true if endpoint is 's3.amazonaws.com' or 's3.cn-north-1.amazonaws.com.cn'\n */\nexport function isAmazonEndpoint(endpoint: string) {\n  return endpoint === 's3.amazonaws.com' || endpoint === 's3.cn-north-1.amazonaws.com.cn'\n}\n\n/**\n * isVirtualHostStyle - verify if bucket name is support with virtual\n * hosts. bucketNames with periods should be always treated as path\n * style if the protocol is 'https:', this is due to SSL wildcard\n * limitation. For all other buckets and Amazon S3 endpoint we will\n * default to virtual host style.\n */\nexport function isVirtualHostStyle(endpoint: string, protocol: string, bucket: string, pathStyle: boolean) {\n  if (protocol === 'https:' && bucket.includes('.')) {\n    return false\n  }\n  return isAmazonEndpoint(endpoint) || !pathStyle\n}\n\nexport function isValidIP(ip: string) {\n  return ipaddr.isValid(ip)\n}\n\n/**\n * @returns if endpoint is valid domain.\n */\nexport function isValidEndpoint(endpoint: string) {\n  return isValidDomain(endpoint) || isValidIP(endpoint)\n}\n\n/**\n * @returns if input host is a valid domain.\n */\nexport function isValidDomain(host: string) {\n  if (!isString(host)) {\n    return false\n  }\n  // See RFC 1035, RFC 3696.\n  if (host.length === 0 || host.length > 255) {\n    return false\n  }\n  // Host cannot start or end with a '-'\n  if (host[0] === '-' || host.slice(-1) === '-') {\n    return false\n  }\n  // Host cannot start or end with a '_'\n  if (host[0] === '_' || host.slice(-1) === '_') {\n    return false\n  }\n  // Host cannot start with a '.'\n  if (host[0] === '.') {\n    return false\n  }\n\n  const alphaNumerics = '`~!@#$%^&*()+={}[]|\\\\\"\\';:><?/'\n  // All non alphanumeric characters are invalid.\n  for (const char of alphaNumerics) {\n    if (host.includes(char)) {\n      return false\n    }\n  }\n  // No need to regexp match, since the list is non-exhaustive.\n  // We let it be valid and fail later.\n  return true\n}\n\n/**\n * Probes contentType using file extensions.\n *\n * @example\n * ```\n * // return 'image/png'\n * probeContentType('file.png')\n * ```\n */\nexport function probeContentType(path: string) {\n  let contentType = mime.lookup(path)\n  if (!contentType) {\n    contentType = 'application/octet-stream'\n  }\n  return contentType\n}\n\n/**\n * is input port valid.\n */\nexport function isValidPort(port: unknown): port is number {\n  // verify if port is a number.\n  if (!isNumber(port)) {\n    return false\n  }\n\n  // port `0` is valid and special case\n  return 0 <= port && port <= 65535\n}\n\nexport function isValidBucketName(bucket: unknown) {\n  if (!isString(bucket)) {\n    return false\n  }\n\n  // bucket length should be less than and no more than 63\n  // characters long.\n  if (bucket.length < 3 || bucket.length > 63) {\n    return false\n  }\n  // bucket with successive periods is invalid.\n  if (bucket.includes('..')) {\n    return false\n  }\n  // bucket cannot have ip address style.\n  if (/[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+/.test(bucket)) {\n    return false\n  }\n  // bucket should begin with alphabet/number and end with alphabet/number,\n  // with alphabet/number/.- in the middle.\n  if (/^[a-z0-9][a-z0-9.-]+[a-z0-9]$/.test(bucket)) {\n    return true\n  }\n  return false\n}\n\n/**\n * check if objectName is a valid object name\n */\nexport function isValidObjectName(objectName: unknown) {\n  if (!isValidPrefix(objectName)) {\n    return false\n  }\n\n  return objectName.length !== 0\n}\n\n/**\n * check if prefix is valid\n */\nexport function isValidPrefix(prefix: unknown): prefix is string {\n  if (!isString(prefix)) {\n    return false\n  }\n  if (prefix.length > 1024) {\n    return false\n  }\n  return true\n}\n\n/**\n * check if typeof arg number\n */\nexport function isNumber(arg: unknown): arg is number {\n  return typeof arg === 'number'\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyFunction = (...args: any[]) => any\n\n/**\n * check if typeof arg function\n */\nexport function isFunction(arg: unknown): arg is AnyFunction {\n  return typeof arg === 'function'\n}\n\n/**\n * check if typeof arg string\n */\nexport function isString(arg: unknown): arg is string {\n  return typeof arg === 'string'\n}\n\n/**\n * check if typeof arg object\n */\nexport function isObject(arg: unknown): arg is object {\n  return typeof arg === 'object' && arg !== null\n}\n\n/**\n * check if object is readable stream\n */\nexport function isReadableStream(arg: unknown): arg is stream.Readable {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  return isObject(arg) && isFunction((arg as stream.Readable)._read)\n}\n\n/**\n * check if arg is boolean\n */\nexport function isBoolean(arg: unknown): arg is boolean {\n  return typeof arg === 'boolean'\n}\n\nexport function isEmpty(o: unknown): o is null | undefined {\n  return _.isEmpty(o)\n}\n\nexport function isEmptyObject(o: Record<string, unknown>): boolean {\n  return Object.values(o).filter((x) => x !== undefined).length !== 0\n}\n\nexport function isDefined<T>(o: T): o is Exclude<T, null | undefined> {\n  return o !== null && o !== undefined\n}\n\n/**\n * check if arg is a valid date\n */\nexport function isValidDate(arg: unknown): arg is Date {\n  // @ts-expect-error checknew Date(Math.NaN)\n  return arg instanceof Date && !isNaN(arg)\n}\n\n/**\n * Create a Date string with format: 'YYYYMMDDTHHmmss' + Z\n */\nexport function makeDateLong(date?: Date): string {\n  date = date || new Date()\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  const s = date.toISOString()\n\n  return s.slice(0, 4) + s.slice(5, 7) + s.slice(8, 13) + s.slice(14, 16) + s.slice(17, 19) + 'Z'\n}\n\n/**\n * Create a Date string with format: 'YYYYMMDD'\n */\nexport function makeDateShort(date?: Date) {\n  date = date || new Date()\n\n  // Gives format like: '2017-08-07T16:28:59.889Z'\n  const s = date.toISOString()\n\n  return s.slice(0, 4) + s.slice(5, 7) + s.slice(8, 10)\n}\n\n/**\n * pipesetup sets up pipe() from left to right os streams array\n * pipesetup will also make sure that error emitted at any of the upstream Stream\n * will be emitted at the last stream. This makes error handling simple\n */\nexport function pipesetup(...streams: [stream.Readable, ...stream.Duplex[], stream.Writable]) {\n  // @ts-expect-error ts can't narrow this\n  return streams.reduce((src: stream.Readable, dst: stream.Writable) => {\n    src.on('error', (err) => dst.emit('error', err))\n    return src.pipe(dst)\n  })\n}\n\n/**\n * return a Readable stream that emits data\n */\nexport function readableStream(data: unknown): stream.Readable {\n  const s = new stream.Readable()\n  s._read = () => {}\n  s.push(data)\n  s.push(null)\n  return s\n}\n\n/**\n * Process metadata to insert appropriate value to `content-type` attribute\n */\nexport function insertContentType(metaData: ObjectMetaData, filePath: string): ObjectMetaData {\n  // check if content-type attribute present in metaData\n  for (const key in metaData) {\n    if (key.toLowerCase() === 'content-type') {\n      return metaData\n    }\n  }\n\n  // if `content-type` attribute is not present in metadata, then infer it from the extension in filePath\n  return {\n    ...metaData,\n    'content-type': probeContentType(filePath),\n  }\n}\n\n/**\n * Function prepends metadata with the appropriate prefix if it is not already on\n */\nexport function prependXAMZMeta(metaData?: ObjectMetaData): RequestHeaders {\n  if (!metaData) {\n    return {}\n  }\n\n  return _.mapKeys(metaData, (value, key) => {\n    if (isAmzHeader(key) || isSupportedHeader(key) || isStorageClassHeader(key)) {\n      return key\n    }\n\n    return MetaDataHeaderPrefix + key\n  })\n}\n\n/**\n * Checks if it is a valid header according to the AmazonS3 API\n */\nexport function isAmzHeader(key: string) {\n  const temp = key.toLowerCase()\n  return (\n    temp.startsWith(MetaDataHeaderPrefix) ||\n    temp === 'x-amz-acl' ||\n    temp.startsWith('x-amz-server-side-encryption-') ||\n    temp === 'x-amz-server-side-encryption'\n  )\n}\n\n/**\n * Checks if it is a supported Header\n */\nexport function isSupportedHeader(key: string) {\n  const supported_headers = [\n    'content-type',\n    'cache-control',\n    'content-encoding',\n    'content-disposition',\n    'content-language',\n    'x-amz-website-redirect-location',\n  ]\n  return supported_headers.includes(key.toLowerCase())\n}\n\n/**\n * Checks if it is a storage header\n */\nexport function isStorageClassHeader(key: string) {\n  return key.toLowerCase() === 'x-amz-storage-class'\n}\n\nexport function extractMetadata(headers: ResponseHeader) {\n  return _.mapKeys(\n    _.pickBy(headers, (value, key) => isSupportedHeader(key) || isStorageClassHeader(key) || isAmzHeader(key)),\n    (value, key) => {\n      const lower = key.toLowerCase()\n      if (lower.startsWith(MetaDataHeaderPrefix)) {\n        return lower.slice(MetaDataHeaderPrefix.length)\n      }\n\n      return key\n    },\n  )\n}\n\nexport function getVersionId(headers: ResponseHeader = {}) {\n  return headers['x-amz-version-id'] || null\n}\n\nexport function getSourceVersionId(headers: ResponseHeader = {}) {\n  return headers['x-amz-copy-source-version-id'] || null\n}\n\nexport function sanitizeETag(etag = ''): string {\n  const replaceChars: Record<string, string> = {\n    '\"': '',\n    '&quot;': '',\n    '&#34;': '',\n    '&QUOT;': '',\n    '&#x00022': '',\n  }\n  return etag.replace(/^(\"|&quot;|&#34;)|(\"|&quot;|&#34;)$/g, (m) => replaceChars[m] as string)\n}\n\nexport function toMd5(payload: Binary): string {\n  // use string from browser and buffer from nodejs\n  // browser support is tested only against minio server\n  return crypto.createHash('md5').update(Buffer.from(payload)).digest().toString('base64')\n}\n\nexport function toSha256(payload: Binary): string {\n  return crypto.createHash('sha256').update(payload).digest('hex')\n}\n\n/**\n * toArray returns a single element array with param being the element,\n * if param is just a string, and returns 'param' back if it is an array\n * So, it makes sure param is always an array\n */\nexport function toArray<T = unknown>(param: T | T[]): Array<T> {\n  if (!Array.isArray(param)) {\n    return [param] as T[]\n  }\n  return param\n}\n\nexport function sanitizeObjectKey(objectName: string): string {\n  // + symbol characters are not decoded as spaces in JS. so replace them first and decode to get the correct result.\n  const asStrName = (objectName ? objectName.toString() : '').replace(/\\+/g, ' ')\n  return decodeURIComponent(asStrName)\n}\n\nexport function sanitizeSize(size?: string): number | undefined {\n  return size ? Number.parseInt(size) : undefined\n}\n\nexport const PART_CONSTRAINTS = {\n  // absMinPartSize - absolute minimum part size (5 MiB)\n  ABS_MIN_PART_SIZE: 1024 * 1024 * 5,\n  // MIN_PART_SIZE - minimum part size 16MiB per object after which\n  MIN_PART_SIZE: 1024 * 1024 * 16,\n  // MAX_PARTS_COUNT - maximum number of parts for a single multipart session.\n  MAX_PARTS_COUNT: 10000,\n  // MAX_PART_SIZE - maximum part size 5GiB for a single multipart upload\n  // operation.\n  MAX_PART_SIZE: 1024 * 1024 * 1024 * 5,\n  // MAX_SINGLE_PUT_OBJECT_SIZE - maximum size 5GiB of object per PUT\n  // operation.\n  MAX_SINGLE_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 5,\n  // MAX_MULTIPART_PUT_OBJECT_SIZE - maximum size 5TiB of object for\n  // Multipart operation.\n  MAX_MULTIPART_PUT_OBJECT_SIZE: 1024 * 1024 * 1024 * 1024 * 5,\n}\n\nconst GENERIC_SSE_HEADER = 'X-Amz-Server-Side-Encryption'\n\nconst ENCRYPTION_HEADERS = {\n  // sseGenericHeader is the AWS SSE header used for SSE-S3 and SSE-KMS.\n  sseGenericHeader: GENERIC_SSE_HEADER,\n  // sseKmsKeyID is the AWS SSE-KMS key id.\n  sseKmsKeyID: GENERIC_SSE_HEADER + '-Aws-Kms-Key-Id',\n} as const\n\n/**\n * Return Encryption headers\n * @param encConfig\n * @returns an object with key value pairs that can be used in headers.\n */\nexport function getEncryptionHeaders(encConfig: Encryption): RequestHeaders {\n  const encType = encConfig.type\n\n  if (!isEmpty(encType)) {\n    if (encType === ENCRYPTION_TYPES.SSEC) {\n      return {\n        [ENCRYPTION_HEADERS.sseGenericHeader]: 'AES256',\n      }\n    } else if (encType === ENCRYPTION_TYPES.KMS) {\n      return {\n        [ENCRYPTION_HEADERS.sseGenericHeader]: encConfig.SSEAlgorithm,\n        [ENCRYPTION_HEADERS.sseKmsKeyID]: encConfig.KMSMasterKeyID,\n      }\n    }\n  }\n\n  return {}\n}\n\nexport function partsRequired(size: number): number {\n  const maxPartSize = PART_CONSTRAINTS.MAX_MULTIPART_PUT_OBJECT_SIZE / (PART_CONSTRAINTS.MAX_PARTS_COUNT - 1)\n  let requiredPartSize = size / maxPartSize\n  if (size % maxPartSize > 0) {\n    requiredPartSize++\n  }\n  requiredPartSize = Math.trunc(requiredPartSize)\n  return requiredPartSize\n}\n\n/**\n * calculateEvenSplits - computes splits for a source and returns\n * start and end index slices. Splits happen evenly to be sure that no\n * part is less than 5MiB, as that could fail the multipart request if\n * it is not the last part.\n */\nexport function calculateEvenSplits<T extends { Start?: number }>(\n  size: number,\n  objInfo: T,\n): {\n  startIndex: number[]\n  objInfo: T\n  endIndex: number[]\n} | null {\n  if (size === 0) {\n    return null\n  }\n  const reqParts = partsRequired(size)\n  const startIndexParts: number[] = []\n  const endIndexParts: number[] = []\n\n  let start = objInfo.Start\n  if (isEmpty(start) || start === -1) {\n    start = 0\n  }\n  const divisorValue = Math.trunc(size / reqParts)\n\n  const reminderValue = size % reqParts\n\n  let nextStart = start\n\n  for (let i = 0; i < reqParts; i++) {\n    let curPartSize = divisorValue\n    if (i < reminderValue) {\n      curPartSize++\n    }\n\n    const currentStart = nextStart\n    const currentEnd = currentStart + curPartSize - 1\n    nextStart = currentEnd + 1\n\n    startIndexParts.push(currentStart)\n    endIndexParts.push(currentEnd)\n  }\n\n  return { startIndex: startIndexParts, endIndex: endIndexParts, objInfo: objInfo }\n}\n\nconst fxp = new XMLParser()\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parseXml(xml: string): any {\n  const result = fxp.parse(xml)\n  if (result.Error) {\n    throw result.Error\n  }\n\n  return result\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}