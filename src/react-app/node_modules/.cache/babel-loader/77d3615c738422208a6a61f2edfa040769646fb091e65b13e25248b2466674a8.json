{"ast":null,"code":"/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as stream from \"stream\";\nimport * as errors from \"../errors.mjs\";\nimport { isBoolean, isString, isValidBucketName, isValidPrefix, uriEscape } from \"./helper.mjs\";\nimport { readAsString } from \"./response.mjs\";\nimport { parseListObjectsV2WithMetadata } from \"./xml-parser.mjs\";\nexport class Extensions {\n  constructor(client) {\n    this.client = client;\n  }\n\n  /**\n   * List the objects in the bucket using S3 ListObjects V2 With Metadata\n   *\n   * @param bucketName - name of the bucket\n   * @param prefix - the prefix of the objects that should be listed (optional, default `''`)\n   * @param recursive - `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n   * @param startAfter - Specifies the key to start after when listing objects in a bucket. (optional, default `''`)\n   * @returns stream emitting the objects in the bucket, the object is of the format:\n   */\n  listObjectsV2WithMetadata(bucketName, prefix, recursive, startAfter) {\n    if (prefix === undefined) {\n      prefix = '';\n    }\n    if (recursive === undefined) {\n      recursive = false;\n    }\n    if (startAfter === undefined) {\n      startAfter = '';\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`);\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"');\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"');\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"');\n    }\n\n    // if recursive is false set delimiter to '/'\n    const delimiter = recursive ? '' : '/';\n    return stream.Readable.from(this.listObjectsV2WithMetadataGen(bucketName, prefix, delimiter, startAfter), {\n      objectMode: true\n    });\n  }\n  async *listObjectsV2WithMetadataGen(bucketName, prefix, delimiter, startAfter) {\n    let ended = false;\n    let continuationToken = '';\n    do {\n      const result = await this.listObjectsV2WithMetadataQuery(bucketName, prefix, continuationToken, delimiter, startAfter);\n      ended = !result.isTruncated;\n      continuationToken = result.nextContinuationToken;\n      for (const obj of result.objects) {\n        yield obj;\n      }\n    } while (!ended);\n  }\n  async listObjectsV2WithMetadataQuery(bucketName, prefix, continuationToken, delimiter, startAfter) {\n    const queries = [];\n\n    // Call for listing objects v2 API\n    queries.push(`list-type=2`);\n    queries.push(`encoding-type=url`);\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`);\n    queries.push(`delimiter=${uriEscape(delimiter)}`);\n    queries.push(`metadata=true`);\n    if (continuationToken) {\n      continuationToken = uriEscape(continuationToken);\n      queries.push(`continuation-token=${continuationToken}`);\n    }\n    // Set start-after\n    if (startAfter) {\n      startAfter = uriEscape(startAfter);\n      queries.push(`start-after=${startAfter}`);\n    }\n    queries.push(`max-keys=1000`);\n    queries.sort();\n    let query = '';\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`;\n    }\n    const method = 'GET';\n    const res = await this.client.makeRequestAsync({\n      method,\n      bucketName,\n      query\n    });\n    return parseListObjectsV2WithMetadata(await readAsString(res));\n  }\n}","map":{"version":3,"names":["stream","errors","isBoolean","isString","isValidBucketName","isValidPrefix","uriEscape","readAsString","parseListObjectsV2WithMetadata","Extensions","constructor","client","listObjectsV2WithMetadata","bucketName","prefix","recursive","startAfter","undefined","InvalidBucketNameError","InvalidPrefixError","TypeError","delimiter","Readable","from","listObjectsV2WithMetadataGen","objectMode","ended","continuationToken","result","listObjectsV2WithMetadataQuery","isTruncated","nextContinuationToken","obj","objects","queries","push","sort","query","length","join","method","res","makeRequestAsync"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/internal/extensions.ts"],"sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2020 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as stream from 'node:stream'\n\nimport * as errors from '../errors.ts'\nimport type { TypedClient } from './client.ts'\nimport { isBoolean, isString, isValidBucketName, isValidPrefix, uriEscape } from './helper.ts'\nimport { readAsString } from './response.ts'\nimport type { BucketItemWithMetadata, BucketStream } from './type.ts'\nimport { parseListObjectsV2WithMetadata } from './xml-parser.ts'\n\nexport class Extensions {\n  constructor(private readonly client: TypedClient) {}\n\n  /**\n   * List the objects in the bucket using S3 ListObjects V2 With Metadata\n   *\n   * @param bucketName - name of the bucket\n   * @param prefix - the prefix of the objects that should be listed (optional, default `''`)\n   * @param recursive - `true` indicates recursive style listing and `false` indicates directory style listing delimited by '/'. (optional, default `false`)\n   * @param startAfter - Specifies the key to start after when listing objects in a bucket. (optional, default `''`)\n   * @returns stream emitting the objects in the bucket, the object is of the format:\n   */\n  public listObjectsV2WithMetadata(\n    bucketName: string,\n    prefix?: string,\n    recursive?: boolean,\n    startAfter?: string,\n  ): BucketStream<BucketItemWithMetadata> {\n    if (prefix === undefined) {\n      prefix = ''\n    }\n    if (recursive === undefined) {\n      recursive = false\n    }\n    if (startAfter === undefined) {\n      startAfter = ''\n    }\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidPrefix(prefix)) {\n      throw new errors.InvalidPrefixError(`Invalid prefix : ${prefix}`)\n    }\n    if (!isString(prefix)) {\n      throw new TypeError('prefix should be of type \"string\"')\n    }\n    if (!isBoolean(recursive)) {\n      throw new TypeError('recursive should be of type \"boolean\"')\n    }\n    if (!isString(startAfter)) {\n      throw new TypeError('startAfter should be of type \"string\"')\n    }\n\n    // if recursive is false set delimiter to '/'\n    const delimiter = recursive ? '' : '/'\n    return stream.Readable.from(this.listObjectsV2WithMetadataGen(bucketName, prefix, delimiter, startAfter), {\n      objectMode: true,\n    })\n  }\n\n  private async *listObjectsV2WithMetadataGen(\n    bucketName: string,\n    prefix: string,\n    delimiter: string,\n    startAfter: string,\n  ): AsyncIterable<BucketItemWithMetadata> {\n    let ended = false\n    let continuationToken = ''\n    do {\n      const result = await this.listObjectsV2WithMetadataQuery(\n        bucketName,\n        prefix,\n        continuationToken,\n        delimiter,\n        startAfter,\n      )\n      ended = !result.isTruncated\n      continuationToken = result.nextContinuationToken\n      for (const obj of result.objects) {\n        yield obj\n      }\n    } while (!ended)\n  }\n\n  private async listObjectsV2WithMetadataQuery(\n    bucketName: string,\n    prefix: string,\n    continuationToken: string,\n    delimiter: string,\n    startAfter: string,\n  ) {\n    const queries = []\n\n    // Call for listing objects v2 API\n    queries.push(`list-type=2`)\n    queries.push(`encoding-type=url`)\n    // escape every value in query string, except maxKeys\n    queries.push(`prefix=${uriEscape(prefix)}`)\n    queries.push(`delimiter=${uriEscape(delimiter)}`)\n    queries.push(`metadata=true`)\n\n    if (continuationToken) {\n      continuationToken = uriEscape(continuationToken)\n      queries.push(`continuation-token=${continuationToken}`)\n    }\n    // Set start-after\n    if (startAfter) {\n      startAfter = uriEscape(startAfter)\n      queries.push(`start-after=${startAfter}`)\n    }\n    queries.push(`max-keys=1000`)\n    queries.sort()\n    let query = ''\n    if (queries.length > 0) {\n      query = `${queries.join('&')}`\n    }\n    const method = 'GET'\n    const res = await this.client.makeRequestAsync({ method, bucketName, query })\n    return parseListObjectsV2WithMetadata(await readAsString(res))\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}