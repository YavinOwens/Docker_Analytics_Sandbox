{"ast":null,"code":"import * as http from \"http\";\nimport * as https from \"https\";\nimport { isBrowser } from 'browser-or-node';\nimport _ from 'lodash';\nimport * as qs from 'query-string';\nimport xml2js from 'xml2js';\nimport { CredentialProvider } from \"../CredentialProvider.mjs\";\nimport * as errors from \"../errors.mjs\";\nimport { DEFAULT_REGION } from \"../helpers.mjs\";\nimport { signV4 } from \"../signing.mjs\";\nimport { Extensions } from \"./extensions.mjs\";\nimport { extractMetadata, getVersionId, isAmazonEndpoint, isBoolean, isDefined, isEmpty, isNumber, isObject, isReadableStream, isString, isValidBucketName, isValidEndpoint, isValidObjectName, isValidPort, isVirtualHostStyle, makeDateLong, sanitizeETag, toMd5, toSha256, uriEscape, uriResourceEscape } from \"./helper.mjs\";\nimport { request } from \"./request.mjs\";\nimport { drainResponse, readAsBuffer, readAsString } from \"./response.mjs\";\nimport { getS3Endpoint } from \"./s3-endpoints.mjs\";\nimport * as xmlParsers from \"./xml-parser.mjs\";\nimport { parseInitiateMultipart } from \"./xml-parser.mjs\";\n\n// will be replaced by bundler.\nconst Package = {\n  version: \"7.1.3\" || 'development'\n};\nconst requestOptionProperties = ['agent', 'ca', 'cert', 'ciphers', 'clientCertEngine', 'crl', 'dhparam', 'ecdhCurve', 'family', 'honorCipherOrder', 'key', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureOptions', 'secureProtocol', 'servername', 'sessionIdContext'];\nexport class TypedClient {\n  partSize = 64 * 1024 * 1024;\n  maximumPartSize = 5 * 1024 * 1024 * 1024;\n  maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024;\n  constructor(params) {\n    // @ts-expect-error deprecated property\n    if (params.secure !== undefined) {\n      throw new Error('\"secure\" option deprecated, \"useSSL\" should be used instead');\n    }\n    // Default values if not specified.\n    if (params.useSSL === undefined) {\n      params.useSSL = true;\n    }\n    if (!params.port) {\n      params.port = 0;\n    }\n    // Validate input params.\n    if (!isValidEndpoint(params.endPoint)) {\n      throw new errors.InvalidEndpointError(`Invalid endPoint : ${params.endPoint}`);\n    }\n    if (!isValidPort(params.port)) {\n      throw new errors.InvalidArgumentError(`Invalid port : ${params.port}`);\n    }\n    if (!isBoolean(params.useSSL)) {\n      throw new errors.InvalidArgumentError(`Invalid useSSL flag type : ${params.useSSL}, expected to be of type \"boolean\"`);\n    }\n\n    // Validate region only if its set.\n    if (params.region) {\n      if (!isString(params.region)) {\n        throw new errors.InvalidArgumentError(`Invalid region : ${params.region}`);\n      }\n    }\n    const host = params.endPoint.toLowerCase();\n    let port = params.port;\n    let protocol;\n    let transport;\n    let transportAgent;\n    // Validate if configuration is not using SSL\n    // for constructing relevant endpoints.\n    if (params.useSSL) {\n      // Defaults to secure.\n      transport = https;\n      protocol = 'https:';\n      port = port || 443;\n      transportAgent = https.globalAgent;\n    } else {\n      transport = http;\n      protocol = 'http:';\n      port = port || 80;\n      transportAgent = http.globalAgent;\n    }\n\n    // if custom transport is set, use it.\n    if (params.transport) {\n      if (!isObject(params.transport)) {\n        throw new errors.InvalidArgumentError(`Invalid transport type : ${params.transport}, expected to be type \"object\"`);\n      }\n      transport = params.transport;\n    }\n\n    // if custom transport agent is set, use it.\n    if (params.transportAgent) {\n      if (!isObject(params.transportAgent)) {\n        throw new errors.InvalidArgumentError(`Invalid transportAgent type: ${params.transportAgent}, expected to be type \"object\"`);\n      }\n      transportAgent = params.transportAgent;\n    }\n\n    // User Agent should always following the below style.\n    // Please open an issue to discuss any new changes here.\n    //\n    //       MinIO (OS; ARCH) LIB/VER APP/VER\n    //\n    const libraryComments = `(${process.platform}; ${process.arch})`;\n    const libraryAgent = `MinIO ${libraryComments} minio-js/${Package.version}`;\n    // User agent block ends.\n\n    this.transport = transport;\n    this.transportAgent = transportAgent;\n    this.host = host;\n    this.port = port;\n    this.protocol = protocol;\n    this.userAgent = `${libraryAgent}`;\n\n    // Default path style is true\n    if (params.pathStyle === undefined) {\n      this.pathStyle = true;\n    } else {\n      this.pathStyle = params.pathStyle;\n    }\n    this.accessKey = params.accessKey ?? '';\n    this.secretKey = params.secretKey ?? '';\n    this.sessionToken = params.sessionToken;\n    this.anonymous = !this.accessKey || !this.secretKey;\n    if (params.credentialsProvider) {\n      this.credentialsProvider = params.credentialsProvider;\n    }\n    this.regionMap = {};\n    if (params.region) {\n      this.region = params.region;\n    }\n    if (params.partSize) {\n      this.partSize = params.partSize;\n      this.overRidePartSize = true;\n    }\n    if (this.partSize < 5 * 1024 * 1024) {\n      throw new errors.InvalidArgumentError(`Part size should be greater than 5MB`);\n    }\n    if (this.partSize > 5 * 1024 * 1024 * 1024) {\n      throw new errors.InvalidArgumentError(`Part size should be less than 5GB`);\n    }\n\n    // SHA256 is enabled only for authenticated http requests. If the request is authenticated\n    // and the connection is https we use x-amz-content-sha256=UNSIGNED-PAYLOAD\n    // header for signature calculation.\n    this.enableSHA256 = !this.anonymous && !params.useSSL;\n    this.s3AccelerateEndpoint = params.s3AccelerateEndpoint || undefined;\n    this.reqOptions = {};\n    this.clientExtensions = new Extensions(this);\n  }\n\n  /**\n   * Minio extensions that aren't necessary present for Amazon S3 compatible storage servers\n   */\n  get extensions() {\n    return this.clientExtensions;\n  }\n\n  /**\n   * @param endPoint - valid S3 acceleration end point\n   */\n  setS3TransferAccelerate(endPoint) {\n    this.s3AccelerateEndpoint = endPoint;\n  }\n\n  /**\n   * Sets the supported request options.\n   */\n  setRequestOptions(options) {\n    if (!isObject(options)) {\n      throw new TypeError('request options should be of type \"object\"');\n    }\n    this.reqOptions = _.pick(options, requestOptionProperties);\n  }\n\n  /**\n   *  This is s3 Specific and does not hold validity in any other Object storage.\n   */\n  getAccelerateEndPointIfSet(bucketName, objectName) {\n    if (!isEmpty(this.s3AccelerateEndpoint) && !isEmpty(bucketName) && !isEmpty(objectName)) {\n      // http://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html\n      // Disable transfer acceleration for non-compliant bucket names.\n      if (bucketName.includes('.')) {\n        throw new Error(`Transfer Acceleration is not supported for non compliant bucket:${bucketName}`);\n      }\n      // If transfer acceleration is requested set new host.\n      // For more details about enabling transfer acceleration read here.\n      // http://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html\n      return this.s3AccelerateEndpoint;\n    }\n    return false;\n  }\n\n  /**\n   * returns options object that can be used with http.request()\n   * Takes care of constructing virtual-host-style or path-style hostname\n   */\n  getRequestOptions(opts) {\n    const method = opts.method;\n    const region = opts.region;\n    const bucketName = opts.bucketName;\n    let objectName = opts.objectName;\n    const headers = opts.headers;\n    const query = opts.query;\n    let reqOptions = {\n      method,\n      headers: {},\n      protocol: this.protocol,\n      // If custom transportAgent was supplied earlier, we'll inject it here\n      agent: this.transportAgent\n    };\n\n    // Verify if virtual host supported.\n    let virtualHostStyle;\n    if (bucketName) {\n      virtualHostStyle = isVirtualHostStyle(this.host, this.protocol, bucketName, this.pathStyle);\n    }\n    let path = '/';\n    let host = this.host;\n    let port;\n    if (this.port) {\n      port = this.port;\n    }\n    if (objectName) {\n      objectName = uriResourceEscape(objectName);\n    }\n\n    // For Amazon S3 endpoint, get endpoint based on region.\n    if (isAmazonEndpoint(host)) {\n      const accelerateEndPoint = this.getAccelerateEndPointIfSet(bucketName, objectName);\n      if (accelerateEndPoint) {\n        host = `${accelerateEndPoint}`;\n      } else {\n        host = getS3Endpoint(region);\n      }\n    }\n    if (virtualHostStyle && !opts.pathStyle) {\n      // For all hosts which support virtual host style, `bucketName`\n      // is part of the hostname in the following format:\n      //\n      //  var host = 'bucketName.example.com'\n      //\n      if (bucketName) {\n        host = `${bucketName}.${host}`;\n      }\n      if (objectName) {\n        path = `/${objectName}`;\n      }\n    } else {\n      // For all S3 compatible storage services we will fallback to\n      // path style requests, where `bucketName` is part of the URI\n      // path.\n      if (bucketName) {\n        path = `/${bucketName}`;\n      }\n      if (objectName) {\n        path = `/${bucketName}/${objectName}`;\n      }\n    }\n    if (query) {\n      path += `?${query}`;\n    }\n    reqOptions.headers.host = host;\n    if (reqOptions.protocol === 'http:' && port !== 80 || reqOptions.protocol === 'https:' && port !== 443) {\n      reqOptions.headers.host = `${host}:${port}`;\n    }\n    reqOptions.headers['user-agent'] = this.userAgent;\n    if (headers) {\n      // have all header keys in lower case - to make signing easy\n      for (const [k, v] of Object.entries(headers)) {\n        reqOptions.headers[k.toLowerCase()] = v;\n      }\n    }\n\n    // Use any request option specified in minioClient.setRequestOptions()\n    reqOptions = Object.assign({}, this.reqOptions, reqOptions);\n    return {\n      ...reqOptions,\n      headers: _.mapValues(_.pickBy(reqOptions.headers, isDefined), v => v.toString()),\n      host,\n      port,\n      path\n    };\n  }\n  async setCredentialsProvider(credentialsProvider) {\n    if (!(credentialsProvider instanceof CredentialProvider)) {\n      throw new Error('Unable to get credentials. Expected instance of CredentialProvider');\n    }\n    this.credentialsProvider = credentialsProvider;\n    await this.checkAndRefreshCreds();\n  }\n  async checkAndRefreshCreds() {\n    if (this.credentialsProvider) {\n      try {\n        const credentialsConf = await this.credentialsProvider.getCredentials();\n        this.accessKey = credentialsConf.getAccessKey();\n        this.secretKey = credentialsConf.getSecretKey();\n        this.sessionToken = credentialsConf.getSessionToken();\n      } catch (e) {\n        throw new Error(`Unable to get credentials: ${e}`, {\n          cause: e\n        });\n      }\n    }\n  }\n  /**\n   * log the request, response, error\n   */\n  logHTTP(reqOptions, response, err) {\n    // if no logStream available return.\n    if (!this.logStream) {\n      return;\n    }\n    if (!isObject(reqOptions)) {\n      throw new TypeError('reqOptions should be of type \"object\"');\n    }\n    if (response && !isReadableStream(response)) {\n      throw new TypeError('response should be of type \"Stream\"');\n    }\n    if (err && !(err instanceof Error)) {\n      throw new TypeError('err should be of type \"Error\"');\n    }\n    const logStream = this.logStream;\n    const logHeaders = headers => {\n      Object.entries(headers).forEach(([k, v]) => {\n        if (k == 'authorization') {\n          if (isString(v)) {\n            const redactor = new RegExp('Signature=([0-9a-f]+)');\n            v = v.replace(redactor, 'Signature=**REDACTED**');\n          }\n        }\n        logStream.write(`${k}: ${v}\\n`);\n      });\n      logStream.write('\\n');\n    };\n    logStream.write(`REQUEST: ${reqOptions.method} ${reqOptions.path}\\n`);\n    logHeaders(reqOptions.headers);\n    if (response) {\n      this.logStream.write(`RESPONSE: ${response.statusCode}\\n`);\n      logHeaders(response.headers);\n    }\n    if (err) {\n      logStream.write('ERROR BODY:\\n');\n      const errJSON = JSON.stringify(err, null, '\\t');\n      logStream.write(`${errJSON}\\n`);\n    }\n  }\n\n  /**\n   * Enable tracing\n   */\n  traceOn(stream) {\n    if (!stream) {\n      stream = process.stdout;\n    }\n    this.logStream = stream;\n  }\n\n  /**\n   * Disable tracing\n   */\n  traceOff() {\n    this.logStream = undefined;\n  }\n\n  /**\n   * makeRequest is the primitive used by the apis for making S3 requests.\n   * payload can be empty string in case of no payload.\n   * statusCode is the expected statusCode. If response.statusCode does not match\n   * we parse the XML error and call the callback with the error message.\n   *\n   * A valid region is passed by the calls - listBuckets, makeBucket and getBucketRegion.\n   *\n   * @internal\n   */\n  async makeRequestAsync(options, payload = '', expectedCodes = [200], region = '') {\n    if (!isObject(options)) {\n      throw new TypeError('options should be of type \"object\"');\n    }\n    if (!isString(payload) && !isObject(payload)) {\n      // Buffer is of type 'object'\n      throw new TypeError('payload should be of type \"string\" or \"Buffer\"');\n    }\n    expectedCodes.forEach(statusCode => {\n      if (!isNumber(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"');\n      }\n    });\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"');\n    }\n    if (!options.headers) {\n      options.headers = {};\n    }\n    if (options.method === 'POST' || options.method === 'PUT' || options.method === 'DELETE') {\n      options.headers['content-length'] = payload.length.toString();\n    }\n    const sha256sum = this.enableSHA256 ? toSha256(payload) : '';\n    return this.makeRequestStreamAsync(options, payload, sha256sum, expectedCodes, region);\n  }\n\n  /**\n   * new request with promise\n   *\n   * No need to drain response, response body is not valid\n   */\n  async makeRequestAsyncOmit(options, payload = '', statusCodes = [200], region = '') {\n    const res = await this.makeRequestAsync(options, payload, statusCodes, region);\n    await drainResponse(res);\n    return res;\n  }\n\n  /**\n   * makeRequestStream will be used directly instead of makeRequest in case the payload\n   * is available as a stream. for ex. putObject\n   *\n   * @internal\n   */\n  async makeRequestStreamAsync(options, body, sha256sum, statusCodes, region) {\n    if (!isObject(options)) {\n      throw new TypeError('options should be of type \"object\"');\n    }\n    if (!(Buffer.isBuffer(body) || typeof body === 'string' || isReadableStream(body))) {\n      throw new errors.InvalidArgumentError(`stream should be a Buffer, string or readable Stream, got ${typeof body} instead`);\n    }\n    if (!isString(sha256sum)) {\n      throw new TypeError('sha256sum should be of type \"string\"');\n    }\n    statusCodes.forEach(statusCode => {\n      if (!isNumber(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"');\n      }\n    });\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"');\n    }\n    // sha256sum will be empty for anonymous or https requests\n    if (!this.enableSHA256 && sha256sum.length !== 0) {\n      throw new errors.InvalidArgumentError(`sha256sum expected to be empty for anonymous or https requests`);\n    }\n    // sha256sum should be valid for non-anonymous http requests.\n    if (this.enableSHA256 && sha256sum.length !== 64) {\n      throw new errors.InvalidArgumentError(`Invalid sha256sum : ${sha256sum}`);\n    }\n    await this.checkAndRefreshCreds();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    region = region || (await this.getBucketRegionAsync(options.bucketName));\n    const reqOptions = this.getRequestOptions({\n      ...options,\n      region\n    });\n    if (!this.anonymous) {\n      // For non-anonymous https requests sha256sum is 'UNSIGNED-PAYLOAD' for signature calculation.\n      if (!this.enableSHA256) {\n        sha256sum = 'UNSIGNED-PAYLOAD';\n      }\n      const date = new Date();\n      reqOptions.headers['x-amz-date'] = makeDateLong(date);\n      reqOptions.headers['x-amz-content-sha256'] = sha256sum;\n      if (this.sessionToken) {\n        reqOptions.headers['x-amz-security-token'] = this.sessionToken;\n      }\n      reqOptions.headers.authorization = signV4(reqOptions, this.accessKey, this.secretKey, region, date, sha256sum);\n    }\n    const response = await request(this.transport, reqOptions, body);\n    if (!response.statusCode) {\n      throw new Error(\"BUG: response doesn't have a statusCode\");\n    }\n    if (!statusCodes.includes(response.statusCode)) {\n      // For an incorrect region, S3 server always sends back 400.\n      // But we will do cache invalidation for all errors so that,\n      // in future, if AWS S3 decides to send a different status code or\n      // XML error code we will still work fine.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      delete this.regionMap[options.bucketName];\n      const err = await xmlParsers.parseResponseError(response);\n      this.logHTTP(reqOptions, response, err);\n      throw err;\n    }\n    this.logHTTP(reqOptions, response);\n    return response;\n  }\n\n  /**\n   * gets the region of the bucket\n   *\n   * @param bucketName\n   *\n   * @internal\n   */\n  async getBucketRegionAsync(bucketName) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name : ${bucketName}`);\n    }\n\n    // Region is set with constructor, return the region right here.\n    if (this.region) {\n      return this.region;\n    }\n    const cached = this.regionMap[bucketName];\n    if (cached) {\n      return cached;\n    }\n    const extractRegionAsync = async response => {\n      const body = await readAsString(response);\n      const region = xmlParsers.parseBucketRegion(body) || DEFAULT_REGION;\n      this.regionMap[bucketName] = region;\n      return region;\n    };\n    const method = 'GET';\n    const query = 'location';\n    // `getBucketLocation` behaves differently in following ways for\n    // different environments.\n    //\n    // - For nodejs env we default to path style requests.\n    // - For browser env path style requests on buckets yields CORS\n    //   error. To circumvent this problem we make a virtual host\n    //   style request signed with 'us-east-1'. This request fails\n    //   with an error 'AuthorizationHeaderMalformed', additionally\n    //   the error XML also provides Region of the bucket. To validate\n    //   this region is proper we retry the same request with the newly\n    //   obtained region.\n    const pathStyle = this.pathStyle && !isBrowser;\n    let region;\n    try {\n      const res = await this.makeRequestAsync({\n        method,\n        bucketName,\n        query,\n        pathStyle\n      }, '', [200], DEFAULT_REGION);\n      return extractRegionAsync(res);\n    } catch (e) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (!(e.name === 'AuthorizationHeaderMalformed')) {\n        throw e;\n      }\n      // @ts-expect-error we set extra properties on error object\n      region = e.Region;\n      if (!region) {\n        throw e;\n      }\n    }\n    const res = await this.makeRequestAsync({\n      method,\n      bucketName,\n      query,\n      pathStyle\n    }, '', [200], region);\n    return await extractRegionAsync(res);\n  }\n\n  /**\n   * makeRequest is the primitive used by the apis for making S3 requests.\n   * payload can be empty string in case of no payload.\n   * statusCode is the expected statusCode. If response.statusCode does not match\n   * we parse the XML error and call the callback with the error message.\n   * A valid region is passed by the calls - listBuckets, makeBucket and\n   * getBucketRegion.\n   *\n   * @deprecated use `makeRequestAsync` instead\n   */\n  makeRequest(options, payload = '', expectedCodes = [200], region = '', returnResponse, cb) {\n    let prom;\n    if (returnResponse) {\n      prom = this.makeRequestAsync(options, payload, expectedCodes, region);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error compatible for old behaviour\n      prom = this.makeRequestAsyncOmit(options, payload, expectedCodes, region);\n    }\n    prom.then(result => cb(null, result), err => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      cb(err);\n    });\n  }\n\n  /**\n   * makeRequestStream will be used directly instead of makeRequest in case the payload\n   * is available as a stream. for ex. putObject\n   *\n   * @deprecated use `makeRequestStreamAsync` instead\n   */\n  makeRequestStream(options, stream, sha256sum, statusCodes, region, returnResponse, cb) {\n    const executor = async () => {\n      const res = await this.makeRequestStreamAsync(options, stream, sha256sum, statusCodes, region);\n      if (!returnResponse) {\n        await drainResponse(res);\n      }\n      return res;\n    };\n    executor().then(result => cb(null, result),\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    err => cb(err));\n  }\n\n  /**\n   * @deprecated use `getBucketRegionAsync` instead\n   */\n  getBucketRegion(bucketName, cb) {\n    return this.getBucketRegionAsync(bucketName).then(result => cb(null, result),\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    err => cb(err));\n  }\n\n  /**\n   * @deprecated use promise style API\n   */\n\n  async removeBucket(bucketName) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    const method = 'DELETE';\n    await this.makeRequestAsyncOmit({\n      method,\n      bucketName\n    }, '', [204]);\n    delete this.regionMap[bucketName];\n  }\n\n  /**\n   * Stat information of the object.\n   */\n  async statObject(bucketName, objectName, statOpts = {}) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isObject(statOpts)) {\n      throw new errors.InvalidArgumentError('statOpts should be of type \"object\"');\n    }\n    const query = qs.stringify(statOpts);\n    const method = 'HEAD';\n    const res = await this.makeRequestAsyncOmit({\n      method,\n      bucketName,\n      objectName,\n      query\n    });\n    return {\n      size: parseInt(res.headers['content-length']),\n      metaData: extractMetadata(res.headers),\n      lastModified: new Date(res.headers['last-modified']),\n      versionId: getVersionId(res.headers),\n      etag: sanitizeETag(res.headers.etag)\n    };\n  }\n\n  /**\n   * Remove the specified object.\n   * @deprecated use new promise style API\n   */\n\n  /**\n   * @deprecated use new promise style API\n   */ // @ts-ignore\n  async removeObject(bucketName, objectName, removeOpts = {}) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isObject(removeOpts)) {\n      throw new errors.InvalidArgumentError('removeOpts should be of type \"object\"');\n    }\n    const method = 'DELETE';\n    const headers = {};\n    if (removeOpts.governanceBypass) {\n      headers['X-Amz-Bypass-Governance-Retention'] = true;\n    }\n    if (removeOpts.forceDelete) {\n      headers['x-minio-force-delete'] = true;\n    }\n    const queryParams = {};\n    if (removeOpts.versionId) {\n      queryParams.versionId = `${removeOpts.versionId}`;\n    }\n    const query = qs.stringify(queryParams);\n    await this.makeRequestAsyncOmit({\n      method,\n      bucketName,\n      objectName,\n      headers,\n      query\n    }, '', [200, 204]);\n  }\n\n  // Calls implemented below are related to multipart.\n\n  /**\n   * Initiate a new multipart upload.\n   * @internal\n   */\n  async initiateNewMultipartUpload(bucketName, objectName, headers) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isObject(headers)) {\n      throw new errors.InvalidObjectNameError('contentType should be of type \"object\"');\n    }\n    const method = 'POST';\n    const query = 'uploads';\n    const res = await this.makeRequestAsync({\n      method,\n      bucketName,\n      objectName,\n      query,\n      headers\n    });\n    const body = await readAsBuffer(res);\n    return parseInitiateMultipart(body.toString());\n  }\n\n  /**\n   * Internal Method to abort a multipart upload request in case of any errors.\n   *\n   * @param bucketName - Bucket Name\n   * @param objectName - Object Name\n   * @param uploadId - id of a multipart upload to cancel during compose object sequence.\n   */\n  async abortMultipartUpload(bucketName, objectName, uploadId) {\n    const method = 'DELETE';\n    const query = `uploadId=${uploadId}`;\n    const requestOptions = {\n      method,\n      bucketName,\n      objectName: objectName,\n      query\n    };\n    await this.makeRequestAsyncOmit(requestOptions, '', [204]);\n  }\n\n  /**\n   * Get part-info of all parts of an incomplete upload specified by uploadId.\n   */\n  async listParts(bucketName, objectName, uploadId) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"');\n    }\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty');\n    }\n    const parts = [];\n    let marker = 0;\n    let result;\n    do {\n      result = await this.listPartsQuery(bucketName, objectName, uploadId, marker);\n      marker = result.marker;\n      parts.push(...result.parts);\n    } while (result.isTruncated);\n    return parts;\n  }\n\n  /**\n   * Called by listParts to fetch a batch of part-info\n   */\n  async listPartsQuery(bucketName, objectName, uploadId, marker) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`);\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"');\n    }\n    if (!isNumber(marker)) {\n      throw new TypeError('marker should be of type \"number\"');\n    }\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty');\n    }\n    let query = `uploadId=${uriEscape(uploadId)}`;\n    if (marker) {\n      query += `&part-number-marker=${marker}`;\n    }\n    const method = 'GET';\n    const res = await this.makeRequestAsync({\n      method,\n      bucketName,\n      objectName,\n      query\n    });\n    return xmlParsers.parseListParts(await readAsString(res));\n  }\n  async listBuckets() {\n    const method = 'GET';\n    const httpRes = await this.makeRequestAsync({\n      method\n    }, '', [200], DEFAULT_REGION);\n    const xmlResult = await readAsString(httpRes);\n    return xmlParsers.parseListBucket(xmlResult);\n  }\n  async removeBucketReplication(bucketName) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    const method = 'DELETE';\n    const query = 'replication';\n    await this.makeRequestAsyncOmit({\n      method,\n      bucketName,\n      query\n    }, '', [200, 204], '');\n  }\n  async setBucketReplication(bucketName, replicationConfig) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    if (!isObject(replicationConfig)) {\n      throw new errors.InvalidArgumentError('replicationConfig should be of type \"object\"');\n    } else {\n      if (_.isEmpty(replicationConfig.role)) {\n        throw new errors.InvalidArgumentError('Role cannot be empty');\n      } else if (replicationConfig.role && !isString(replicationConfig.role)) {\n        throw new errors.InvalidArgumentError('Invalid value for role', replicationConfig.role);\n      }\n      if (_.isEmpty(replicationConfig.rules)) {\n        throw new errors.InvalidArgumentError('Minimum one replication rule must be specified');\n      }\n    }\n    const method = 'PUT';\n    const query = 'replication';\n    const headers = {};\n    const replicationParamsConfig = {\n      ReplicationConfiguration: {\n        Role: replicationConfig.role,\n        Rule: replicationConfig.rules\n      }\n    };\n    const builder = new xml2js.Builder({\n      renderOpts: {\n        pretty: false\n      },\n      headless: true\n    });\n    const payload = builder.buildObject(replicationParamsConfig);\n    headers['Content-MD5'] = toMd5(payload);\n    await this.makeRequestAsyncOmit({\n      method,\n      bucketName,\n      query,\n      headers\n    }, payload);\n  }\n  async getBucketReplication(bucketName) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName);\n    }\n    const method = 'GET';\n    const query = 'replication';\n    const httpRes = await this.makeRequestAsync({\n      method,\n      bucketName,\n      query\n    }, '', [200, 204]);\n    const xmlResult = await readAsString(httpRes);\n    return xmlParsers.parseReplicationConfig(xmlResult);\n  }\n}","map":{"version":3,"names":["http","https","isBrowser","_","qs","xml2js","CredentialProvider","errors","DEFAULT_REGION","signV4","Extensions","extractMetadata","getVersionId","isAmazonEndpoint","isBoolean","isDefined","isEmpty","isNumber","isObject","isReadableStream","isString","isValidBucketName","isValidEndpoint","isValidObjectName","isValidPort","isVirtualHostStyle","makeDateLong","sanitizeETag","toMd5","toSha256","uriEscape","uriResourceEscape","request","drainResponse","readAsBuffer","readAsString","getS3Endpoint","xmlParsers","parseInitiateMultipart","Package","version","requestOptionProperties","TypedClient","partSize","maximumPartSize","maxObjectSize","constructor","params","secure","undefined","Error","useSSL","port","endPoint","InvalidEndpointError","InvalidArgumentError","region","host","toLowerCase","protocol","transport","transportAgent","globalAgent","libraryComments","process","platform","arch","libraryAgent","userAgent","pathStyle","accessKey","secretKey","sessionToken","anonymous","credentialsProvider","regionMap","overRidePartSize","enableSHA256","s3AccelerateEndpoint","reqOptions","clientExtensions","extensions","setS3TransferAccelerate","setRequestOptions","options","TypeError","pick","getAccelerateEndPointIfSet","bucketName","objectName","includes","getRequestOptions","opts","method","headers","query","agent","virtualHostStyle","path","accelerateEndPoint","k","v","Object","entries","assign","mapValues","pickBy","toString","setCredentialsProvider","checkAndRefreshCreds","credentialsConf","getCredentials","getAccessKey","getSecretKey","getSessionToken","e","cause","logHTTP","response","err","logStream","logHeaders","forEach","redactor","RegExp","replace","write","statusCode","errJSON","JSON","stringify","traceOn","stream","stdout","traceOff","makeRequestAsync","payload","expectedCodes","length","sha256sum","makeRequestStreamAsync","makeRequestAsyncOmit","statusCodes","res","body","Buffer","isBuffer","getBucketRegionAsync","date","Date","authorization","parseResponseError","InvalidBucketNameError","cached","extractRegionAsync","parseBucketRegion","name","Region","makeRequest","returnResponse","cb","prom","then","result","makeRequestStream","executor","getBucketRegion","removeBucket","statObject","statOpts","InvalidObjectNameError","size","parseInt","metaData","lastModified","versionId","etag","removeObject","removeOpts","governanceBypass","forceDelete","queryParams","initiateNewMultipartUpload","abortMultipartUpload","uploadId","requestOptions","listParts","parts","marker","listPartsQuery","push","isTruncated","parseListParts","listBuckets","httpRes","xmlResult","parseListBucket","removeBucketReplication","setBucketReplication","replicationConfig","role","rules","replicationParamsConfig","ReplicationConfiguration","Role","Rule","builder","Builder","renderOpts","pretty","headless","buildObject","getBucketReplication","parseReplicationConfig"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/internal/client.ts"],"sourcesContent":["import * as http from 'node:http'\nimport * as https from 'node:https'\nimport type * as stream from 'node:stream'\n\nimport { isBrowser } from 'browser-or-node'\nimport _ from 'lodash'\nimport * as qs from 'query-string'\nimport xml2js from 'xml2js'\n\nimport { CredentialProvider } from '../CredentialProvider.ts'\nimport * as errors from '../errors.ts'\nimport { DEFAULT_REGION } from '../helpers.ts'\nimport { signV4 } from '../signing.ts'\nimport { Extensions } from './extensions.ts'\nimport {\n  extractMetadata,\n  getVersionId,\n  isAmazonEndpoint,\n  isBoolean,\n  isDefined,\n  isEmpty,\n  isNumber,\n  isObject,\n  isReadableStream,\n  isString,\n  isValidBucketName,\n  isValidEndpoint,\n  isValidObjectName,\n  isValidPort,\n  isVirtualHostStyle,\n  makeDateLong,\n  sanitizeETag,\n  toMd5,\n  toSha256,\n  uriEscape,\n  uriResourceEscape,\n} from './helper.ts'\nimport { request } from './request.ts'\nimport { drainResponse, readAsBuffer, readAsString } from './response.ts'\nimport type { Region } from './s3-endpoints.ts'\nimport { getS3Endpoint } from './s3-endpoints.ts'\nimport type {\n  Binary,\n  BucketItemFromList,\n  BucketItemStat,\n  IRequest,\n  ReplicationConfig,\n  ReplicationConfigOpts,\n  RequestHeaders,\n  ResponseHeader,\n  ResultCallback,\n  StatObjectOpts,\n  Transport,\n} from './type.ts'\nimport type { UploadedPart } from './xml-parser.ts'\nimport * as xmlParsers from './xml-parser.ts'\nimport { parseInitiateMultipart } from './xml-parser.ts'\n\n// will be replaced by bundler.\nconst Package = { version: process.env.MINIO_JS_PACKAGE_VERSION || 'development' }\n\nconst requestOptionProperties = [\n  'agent',\n  'ca',\n  'cert',\n  'ciphers',\n  'clientCertEngine',\n  'crl',\n  'dhparam',\n  'ecdhCurve',\n  'family',\n  'honorCipherOrder',\n  'key',\n  'passphrase',\n  'pfx',\n  'rejectUnauthorized',\n  'secureOptions',\n  'secureProtocol',\n  'servername',\n  'sessionIdContext',\n] as const\n\nexport interface ClientOptions {\n  endPoint: string\n  accessKey: string\n  secretKey: string\n  useSSL?: boolean\n  port?: number\n  region?: Region\n  transport?: Transport\n  sessionToken?: string\n  partSize?: number\n  pathStyle?: boolean\n  credentialsProvider?: CredentialProvider\n  s3AccelerateEndpoint?: string\n  transportAgent?: http.Agent\n}\n\nexport type RequestOption = Partial<IRequest> & {\n  method: string\n  bucketName?: string\n  objectName?: string\n  query?: string\n  pathStyle?: boolean\n}\n\nexport type NoResultCallback = (error: unknown) => void\n\nexport interface RemoveOptions {\n  versionId?: string\n  governanceBypass?: boolean\n  forceDelete?: boolean\n}\n\nexport class TypedClient {\n  protected transport: Transport\n  protected host: string\n  protected port: number\n  protected protocol: string\n  protected accessKey: string\n  protected secretKey: string\n  protected sessionToken?: string\n  protected userAgent: string\n  protected anonymous: boolean\n  protected pathStyle: boolean\n  protected regionMap: Record<string, string>\n  public region?: string\n  protected credentialsProvider?: CredentialProvider\n  partSize: number = 64 * 1024 * 1024\n  protected overRidePartSize?: boolean\n\n  protected maximumPartSize = 5 * 1024 * 1024 * 1024\n  protected maxObjectSize = 5 * 1024 * 1024 * 1024 * 1024\n  public enableSHA256: boolean\n  protected s3AccelerateEndpoint?: string\n  protected reqOptions: Record<string, unknown>\n\n  protected transportAgent: http.Agent\n  private readonly clientExtensions: Extensions\n\n  constructor(params: ClientOptions) {\n    // @ts-expect-error deprecated property\n    if (params.secure !== undefined) {\n      throw new Error('\"secure\" option deprecated, \"useSSL\" should be used instead')\n    }\n    // Default values if not specified.\n    if (params.useSSL === undefined) {\n      params.useSSL = true\n    }\n    if (!params.port) {\n      params.port = 0\n    }\n    // Validate input params.\n    if (!isValidEndpoint(params.endPoint)) {\n      throw new errors.InvalidEndpointError(`Invalid endPoint : ${params.endPoint}`)\n    }\n    if (!isValidPort(params.port)) {\n      throw new errors.InvalidArgumentError(`Invalid port : ${params.port}`)\n    }\n    if (!isBoolean(params.useSSL)) {\n      throw new errors.InvalidArgumentError(\n        `Invalid useSSL flag type : ${params.useSSL}, expected to be of type \"boolean\"`,\n      )\n    }\n\n    // Validate region only if its set.\n    if (params.region) {\n      if (!isString(params.region)) {\n        throw new errors.InvalidArgumentError(`Invalid region : ${params.region}`)\n      }\n    }\n\n    const host = params.endPoint.toLowerCase()\n    let port = params.port\n    let protocol: string\n    let transport\n    let transportAgent: http.Agent\n    // Validate if configuration is not using SSL\n    // for constructing relevant endpoints.\n    if (params.useSSL) {\n      // Defaults to secure.\n      transport = https\n      protocol = 'https:'\n      port = port || 443\n      transportAgent = https.globalAgent\n    } else {\n      transport = http\n      protocol = 'http:'\n      port = port || 80\n      transportAgent = http.globalAgent\n    }\n\n    // if custom transport is set, use it.\n    if (params.transport) {\n      if (!isObject(params.transport)) {\n        throw new errors.InvalidArgumentError(\n          `Invalid transport type : ${params.transport}, expected to be type \"object\"`,\n        )\n      }\n      transport = params.transport\n    }\n\n    // if custom transport agent is set, use it.\n    if (params.transportAgent) {\n      if (!isObject(params.transportAgent)) {\n        throw new errors.InvalidArgumentError(\n          `Invalid transportAgent type: ${params.transportAgent}, expected to be type \"object\"`,\n        )\n      }\n\n      transportAgent = params.transportAgent\n    }\n\n    // User Agent should always following the below style.\n    // Please open an issue to discuss any new changes here.\n    //\n    //       MinIO (OS; ARCH) LIB/VER APP/VER\n    //\n    const libraryComments = `(${process.platform}; ${process.arch})`\n    const libraryAgent = `MinIO ${libraryComments} minio-js/${Package.version}`\n    // User agent block ends.\n\n    this.transport = transport\n    this.transportAgent = transportAgent\n    this.host = host\n    this.port = port\n    this.protocol = protocol\n    this.userAgent = `${libraryAgent}`\n\n    // Default path style is true\n    if (params.pathStyle === undefined) {\n      this.pathStyle = true\n    } else {\n      this.pathStyle = params.pathStyle\n    }\n\n    this.accessKey = params.accessKey ?? ''\n    this.secretKey = params.secretKey ?? ''\n    this.sessionToken = params.sessionToken\n    this.anonymous = !this.accessKey || !this.secretKey\n\n    if (params.credentialsProvider) {\n      this.credentialsProvider = params.credentialsProvider\n    }\n\n    this.regionMap = {}\n    if (params.region) {\n      this.region = params.region\n    }\n\n    if (params.partSize) {\n      this.partSize = params.partSize\n      this.overRidePartSize = true\n    }\n    if (this.partSize < 5 * 1024 * 1024) {\n      throw new errors.InvalidArgumentError(`Part size should be greater than 5MB`)\n    }\n    if (this.partSize > 5 * 1024 * 1024 * 1024) {\n      throw new errors.InvalidArgumentError(`Part size should be less than 5GB`)\n    }\n\n    // SHA256 is enabled only for authenticated http requests. If the request is authenticated\n    // and the connection is https we use x-amz-content-sha256=UNSIGNED-PAYLOAD\n    // header for signature calculation.\n    this.enableSHA256 = !this.anonymous && !params.useSSL\n\n    this.s3AccelerateEndpoint = params.s3AccelerateEndpoint || undefined\n    this.reqOptions = {}\n    this.clientExtensions = new Extensions(this)\n  }\n\n  /**\n   * Minio extensions that aren't necessary present for Amazon S3 compatible storage servers\n   */\n  get extensions() {\n    return this.clientExtensions\n  }\n\n  /**\n   * @param endPoint - valid S3 acceleration end point\n   */\n  setS3TransferAccelerate(endPoint: string) {\n    this.s3AccelerateEndpoint = endPoint\n  }\n\n  /**\n   * Sets the supported request options.\n   */\n  public setRequestOptions(options: Pick<https.RequestOptions, (typeof requestOptionProperties)[number]>) {\n    if (!isObject(options)) {\n      throw new TypeError('request options should be of type \"object\"')\n    }\n    this.reqOptions = _.pick(options, requestOptionProperties)\n  }\n\n  /**\n   *  This is s3 Specific and does not hold validity in any other Object storage.\n   */\n  private getAccelerateEndPointIfSet(bucketName?: string, objectName?: string) {\n    if (!isEmpty(this.s3AccelerateEndpoint) && !isEmpty(bucketName) && !isEmpty(objectName)) {\n      // http://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html\n      // Disable transfer acceleration for non-compliant bucket names.\n      if (bucketName.includes('.')) {\n        throw new Error(`Transfer Acceleration is not supported for non compliant bucket:${bucketName}`)\n      }\n      // If transfer acceleration is requested set new host.\n      // For more details about enabling transfer acceleration read here.\n      // http://docs.aws.amazon.com/AmazonS3/latest/dev/transfer-acceleration.html\n      return this.s3AccelerateEndpoint\n    }\n    return false\n  }\n\n  /**\n   * returns options object that can be used with http.request()\n   * Takes care of constructing virtual-host-style or path-style hostname\n   */\n  protected getRequestOptions(\n    opts: RequestOption & { region: string },\n  ): IRequest & { host: string; headers: Record<string, string> } {\n    const method = opts.method\n    const region = opts.region\n    const bucketName = opts.bucketName\n    let objectName = opts.objectName\n    const headers = opts.headers\n    const query = opts.query\n\n    let reqOptions = {\n      method,\n      headers: {} as RequestHeaders,\n      protocol: this.protocol,\n      // If custom transportAgent was supplied earlier, we'll inject it here\n      agent: this.transportAgent,\n    }\n\n    // Verify if virtual host supported.\n    let virtualHostStyle\n    if (bucketName) {\n      virtualHostStyle = isVirtualHostStyle(this.host, this.protocol, bucketName, this.pathStyle)\n    }\n\n    let path = '/'\n    let host = this.host\n\n    let port: undefined | number\n    if (this.port) {\n      port = this.port\n    }\n\n    if (objectName) {\n      objectName = uriResourceEscape(objectName)\n    }\n\n    // For Amazon S3 endpoint, get endpoint based on region.\n    if (isAmazonEndpoint(host)) {\n      const accelerateEndPoint = this.getAccelerateEndPointIfSet(bucketName, objectName)\n      if (accelerateEndPoint) {\n        host = `${accelerateEndPoint}`\n      } else {\n        host = getS3Endpoint(region)\n      }\n    }\n\n    if (virtualHostStyle && !opts.pathStyle) {\n      // For all hosts which support virtual host style, `bucketName`\n      // is part of the hostname in the following format:\n      //\n      //  var host = 'bucketName.example.com'\n      //\n      if (bucketName) {\n        host = `${bucketName}.${host}`\n      }\n      if (objectName) {\n        path = `/${objectName}`\n      }\n    } else {\n      // For all S3 compatible storage services we will fallback to\n      // path style requests, where `bucketName` is part of the URI\n      // path.\n      if (bucketName) {\n        path = `/${bucketName}`\n      }\n      if (objectName) {\n        path = `/${bucketName}/${objectName}`\n      }\n    }\n\n    if (query) {\n      path += `?${query}`\n    }\n    reqOptions.headers.host = host\n    if ((reqOptions.protocol === 'http:' && port !== 80) || (reqOptions.protocol === 'https:' && port !== 443)) {\n      reqOptions.headers.host = `${host}:${port}`\n    }\n    reqOptions.headers['user-agent'] = this.userAgent\n    if (headers) {\n      // have all header keys in lower case - to make signing easy\n      for (const [k, v] of Object.entries(headers)) {\n        reqOptions.headers[k.toLowerCase()] = v\n      }\n    }\n\n    // Use any request option specified in minioClient.setRequestOptions()\n    reqOptions = Object.assign({}, this.reqOptions, reqOptions)\n\n    return {\n      ...reqOptions,\n      headers: _.mapValues(_.pickBy(reqOptions.headers, isDefined), (v) => v.toString()),\n      host,\n      port,\n      path,\n    } satisfies https.RequestOptions\n  }\n\n  public async setCredentialsProvider(credentialsProvider: CredentialProvider) {\n    if (!(credentialsProvider instanceof CredentialProvider)) {\n      throw new Error('Unable to get credentials. Expected instance of CredentialProvider')\n    }\n    this.credentialsProvider = credentialsProvider\n    await this.checkAndRefreshCreds()\n  }\n\n  private async checkAndRefreshCreds() {\n    if (this.credentialsProvider) {\n      try {\n        const credentialsConf = await this.credentialsProvider.getCredentials()\n        this.accessKey = credentialsConf.getAccessKey()\n        this.secretKey = credentialsConf.getSecretKey()\n        this.sessionToken = credentialsConf.getSessionToken()\n      } catch (e) {\n        throw new Error(`Unable to get credentials: ${e}`, { cause: e })\n      }\n    }\n  }\n\n  private logStream?: stream.Writable\n\n  /**\n   * log the request, response, error\n   */\n  private logHTTP(reqOptions: IRequest, response: http.IncomingMessage | null, err?: unknown) {\n    // if no logStream available return.\n    if (!this.logStream) {\n      return\n    }\n    if (!isObject(reqOptions)) {\n      throw new TypeError('reqOptions should be of type \"object\"')\n    }\n    if (response && !isReadableStream(response)) {\n      throw new TypeError('response should be of type \"Stream\"')\n    }\n    if (err && !(err instanceof Error)) {\n      throw new TypeError('err should be of type \"Error\"')\n    }\n    const logStream = this.logStream\n    const logHeaders = (headers: RequestHeaders) => {\n      Object.entries(headers).forEach(([k, v]) => {\n        if (k == 'authorization') {\n          if (isString(v)) {\n            const redactor = new RegExp('Signature=([0-9a-f]+)')\n            v = v.replace(redactor, 'Signature=**REDACTED**')\n          }\n        }\n        logStream.write(`${k}: ${v}\\n`)\n      })\n      logStream.write('\\n')\n    }\n    logStream.write(`REQUEST: ${reqOptions.method} ${reqOptions.path}\\n`)\n    logHeaders(reqOptions.headers)\n    if (response) {\n      this.logStream.write(`RESPONSE: ${response.statusCode}\\n`)\n      logHeaders(response.headers as RequestHeaders)\n    }\n    if (err) {\n      logStream.write('ERROR BODY:\\n')\n      const errJSON = JSON.stringify(err, null, '\\t')\n      logStream.write(`${errJSON}\\n`)\n    }\n  }\n\n  /**\n   * Enable tracing\n   */\n  public traceOn(stream?: stream.Writable) {\n    if (!stream) {\n      stream = process.stdout\n    }\n    this.logStream = stream\n  }\n\n  /**\n   * Disable tracing\n   */\n  public traceOff() {\n    this.logStream = undefined\n  }\n\n  /**\n   * makeRequest is the primitive used by the apis for making S3 requests.\n   * payload can be empty string in case of no payload.\n   * statusCode is the expected statusCode. If response.statusCode does not match\n   * we parse the XML error and call the callback with the error message.\n   *\n   * A valid region is passed by the calls - listBuckets, makeBucket and getBucketRegion.\n   *\n   * @internal\n   */\n  async makeRequestAsync(\n    options: RequestOption,\n    payload: Binary = '',\n    expectedCodes: number[] = [200],\n    region = '',\n  ): Promise<http.IncomingMessage> {\n    if (!isObject(options)) {\n      throw new TypeError('options should be of type \"object\"')\n    }\n    if (!isString(payload) && !isObject(payload)) {\n      // Buffer is of type 'object'\n      throw new TypeError('payload should be of type \"string\" or \"Buffer\"')\n    }\n    expectedCodes.forEach((statusCode) => {\n      if (!isNumber(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"')\n      }\n    })\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"')\n    }\n    if (!options.headers) {\n      options.headers = {}\n    }\n    if (options.method === 'POST' || options.method === 'PUT' || options.method === 'DELETE') {\n      options.headers['content-length'] = payload.length.toString()\n    }\n    const sha256sum = this.enableSHA256 ? toSha256(payload) : ''\n    return this.makeRequestStreamAsync(options, payload, sha256sum, expectedCodes, region)\n  }\n\n  /**\n   * new request with promise\n   *\n   * No need to drain response, response body is not valid\n   */\n  async makeRequestAsyncOmit(\n    options: RequestOption,\n    payload: Binary = '',\n    statusCodes: number[] = [200],\n    region = '',\n  ): Promise<Omit<http.IncomingMessage, 'on'>> {\n    const res = await this.makeRequestAsync(options, payload, statusCodes, region)\n    await drainResponse(res)\n    return res\n  }\n\n  /**\n   * makeRequestStream will be used directly instead of makeRequest in case the payload\n   * is available as a stream. for ex. putObject\n   *\n   * @internal\n   */\n  async makeRequestStreamAsync(\n    options: RequestOption,\n    body: stream.Readable | Binary,\n    sha256sum: string,\n    statusCodes: number[],\n    region: string,\n  ): Promise<http.IncomingMessage> {\n    if (!isObject(options)) {\n      throw new TypeError('options should be of type \"object\"')\n    }\n    if (!(Buffer.isBuffer(body) || typeof body === 'string' || isReadableStream(body))) {\n      throw new errors.InvalidArgumentError(\n        `stream should be a Buffer, string or readable Stream, got ${typeof body} instead`,\n      )\n    }\n    if (!isString(sha256sum)) {\n      throw new TypeError('sha256sum should be of type \"string\"')\n    }\n    statusCodes.forEach((statusCode) => {\n      if (!isNumber(statusCode)) {\n        throw new TypeError('statusCode should be of type \"number\"')\n      }\n    })\n    if (!isString(region)) {\n      throw new TypeError('region should be of type \"string\"')\n    }\n    // sha256sum will be empty for anonymous or https requests\n    if (!this.enableSHA256 && sha256sum.length !== 0) {\n      throw new errors.InvalidArgumentError(`sha256sum expected to be empty for anonymous or https requests`)\n    }\n    // sha256sum should be valid for non-anonymous http requests.\n    if (this.enableSHA256 && sha256sum.length !== 64) {\n      throw new errors.InvalidArgumentError(`Invalid sha256sum : ${sha256sum}`)\n    }\n\n    await this.checkAndRefreshCreds()\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    region = region || (await this.getBucketRegionAsync(options.bucketName!))\n\n    const reqOptions = this.getRequestOptions({ ...options, region })\n    if (!this.anonymous) {\n      // For non-anonymous https requests sha256sum is 'UNSIGNED-PAYLOAD' for signature calculation.\n      if (!this.enableSHA256) {\n        sha256sum = 'UNSIGNED-PAYLOAD'\n      }\n      const date = new Date()\n      reqOptions.headers['x-amz-date'] = makeDateLong(date)\n      reqOptions.headers['x-amz-content-sha256'] = sha256sum\n      if (this.sessionToken) {\n        reqOptions.headers['x-amz-security-token'] = this.sessionToken\n      }\n      reqOptions.headers.authorization = signV4(reqOptions, this.accessKey, this.secretKey, region, date, sha256sum)\n    }\n\n    const response = await request(this.transport, reqOptions, body)\n    if (!response.statusCode) {\n      throw new Error(\"BUG: response doesn't have a statusCode\")\n    }\n\n    if (!statusCodes.includes(response.statusCode)) {\n      // For an incorrect region, S3 server always sends back 400.\n      // But we will do cache invalidation for all errors so that,\n      // in future, if AWS S3 decides to send a different status code or\n      // XML error code we will still work fine.\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      delete this.regionMap[options.bucketName!]\n\n      const err = await xmlParsers.parseResponseError(response)\n      this.logHTTP(reqOptions, response, err)\n      throw err\n    }\n\n    this.logHTTP(reqOptions, response)\n\n    return response\n  }\n\n  /**\n   * gets the region of the bucket\n   *\n   * @param bucketName\n   *\n   * @internal\n   */\n  protected async getBucketRegionAsync(bucketName: string): Promise<string> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name : ${bucketName}`)\n    }\n\n    // Region is set with constructor, return the region right here.\n    if (this.region) {\n      return this.region\n    }\n\n    const cached = this.regionMap[bucketName]\n    if (cached) {\n      return cached\n    }\n\n    const extractRegionAsync = async (response: http.IncomingMessage) => {\n      const body = await readAsString(response)\n      const region = xmlParsers.parseBucketRegion(body) || DEFAULT_REGION\n      this.regionMap[bucketName] = region\n      return region\n    }\n\n    const method = 'GET'\n    const query = 'location'\n    // `getBucketLocation` behaves differently in following ways for\n    // different environments.\n    //\n    // - For nodejs env we default to path style requests.\n    // - For browser env path style requests on buckets yields CORS\n    //   error. To circumvent this problem we make a virtual host\n    //   style request signed with 'us-east-1'. This request fails\n    //   with an error 'AuthorizationHeaderMalformed', additionally\n    //   the error XML also provides Region of the bucket. To validate\n    //   this region is proper we retry the same request with the newly\n    //   obtained region.\n    const pathStyle = this.pathStyle && !isBrowser\n    let region: string\n    try {\n      const res = await this.makeRequestAsync({ method, bucketName, query, pathStyle }, '', [200], DEFAULT_REGION)\n      return extractRegionAsync(res)\n    } catch (e) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      if (!(e.name === 'AuthorizationHeaderMalformed')) {\n        throw e\n      }\n      // @ts-expect-error we set extra properties on error object\n      region = e.Region as string\n      if (!region) {\n        throw e\n      }\n    }\n\n    const res = await this.makeRequestAsync({ method, bucketName, query, pathStyle }, '', [200], region)\n    return await extractRegionAsync(res)\n  }\n\n  /**\n   * makeRequest is the primitive used by the apis for making S3 requests.\n   * payload can be empty string in case of no payload.\n   * statusCode is the expected statusCode. If response.statusCode does not match\n   * we parse the XML error and call the callback with the error message.\n   * A valid region is passed by the calls - listBuckets, makeBucket and\n   * getBucketRegion.\n   *\n   * @deprecated use `makeRequestAsync` instead\n   */\n  makeRequest(\n    options: RequestOption,\n    payload: Binary = '',\n    expectedCodes: number[] = [200],\n    region = '',\n    returnResponse: boolean,\n    cb: (cb: unknown, result: http.IncomingMessage) => void,\n  ) {\n    let prom: Promise<http.IncomingMessage>\n    if (returnResponse) {\n      prom = this.makeRequestAsync(options, payload, expectedCodes, region)\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error compatible for old behaviour\n      prom = this.makeRequestAsyncOmit(options, payload, expectedCodes, region)\n    }\n\n    prom.then(\n      (result) => cb(null, result),\n      (err) => {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        cb(err)\n      },\n    )\n  }\n\n  /**\n   * makeRequestStream will be used directly instead of makeRequest in case the payload\n   * is available as a stream. for ex. putObject\n   *\n   * @deprecated use `makeRequestStreamAsync` instead\n   */\n  makeRequestStream(\n    options: RequestOption,\n    stream: stream.Readable | Buffer,\n    sha256sum: string,\n    statusCodes: number[],\n    region: string,\n    returnResponse: boolean,\n    cb: (cb: unknown, result: http.IncomingMessage) => void,\n  ) {\n    const executor = async () => {\n      const res = await this.makeRequestStreamAsync(options, stream, sha256sum, statusCodes, region)\n      if (!returnResponse) {\n        await drainResponse(res)\n      }\n\n      return res\n    }\n\n    executor().then(\n      (result) => cb(null, result),\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      (err) => cb(err),\n    )\n  }\n\n  /**\n   * @deprecated use `getBucketRegionAsync` instead\n   */\n  getBucketRegion(bucketName: string, cb: (err: unknown, region: string) => void) {\n    return this.getBucketRegionAsync(bucketName).then(\n      (result) => cb(null, result),\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      (err) => cb(err),\n    )\n  }\n\n  async removeBucket(bucketName: string): Promise<void>\n\n  /**\n   * @deprecated use promise style API\n   */\n  removeBucket(bucketName: string, callback: NoResultCallback): void\n\n  async removeBucket(bucketName: string): Promise<void> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    const method = 'DELETE'\n    await this.makeRequestAsyncOmit({ method, bucketName }, '', [204])\n    delete this.regionMap[bucketName]\n  }\n\n  /**\n   * Stat information of the object.\n   */\n  async statObject(bucketName: string, objectName: string, statOpts: StatObjectOpts = {}): Promise<BucketItemStat> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    if (!isObject(statOpts)) {\n      throw new errors.InvalidArgumentError('statOpts should be of type \"object\"')\n    }\n\n    const query = qs.stringify(statOpts)\n    const method = 'HEAD'\n    const res = await this.makeRequestAsyncOmit({ method, bucketName, objectName, query })\n\n    return {\n      size: parseInt(res.headers['content-length'] as string),\n      metaData: extractMetadata(res.headers as ResponseHeader),\n      lastModified: new Date(res.headers['last-modified'] as string),\n      versionId: getVersionId(res.headers as ResponseHeader),\n      etag: sanitizeETag(res.headers.etag),\n    }\n  }\n\n  /**\n   * Remove the specified object.\n   * @deprecated use new promise style API\n   */\n  removeObject(bucketName: string, objectName: string, removeOpts: RemoveOptions, callback: NoResultCallback): void\n  /**\n   * @deprecated use new promise style API\n   */\n  // @ts-ignore\n  removeObject(bucketName: string, objectName: string, callback: NoResultCallback): void\n  async removeObject(bucketName: string, objectName: string, removeOpts?: RemoveOptions): Promise<void>\n\n  async removeObject(bucketName: string, objectName: string, removeOpts: RemoveOptions = {}): Promise<void> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError(`Invalid bucket name: ${bucketName}`)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n\n    if (!isObject(removeOpts)) {\n      throw new errors.InvalidArgumentError('removeOpts should be of type \"object\"')\n    }\n\n    const method = 'DELETE'\n\n    const headers: RequestHeaders = {}\n    if (removeOpts.governanceBypass) {\n      headers['X-Amz-Bypass-Governance-Retention'] = true\n    }\n    if (removeOpts.forceDelete) {\n      headers['x-minio-force-delete'] = true\n    }\n\n    const queryParams: Record<string, string> = {}\n    if (removeOpts.versionId) {\n      queryParams.versionId = `${removeOpts.versionId}`\n    }\n    const query = qs.stringify(queryParams)\n\n    await this.makeRequestAsyncOmit({ method, bucketName, objectName, headers, query }, '', [200, 204])\n  }\n\n  // Calls implemented below are related to multipart.\n\n  /**\n   * Initiate a new multipart upload.\n   * @internal\n   */\n  async initiateNewMultipartUpload(bucketName: string, objectName: string, headers: RequestHeaders): Promise<string> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isObject(headers)) {\n      throw new errors.InvalidObjectNameError('contentType should be of type \"object\"')\n    }\n    const method = 'POST'\n    const query = 'uploads'\n    const res = await this.makeRequestAsync({ method, bucketName, objectName, query, headers })\n    const body = await readAsBuffer(res)\n    return parseInitiateMultipart(body.toString())\n  }\n\n  /**\n   * Internal Method to abort a multipart upload request in case of any errors.\n   *\n   * @param bucketName - Bucket Name\n   * @param objectName - Object Name\n   * @param uploadId - id of a multipart upload to cancel during compose object sequence.\n   */\n  async abortMultipartUpload(bucketName: string, objectName: string, uploadId: string): Promise<void> {\n    const method = 'DELETE'\n    const query = `uploadId=${uploadId}`\n\n    const requestOptions = { method, bucketName, objectName: objectName, query }\n    await this.makeRequestAsyncOmit(requestOptions, '', [204])\n  }\n\n  /**\n   * Get part-info of all parts of an incomplete upload specified by uploadId.\n   */\n  protected async listParts(bucketName: string, objectName: string, uploadId: string): Promise<UploadedPart[]> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"')\n    }\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty')\n    }\n\n    const parts: UploadedPart[] = []\n    let marker = 0\n    let result\n    do {\n      result = await this.listPartsQuery(bucketName, objectName, uploadId, marker)\n      marker = result.marker\n      parts.push(...result.parts)\n    } while (result.isTruncated)\n\n    return parts\n  }\n\n  /**\n   * Called by listParts to fetch a batch of part-info\n   */\n  private async listPartsQuery(bucketName: string, objectName: string, uploadId: string, marker: number) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isValidObjectName(objectName)) {\n      throw new errors.InvalidObjectNameError(`Invalid object name: ${objectName}`)\n    }\n    if (!isString(uploadId)) {\n      throw new TypeError('uploadId should be of type \"string\"')\n    }\n    if (!isNumber(marker)) {\n      throw new TypeError('marker should be of type \"number\"')\n    }\n    if (!uploadId) {\n      throw new errors.InvalidArgumentError('uploadId cannot be empty')\n    }\n\n    let query = `uploadId=${uriEscape(uploadId)}`\n    if (marker) {\n      query += `&part-number-marker=${marker}`\n    }\n\n    const method = 'GET'\n    const res = await this.makeRequestAsync({ method, bucketName, objectName, query })\n    return xmlParsers.parseListParts(await readAsString(res))\n  }\n\n  async listBuckets(): Promise<BucketItemFromList[]> {\n    const method = 'GET'\n    const httpRes = await this.makeRequestAsync({ method }, '', [200], DEFAULT_REGION)\n    const xmlResult = await readAsString(httpRes)\n    return xmlParsers.parseListBucket(xmlResult)\n  }\n\n  async removeBucketReplication(bucketName: string): Promise<void>\n  removeBucketReplication(bucketName: string, callback: NoResultCallback): void\n  async removeBucketReplication(bucketName: string): Promise<void> {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    const method = 'DELETE'\n    const query = 'replication'\n    await this.makeRequestAsyncOmit({ method, bucketName, query }, '', [200, 204], '')\n  }\n\n  setBucketReplication(bucketName: string, replicationConfig: ReplicationConfigOpts, callback: NoResultCallback): void\n  async setBucketReplication(bucketName: string, replicationConfig: ReplicationConfigOpts): Promise<void>\n  async setBucketReplication(bucketName: string, replicationConfig: ReplicationConfigOpts) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    if (!isObject(replicationConfig)) {\n      throw new errors.InvalidArgumentError('replicationConfig should be of type \"object\"')\n    } else {\n      if (_.isEmpty(replicationConfig.role)) {\n        throw new errors.InvalidArgumentError('Role cannot be empty')\n      } else if (replicationConfig.role && !isString(replicationConfig.role)) {\n        throw new errors.InvalidArgumentError('Invalid value for role', replicationConfig.role)\n      }\n      if (_.isEmpty(replicationConfig.rules)) {\n        throw new errors.InvalidArgumentError('Minimum one replication rule must be specified')\n      }\n    }\n    const method = 'PUT'\n    const query = 'replication'\n    const headers: Record<string, string> = {}\n\n    const replicationParamsConfig = {\n      ReplicationConfiguration: {\n        Role: replicationConfig.role,\n        Rule: replicationConfig.rules,\n      },\n    }\n\n    const builder = new xml2js.Builder({ renderOpts: { pretty: false }, headless: true })\n    const payload = builder.buildObject(replicationParamsConfig)\n    headers['Content-MD5'] = toMd5(payload)\n    await this.makeRequestAsyncOmit({ method, bucketName, query, headers }, payload)\n  }\n\n  getBucketReplication(bucketName: string, callback: ResultCallback<ReplicationConfig>): void\n  async getBucketReplication(bucketName: string): Promise<ReplicationConfig>\n  async getBucketReplication(bucketName: string) {\n    if (!isValidBucketName(bucketName)) {\n      throw new errors.InvalidBucketNameError('Invalid bucket name: ' + bucketName)\n    }\n    const method = 'GET'\n    const query = 'replication'\n\n    const httpRes = await this.makeRequestAsync({ method, bucketName, query }, '', [200, 204])\n    const xmlResult = await readAsString(httpRes)\n    return xmlParsers.parseReplicationConfig(xmlResult)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}