{"ast":null,"code":"/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport crc32 from 'buffer-crc32';\nimport { XMLParser } from 'fast-xml-parser';\nimport * as errors from \"./errors.mjs\";\nimport { SelectResults } from \"./helpers.mjs\";\nimport { isObject, parseXml, readableStream, sanitizeETag, sanitizeObjectKey, sanitizeSize, toArray } from \"./internal/helper.mjs\";\nimport { RETENTION_VALIDITY_UNITS } from \"./internal/type.mjs\";\nconst fxpWithoutNumParser = new XMLParser({\n  numberParseOptions: {\n    skipLike: /./\n  }\n});\n\n// parse XML response for copy object\nexport function parseCopyObject(xml) {\n  var result = {\n    etag: '',\n    lastModified: ''\n  };\n  var xmlobj = parseXml(xml);\n  if (!xmlobj.CopyObjectResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"CopyObjectResult\"');\n  }\n  xmlobj = xmlobj.CopyObjectResult;\n  if (xmlobj.ETag) {\n    result.etag = xmlobj.ETag.replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/&#34;$/g, '');\n  }\n  if (xmlobj.LastModified) {\n    result.lastModified = new Date(xmlobj.LastModified);\n  }\n  return result;\n}\n\n// parse XML response for listing in-progress multipart uploads\nexport function parseListMultipart(xml) {\n  var result = {\n    uploads: [],\n    prefixes: [],\n    isTruncated: false\n  };\n  var xmlobj = parseXml(xml);\n  if (!xmlobj.ListMultipartUploadsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListMultipartUploadsResult\"');\n  }\n  xmlobj = xmlobj.ListMultipartUploadsResult;\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated;\n  }\n  if (xmlobj.NextKeyMarker) {\n    result.nextKeyMarker = xmlobj.NextKeyMarker;\n  }\n  if (xmlobj.NextUploadIdMarker) {\n    result.nextUploadIdMarker = xmlobj.nextUploadIdMarker || '';\n  }\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach(prefix => {\n      result.prefixes.push({\n        prefix: sanitizeObjectKey(toArray(prefix.Prefix)[0])\n      });\n    });\n  }\n  if (xmlobj.Upload) {\n    toArray(xmlobj.Upload).forEach(upload => {\n      var key = upload.Key;\n      var uploadId = upload.UploadId;\n      var initiator = {\n        id: upload.Initiator.ID,\n        displayName: upload.Initiator.DisplayName\n      };\n      var owner = {\n        id: upload.Owner.ID,\n        displayName: upload.Owner.DisplayName\n      };\n      var storageClass = upload.StorageClass;\n      var initiated = new Date(upload.Initiated);\n      result.uploads.push({\n        key,\n        uploadId,\n        initiator,\n        owner,\n        storageClass,\n        initiated\n      });\n    });\n  }\n  return result;\n}\n\n// parse XML response to list all the owned buckets\n\n// parse XML response for bucket notification\nexport function parseBucketNotification(xml) {\n  var result = {\n    TopicConfiguration: [],\n    QueueConfiguration: [],\n    CloudFunctionConfiguration: []\n  };\n  // Parse the events list\n  var genEvents = function (events) {\n    var result = [];\n    if (events) {\n      toArray(events).forEach(s3event => {\n        result.push(s3event);\n      });\n    }\n    return result;\n  };\n  // Parse all filter rules\n  var genFilterRules = function (filters) {\n    var result = [];\n    if (filters) {\n      filters = toArray(filters);\n      if (filters[0].S3Key) {\n        filters[0].S3Key = toArray(filters[0].S3Key);\n        if (filters[0].S3Key[0].FilterRule) {\n          toArray(filters[0].S3Key[0].FilterRule).forEach(rule => {\n            var Name = toArray(rule.Name)[0];\n            var Value = toArray(rule.Value)[0];\n            result.push({\n              Name,\n              Value\n            });\n          });\n        }\n      }\n    }\n    return result;\n  };\n  var xmlobj = parseXml(xml);\n  xmlobj = xmlobj.NotificationConfiguration;\n\n  // Parse all topic configurations in the xml\n  if (xmlobj.TopicConfiguration) {\n    toArray(xmlobj.TopicConfiguration).forEach(config => {\n      var Id = toArray(config.Id)[0];\n      var Topic = toArray(config.Topic)[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.TopicConfiguration.push({\n        Id,\n        Topic,\n        Event,\n        Filter\n      });\n    });\n  }\n  // Parse all topic configurations in the xml\n  if (xmlobj.QueueConfiguration) {\n    toArray(xmlobj.QueueConfiguration).forEach(config => {\n      var Id = toArray(config.Id)[0];\n      var Queue = toArray(config.Queue)[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.QueueConfiguration.push({\n        Id,\n        Queue,\n        Event,\n        Filter\n      });\n    });\n  }\n  // Parse all QueueConfiguration arrays\n  if (xmlobj.CloudFunctionConfiguration) {\n    toArray(xmlobj.CloudFunctionConfiguration).forEach(config => {\n      var Id = toArray(config.Id)[0];\n      var CloudFunction = toArray(config.CloudFunction)[0];\n      var Event = genEvents(config.Event);\n      var Filter = genFilterRules(config.Filter);\n      result.CloudFunctionConfiguration.push({\n        Id,\n        CloudFunction,\n        Event,\n        Filter\n      });\n    });\n  }\n  return result;\n}\n\n// parse XML response when a multipart upload is completed\nexport function parseCompleteMultipart(xml) {\n  var xmlobj = parseXml(xml).CompleteMultipartUploadResult;\n  if (xmlobj.Location) {\n    var location = toArray(xmlobj.Location)[0];\n    var bucket = toArray(xmlobj.Bucket)[0];\n    var key = xmlobj.Key;\n    var etag = xmlobj.ETag.replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/&#34;$/g, '');\n    return {\n      location,\n      bucket,\n      key,\n      etag\n    };\n  }\n  // Complete Multipart can return XML Error after a 200 OK response\n  if (xmlobj.Code && xmlobj.Message) {\n    var errCode = toArray(xmlobj.Code)[0];\n    var errMessage = toArray(xmlobj.Message)[0];\n    return {\n      errCode,\n      errMessage\n    };\n  }\n}\nconst formatObjInfo = (content, opts = {}) => {\n  let {\n    Key,\n    LastModified,\n    ETag,\n    Size,\n    VersionId,\n    IsLatest\n  } = content;\n  if (!isObject(opts)) {\n    opts = {};\n  }\n  const name = sanitizeObjectKey(toArray(Key)[0]);\n  const lastModified = new Date(toArray(LastModified)[0]);\n  const etag = sanitizeETag(toArray(ETag)[0]);\n  const size = sanitizeSize(Size);\n  return {\n    name,\n    lastModified,\n    etag,\n    size,\n    versionId: VersionId,\n    isLatest: IsLatest,\n    isDeleteMarker: opts.IsDeleteMarker ? opts.IsDeleteMarker : false\n  };\n};\n\n// parse XML response for list objects in a bucket\nexport function parseListObjects(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false\n  };\n  let isTruncated = false;\n  let nextMarker, nextVersionKeyMarker;\n  const xmlobj = fxpWithoutNumParser.parse(xml);\n  const parseCommonPrefixesEntity = responseEntity => {\n    if (responseEntity) {\n      toArray(responseEntity).forEach(commonPrefix => {\n        result.objects.push({\n          prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),\n          size: 0\n        });\n      });\n    }\n  };\n  const listBucketResult = xmlobj.ListBucketResult;\n  const listVersionsResult = xmlobj.ListVersionsResult;\n  if (listBucketResult) {\n    if (listBucketResult.IsTruncated) {\n      isTruncated = listBucketResult.IsTruncated;\n    }\n    if (listBucketResult.Contents) {\n      toArray(listBucketResult.Contents).forEach(content => {\n        const name = sanitizeObjectKey(toArray(content.Key)[0]);\n        const lastModified = new Date(toArray(content.LastModified)[0]);\n        const etag = sanitizeETag(toArray(content.ETag)[0]);\n        const size = sanitizeSize(content.Size);\n        result.objects.push({\n          name,\n          lastModified,\n          etag,\n          size\n        });\n      });\n    }\n    if (listBucketResult.NextMarker) {\n      nextMarker = listBucketResult.NextMarker;\n    }\n    parseCommonPrefixesEntity(listBucketResult.CommonPrefixes);\n  }\n  if (listVersionsResult) {\n    if (listVersionsResult.IsTruncated) {\n      isTruncated = listVersionsResult.IsTruncated;\n    }\n    if (listVersionsResult.Version) {\n      toArray(listVersionsResult.Version).forEach(content => {\n        result.objects.push(formatObjInfo(content));\n      });\n    }\n    if (listVersionsResult.DeleteMarker) {\n      toArray(listVersionsResult.DeleteMarker).forEach(content => {\n        result.objects.push(formatObjInfo(content, {\n          IsDeleteMarker: true\n        }));\n      });\n    }\n    if (listVersionsResult.NextKeyMarker) {\n      nextVersionKeyMarker = listVersionsResult.NextKeyMarker;\n    }\n    if (listVersionsResult.NextVersionIdMarker) {\n      result.versionIdMarker = listVersionsResult.NextVersionIdMarker;\n    }\n    parseCommonPrefixesEntity(listVersionsResult.CommonPrefixes);\n  }\n  result.isTruncated = isTruncated;\n  if (isTruncated) {\n    result.nextMarker = nextVersionKeyMarker || nextMarker;\n  }\n  return result;\n}\n\n// parse XML response for list objects v2 in a bucket\nexport function parseListObjectsV2(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false\n  };\n  var xmlobj = parseXml(xml);\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"');\n  }\n  xmlobj = xmlobj.ListBucketResult;\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated;\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken;\n  }\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach(content => {\n      var name = sanitizeObjectKey(toArray(content.Key)[0]);\n      var lastModified = new Date(content.LastModified);\n      var etag = sanitizeETag(content.ETag);\n      var size = content.Size;\n      result.objects.push({\n        name,\n        lastModified,\n        etag,\n        size\n      });\n    });\n  }\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach(commonPrefix => {\n      result.objects.push({\n        prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),\n        size: 0\n      });\n    });\n  }\n  return result;\n}\n\n// parse XML response for list objects v2 with metadata in a bucket\nexport function parseListObjectsV2WithMetadata(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false\n  };\n  var xmlobj = parseXml(xml);\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"');\n  }\n  xmlobj = xmlobj.ListBucketResult;\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated;\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken;\n  }\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach(content => {\n      var name = sanitizeObjectKey(content.Key);\n      var lastModified = new Date(content.LastModified);\n      var etag = sanitizeETag(content.ETag);\n      var size = content.Size;\n      var metadata;\n      if (content.UserMetadata != null) {\n        metadata = toArray(content.UserMetadata)[0];\n      } else {\n        metadata = null;\n      }\n      result.objects.push({\n        name,\n        lastModified,\n        etag,\n        size,\n        metadata\n      });\n    });\n  }\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach(commonPrefix => {\n      result.objects.push({\n        prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),\n        size: 0\n      });\n    });\n  }\n  return result;\n}\nexport function parseBucketVersioningConfig(xml) {\n  var xmlObj = parseXml(xml);\n  return xmlObj.VersioningConfiguration;\n}\nexport function parseTagging(xml) {\n  const xmlObj = parseXml(xml);\n  let result = [];\n  if (xmlObj.Tagging && xmlObj.Tagging.TagSet && xmlObj.Tagging.TagSet.Tag) {\n    const tagResult = xmlObj.Tagging.TagSet.Tag;\n    // if it is a single tag convert into an array so that the return value is always an array.\n    if (isObject(tagResult)) {\n      result.push(tagResult);\n    } else {\n      result = tagResult;\n    }\n  }\n  return result;\n}\nexport function parseLifecycleConfig(xml) {\n  const xmlObj = parseXml(xml);\n  return xmlObj.LifecycleConfiguration;\n}\nexport function parseObjectLockConfig(xml) {\n  const xmlObj = parseXml(xml);\n  let lockConfigResult = {};\n  if (xmlObj.ObjectLockConfiguration) {\n    lockConfigResult = {\n      objectLockEnabled: xmlObj.ObjectLockConfiguration.ObjectLockEnabled\n    };\n    let retentionResp;\n    if (xmlObj.ObjectLockConfiguration && xmlObj.ObjectLockConfiguration.Rule && xmlObj.ObjectLockConfiguration.Rule.DefaultRetention) {\n      retentionResp = xmlObj.ObjectLockConfiguration.Rule.DefaultRetention || {};\n      lockConfigResult.mode = retentionResp.Mode;\n    }\n    if (retentionResp) {\n      const isUnitYears = retentionResp.Years;\n      if (isUnitYears) {\n        lockConfigResult.validity = isUnitYears;\n        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.YEARS;\n      } else {\n        lockConfigResult.validity = retentionResp.Days;\n        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.DAYS;\n      }\n    }\n    return lockConfigResult;\n  }\n}\nexport function parseObjectRetentionConfig(xml) {\n  const xmlObj = parseXml(xml);\n  const retentionConfig = xmlObj.Retention;\n  return {\n    mode: retentionConfig.Mode,\n    retainUntilDate: retentionConfig.RetainUntilDate\n  };\n}\nexport function parseBucketEncryptionConfig(xml) {\n  let encConfig = parseXml(xml);\n  return encConfig;\n}\nexport function parseObjectLegalHoldConfig(xml) {\n  const xmlObj = parseXml(xml);\n  return xmlObj.LegalHold;\n}\nexport function uploadPartParser(xml) {\n  const xmlObj = parseXml(xml);\n  const respEl = xmlObj.CopyPartResult;\n  return respEl;\n}\nexport function removeObjectsParser(xml) {\n  const xmlObj = parseXml(xml);\n  if (xmlObj.DeleteResult && xmlObj.DeleteResult.Error) {\n    // return errors as array always. as the response is object in case of single object passed in removeObjects\n    return toArray(xmlObj.DeleteResult.Error);\n  }\n  return [];\n}\nexport function parseSelectObjectContentResponse(res) {\n  // extractHeaderType extracts the first half of the header message, the header type.\n  function extractHeaderType(stream) {\n    const headerNameLen = Buffer.from(stream.read(1)).readUInt8();\n    const headerNameWithSeparator = Buffer.from(stream.read(headerNameLen)).toString();\n    const splitBySeparator = (headerNameWithSeparator || '').split(':');\n    const headerName = splitBySeparator.length >= 1 ? splitBySeparator[1] : '';\n    return headerName;\n  }\n  function extractHeaderValue(stream) {\n    const bodyLen = Buffer.from(stream.read(2)).readUInt16BE();\n    const bodyName = Buffer.from(stream.read(bodyLen)).toString();\n    return bodyName;\n  }\n  const selectResults = new SelectResults({}); // will be returned\n\n  const responseStream = readableStream(res); // convert byte array to a readable responseStream\n  while (responseStream._readableState.length) {\n    // Top level responseStream read tracker.\n    let msgCrcAccumulator; // accumulate from start of the message till the message crc start.\n\n    const totalByteLengthBuffer = Buffer.from(responseStream.read(4));\n    msgCrcAccumulator = crc32(totalByteLengthBuffer);\n    const headerBytesBuffer = Buffer.from(responseStream.read(4));\n    msgCrcAccumulator = crc32(headerBytesBuffer, msgCrcAccumulator);\n    const calculatedPreludeCrc = msgCrcAccumulator.readInt32BE(); // use it to check if any CRC mismatch in header itself.\n\n    const preludeCrcBuffer = Buffer.from(responseStream.read(4)); // read 4 bytes    i.e 4+4 =8 + 4 = 12 ( prelude + prelude crc)\n    msgCrcAccumulator = crc32(preludeCrcBuffer, msgCrcAccumulator);\n    const totalMsgLength = totalByteLengthBuffer.readInt32BE();\n    const headerLength = headerBytesBuffer.readInt32BE();\n    const preludeCrcByteValue = preludeCrcBuffer.readInt32BE();\n    if (preludeCrcByteValue !== calculatedPreludeCrc) {\n      // Handle Header CRC mismatch Error\n      throw new Error(`Header Checksum Mismatch, Prelude CRC of ${preludeCrcByteValue} does not equal expected CRC of ${calculatedPreludeCrc}`);\n    }\n    const headers = {};\n    if (headerLength > 0) {\n      const headerBytes = Buffer.from(responseStream.read(headerLength));\n      msgCrcAccumulator = crc32(headerBytes, msgCrcAccumulator);\n      const headerReaderStream = readableStream(headerBytes);\n      while (headerReaderStream._readableState.length) {\n        let headerTypeName = extractHeaderType(headerReaderStream);\n        headerReaderStream.read(1); // just read and ignore it.\n        headers[headerTypeName] = extractHeaderValue(headerReaderStream);\n      }\n    }\n    let payloadStream;\n    const payLoadLength = totalMsgLength - headerLength - 16;\n    if (payLoadLength > 0) {\n      const payLoadBuffer = Buffer.from(responseStream.read(payLoadLength));\n      msgCrcAccumulator = crc32(payLoadBuffer, msgCrcAccumulator);\n      // read the checksum early and detect any mismatch so we can avoid unnecessary further processing.\n      const messageCrcByteValue = Buffer.from(responseStream.read(4)).readInt32BE();\n      const calculatedCrc = msgCrcAccumulator.readInt32BE();\n      // Handle message CRC Error\n      if (messageCrcByteValue !== calculatedCrc) {\n        throw new Error(`Message Checksum Mismatch, Message CRC of ${messageCrcByteValue} does not equal expected CRC of ${calculatedCrc}`);\n      }\n      payloadStream = readableStream(payLoadBuffer);\n    }\n    const messageType = headers['message-type'];\n    switch (messageType) {\n      case 'error':\n        {\n          const errorMessage = headers['error-code'] + ':\"' + headers['error-message'] + '\"';\n          throw new Error(errorMessage);\n        }\n      case 'event':\n        {\n          const contentType = headers['content-type'];\n          const eventType = headers['event-type'];\n          switch (eventType) {\n            case 'End':\n              {\n                selectResults.setResponse(res);\n                return selectResults;\n              }\n            case 'Records':\n              {\n                const readData = payloadStream.read(payLoadLength);\n                selectResults.setRecords(readData);\n                break;\n              }\n            case 'Progress':\n              {\n                switch (contentType) {\n                  case 'text/xml':\n                    {\n                      const progressData = payloadStream.read(payLoadLength);\n                      selectResults.setProgress(progressData.toString());\n                      break;\n                    }\n                  default:\n                    {\n                      const errorMessage = `Unexpected content-type ${contentType} sent for event-type Progress`;\n                      throw new Error(errorMessage);\n                    }\n                }\n              }\n              break;\n            case 'Stats':\n              {\n                switch (contentType) {\n                  case 'text/xml':\n                    {\n                      const statsData = payloadStream.read(payLoadLength);\n                      selectResults.setStats(statsData.toString());\n                      break;\n                    }\n                  default:\n                    {\n                      const errorMessage = `Unexpected content-type ${contentType} sent for event-type Stats`;\n                      throw new Error(errorMessage);\n                    }\n                }\n              }\n              break;\n            default:\n              {\n                // Continuation message: Not sure if it is supported. did not find a reference or any message in response.\n                // It does not have a payload.\n                const warningMessage = `Un implemented event detected  ${messageType}.`;\n                // eslint-disable-next-line no-console\n                console.warn(warningMessage);\n              }\n          } // eventType End\n        }\n      // Event End\n    } // messageType End\n  } // Top Level Stream End\n}","map":{"version":3,"names":["crc32","XMLParser","errors","SelectResults","isObject","parseXml","readableStream","sanitizeETag","sanitizeObjectKey","sanitizeSize","toArray","RETENTION_VALIDITY_UNITS","fxpWithoutNumParser","numberParseOptions","skipLike","parseCopyObject","xml","result","etag","lastModified","xmlobj","CopyObjectResult","InvalidXMLError","ETag","replace","LastModified","Date","parseListMultipart","uploads","prefixes","isTruncated","ListMultipartUploadsResult","IsTruncated","NextKeyMarker","nextKeyMarker","NextUploadIdMarker","nextUploadIdMarker","CommonPrefixes","forEach","prefix","push","Prefix","Upload","upload","key","Key","uploadId","UploadId","initiator","id","Initiator","ID","displayName","DisplayName","owner","Owner","storageClass","StorageClass","initiated","Initiated","parseBucketNotification","TopicConfiguration","QueueConfiguration","CloudFunctionConfiguration","genEvents","events","s3event","genFilterRules","filters","S3Key","FilterRule","rule","Name","Value","NotificationConfiguration","config","Id","Topic","Event","Filter","Queue","CloudFunction","parseCompleteMultipart","CompleteMultipartUploadResult","Location","location","bucket","Bucket","Code","Message","errCode","errMessage","formatObjInfo","content","opts","Size","VersionId","IsLatest","name","size","versionId","isLatest","isDeleteMarker","IsDeleteMarker","parseListObjects","objects","nextMarker","nextVersionKeyMarker","parse","parseCommonPrefixesEntity","responseEntity","commonPrefix","listBucketResult","ListBucketResult","listVersionsResult","ListVersionsResult","Contents","NextMarker","Version","DeleteMarker","NextVersionIdMarker","versionIdMarker","parseListObjectsV2","NextContinuationToken","nextContinuationToken","parseListObjectsV2WithMetadata","metadata","UserMetadata","parseBucketVersioningConfig","xmlObj","VersioningConfiguration","parseTagging","Tagging","TagSet","Tag","tagResult","parseLifecycleConfig","LifecycleConfiguration","parseObjectLockConfig","lockConfigResult","ObjectLockConfiguration","objectLockEnabled","ObjectLockEnabled","retentionResp","Rule","DefaultRetention","mode","Mode","isUnitYears","Years","validity","unit","YEARS","Days","DAYS","parseObjectRetentionConfig","retentionConfig","Retention","retainUntilDate","RetainUntilDate","parseBucketEncryptionConfig","encConfig","parseObjectLegalHoldConfig","LegalHold","uploadPartParser","respEl","CopyPartResult","removeObjectsParser","DeleteResult","Error","parseSelectObjectContentResponse","res","extractHeaderType","stream","headerNameLen","Buffer","from","read","readUInt8","headerNameWithSeparator","toString","splitBySeparator","split","headerName","length","extractHeaderValue","bodyLen","readUInt16BE","bodyName","selectResults","responseStream","_readableState","msgCrcAccumulator","totalByteLengthBuffer","headerBytesBuffer","calculatedPreludeCrc","readInt32BE","preludeCrcBuffer","totalMsgLength","headerLength","preludeCrcByteValue","headers","headerBytes","headerReaderStream","headerTypeName","payloadStream","payLoadLength","payLoadBuffer","messageCrcByteValue","calculatedCrc","messageType","errorMessage","contentType","eventType","setResponse","readData","setRecords","progressData","setProgress","statsData","setStats","warningMessage","console","warn"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/xml-parsers.js"],"sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2015 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport crc32 from 'buffer-crc32'\nimport { XMLParser } from 'fast-xml-parser'\n\nimport * as errors from './errors.ts'\nimport { SelectResults } from './helpers.ts'\nimport {\n  isObject,\n  parseXml,\n  readableStream,\n  sanitizeETag,\n  sanitizeObjectKey,\n  sanitizeSize,\n  toArray,\n} from './internal/helper.ts'\nimport { RETENTION_VALIDITY_UNITS } from './internal/type.ts'\n\nconst fxpWithoutNumParser = new XMLParser({\n  numberParseOptions: {\n    skipLike: /./,\n  },\n})\n\n// parse XML response for copy object\nexport function parseCopyObject(xml) {\n  var result = {\n    etag: '',\n    lastModified: '',\n  }\n\n  var xmlobj = parseXml(xml)\n  if (!xmlobj.CopyObjectResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"CopyObjectResult\"')\n  }\n  xmlobj = xmlobj.CopyObjectResult\n  if (xmlobj.ETag) {\n    result.etag = xmlobj.ETag.replace(/^\"/g, '')\n      .replace(/\"$/g, '')\n      .replace(/^&quot;/g, '')\n      .replace(/&quot;$/g, '')\n      .replace(/^&#34;/g, '')\n      .replace(/&#34;$/g, '')\n  }\n  if (xmlobj.LastModified) {\n    result.lastModified = new Date(xmlobj.LastModified)\n  }\n\n  return result\n}\n\n// parse XML response for listing in-progress multipart uploads\nexport function parseListMultipart(xml) {\n  var result = {\n    uploads: [],\n    prefixes: [],\n    isTruncated: false,\n  }\n\n  var xmlobj = parseXml(xml)\n\n  if (!xmlobj.ListMultipartUploadsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListMultipartUploadsResult\"')\n  }\n  xmlobj = xmlobj.ListMultipartUploadsResult\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated\n  }\n  if (xmlobj.NextKeyMarker) {\n    result.nextKeyMarker = xmlobj.NextKeyMarker\n  }\n  if (xmlobj.NextUploadIdMarker) {\n    result.nextUploadIdMarker = xmlobj.nextUploadIdMarker || ''\n  }\n\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach((prefix) => {\n      result.prefixes.push({ prefix: sanitizeObjectKey(toArray(prefix.Prefix)[0]) })\n    })\n  }\n\n  if (xmlobj.Upload) {\n    toArray(xmlobj.Upload).forEach((upload) => {\n      var key = upload.Key\n      var uploadId = upload.UploadId\n      var initiator = { id: upload.Initiator.ID, displayName: upload.Initiator.DisplayName }\n      var owner = { id: upload.Owner.ID, displayName: upload.Owner.DisplayName }\n      var storageClass = upload.StorageClass\n      var initiated = new Date(upload.Initiated)\n      result.uploads.push({ key, uploadId, initiator, owner, storageClass, initiated })\n    })\n  }\n  return result\n}\n\n// parse XML response to list all the owned buckets\n\n// parse XML response for bucket notification\nexport function parseBucketNotification(xml) {\n  var result = {\n    TopicConfiguration: [],\n    QueueConfiguration: [],\n    CloudFunctionConfiguration: [],\n  }\n  // Parse the events list\n  var genEvents = function (events) {\n    var result = []\n    if (events) {\n      toArray(events).forEach((s3event) => {\n        result.push(s3event)\n      })\n    }\n    return result\n  }\n  // Parse all filter rules\n  var genFilterRules = function (filters) {\n    var result = []\n    if (filters) {\n      filters = toArray(filters)\n      if (filters[0].S3Key) {\n        filters[0].S3Key = toArray(filters[0].S3Key)\n        if (filters[0].S3Key[0].FilterRule) {\n          toArray(filters[0].S3Key[0].FilterRule).forEach((rule) => {\n            var Name = toArray(rule.Name)[0]\n            var Value = toArray(rule.Value)[0]\n            result.push({ Name, Value })\n          })\n        }\n      }\n    }\n    return result\n  }\n\n  var xmlobj = parseXml(xml)\n  xmlobj = xmlobj.NotificationConfiguration\n\n  // Parse all topic configurations in the xml\n  if (xmlobj.TopicConfiguration) {\n    toArray(xmlobj.TopicConfiguration).forEach((config) => {\n      var Id = toArray(config.Id)[0]\n      var Topic = toArray(config.Topic)[0]\n      var Event = genEvents(config.Event)\n      var Filter = genFilterRules(config.Filter)\n      result.TopicConfiguration.push({ Id, Topic, Event, Filter })\n    })\n  }\n  // Parse all topic configurations in the xml\n  if (xmlobj.QueueConfiguration) {\n    toArray(xmlobj.QueueConfiguration).forEach((config) => {\n      var Id = toArray(config.Id)[0]\n      var Queue = toArray(config.Queue)[0]\n      var Event = genEvents(config.Event)\n      var Filter = genFilterRules(config.Filter)\n      result.QueueConfiguration.push({ Id, Queue, Event, Filter })\n    })\n  }\n  // Parse all QueueConfiguration arrays\n  if (xmlobj.CloudFunctionConfiguration) {\n    toArray(xmlobj.CloudFunctionConfiguration).forEach((config) => {\n      var Id = toArray(config.Id)[0]\n      var CloudFunction = toArray(config.CloudFunction)[0]\n      var Event = genEvents(config.Event)\n      var Filter = genFilterRules(config.Filter)\n      result.CloudFunctionConfiguration.push({ Id, CloudFunction, Event, Filter })\n    })\n  }\n\n  return result\n}\n\n// parse XML response when a multipart upload is completed\nexport function parseCompleteMultipart(xml) {\n  var xmlobj = parseXml(xml).CompleteMultipartUploadResult\n  if (xmlobj.Location) {\n    var location = toArray(xmlobj.Location)[0]\n    var bucket = toArray(xmlobj.Bucket)[0]\n    var key = xmlobj.Key\n    var etag = xmlobj.ETag.replace(/^\"/g, '')\n      .replace(/\"$/g, '')\n      .replace(/^&quot;/g, '')\n      .replace(/&quot;$/g, '')\n      .replace(/^&#34;/g, '')\n      .replace(/&#34;$/g, '')\n\n    return { location, bucket, key, etag }\n  }\n  // Complete Multipart can return XML Error after a 200 OK response\n  if (xmlobj.Code && xmlobj.Message) {\n    var errCode = toArray(xmlobj.Code)[0]\n    var errMessage = toArray(xmlobj.Message)[0]\n    return { errCode, errMessage }\n  }\n}\n\nconst formatObjInfo = (content, opts = {}) => {\n  let { Key, LastModified, ETag, Size, VersionId, IsLatest } = content\n\n  if (!isObject(opts)) {\n    opts = {}\n  }\n\n  const name = sanitizeObjectKey(toArray(Key)[0])\n  const lastModified = new Date(toArray(LastModified)[0])\n  const etag = sanitizeETag(toArray(ETag)[0])\n  const size = sanitizeSize(Size)\n\n  return {\n    name,\n    lastModified,\n    etag,\n    size,\n    versionId: VersionId,\n    isLatest: IsLatest,\n    isDeleteMarker: opts.IsDeleteMarker ? opts.IsDeleteMarker : false,\n  }\n}\n\n// parse XML response for list objects in a bucket\nexport function parseListObjects(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false,\n  }\n  let isTruncated = false\n  let nextMarker, nextVersionKeyMarker\n  const xmlobj = fxpWithoutNumParser.parse(xml)\n\n  const parseCommonPrefixesEntity = (responseEntity) => {\n    if (responseEntity) {\n      toArray(responseEntity).forEach((commonPrefix) => {\n        result.objects.push({ prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]), size: 0 })\n      })\n    }\n  }\n\n  const listBucketResult = xmlobj.ListBucketResult\n  const listVersionsResult = xmlobj.ListVersionsResult\n\n  if (listBucketResult) {\n    if (listBucketResult.IsTruncated) {\n      isTruncated = listBucketResult.IsTruncated\n    }\n    if (listBucketResult.Contents) {\n      toArray(listBucketResult.Contents).forEach((content) => {\n        const name = sanitizeObjectKey(toArray(content.Key)[0])\n        const lastModified = new Date(toArray(content.LastModified)[0])\n        const etag = sanitizeETag(toArray(content.ETag)[0])\n        const size = sanitizeSize(content.Size)\n        result.objects.push({ name, lastModified, etag, size })\n      })\n    }\n\n    if (listBucketResult.NextMarker) {\n      nextMarker = listBucketResult.NextMarker\n    }\n    parseCommonPrefixesEntity(listBucketResult.CommonPrefixes)\n  }\n\n  if (listVersionsResult) {\n    if (listVersionsResult.IsTruncated) {\n      isTruncated = listVersionsResult.IsTruncated\n    }\n\n    if (listVersionsResult.Version) {\n      toArray(listVersionsResult.Version).forEach((content) => {\n        result.objects.push(formatObjInfo(content))\n      })\n    }\n    if (listVersionsResult.DeleteMarker) {\n      toArray(listVersionsResult.DeleteMarker).forEach((content) => {\n        result.objects.push(formatObjInfo(content, { IsDeleteMarker: true }))\n      })\n    }\n\n    if (listVersionsResult.NextKeyMarker) {\n      nextVersionKeyMarker = listVersionsResult.NextKeyMarker\n    }\n    if (listVersionsResult.NextVersionIdMarker) {\n      result.versionIdMarker = listVersionsResult.NextVersionIdMarker\n    }\n    parseCommonPrefixesEntity(listVersionsResult.CommonPrefixes)\n  }\n\n  result.isTruncated = isTruncated\n  if (isTruncated) {\n    result.nextMarker = nextVersionKeyMarker || nextMarker\n  }\n  return result\n}\n\n// parse XML response for list objects v2 in a bucket\nexport function parseListObjectsV2(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false,\n  }\n  var xmlobj = parseXml(xml)\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"')\n  }\n  xmlobj = xmlobj.ListBucketResult\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken\n  }\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach((content) => {\n      var name = sanitizeObjectKey(toArray(content.Key)[0])\n      var lastModified = new Date(content.LastModified)\n      var etag = sanitizeETag(content.ETag)\n      var size = content.Size\n      result.objects.push({ name, lastModified, etag, size })\n    })\n  }\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach((commonPrefix) => {\n      result.objects.push({ prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]), size: 0 })\n    })\n  }\n  return result\n}\n\n// parse XML response for list objects v2 with metadata in a bucket\nexport function parseListObjectsV2WithMetadata(xml) {\n  var result = {\n    objects: [],\n    isTruncated: false,\n  }\n  var xmlobj = parseXml(xml)\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"')\n  }\n  xmlobj = xmlobj.ListBucketResult\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken\n  }\n\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach((content) => {\n      var name = sanitizeObjectKey(content.Key)\n      var lastModified = new Date(content.LastModified)\n      var etag = sanitizeETag(content.ETag)\n      var size = content.Size\n      var metadata\n      if (content.UserMetadata != null) {\n        metadata = toArray(content.UserMetadata)[0]\n      } else {\n        metadata = null\n      }\n      result.objects.push({ name, lastModified, etag, size, metadata })\n    })\n  }\n\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach((commonPrefix) => {\n      result.objects.push({ prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]), size: 0 })\n    })\n  }\n  return result\n}\n\nexport function parseBucketVersioningConfig(xml) {\n  var xmlObj = parseXml(xml)\n  return xmlObj.VersioningConfiguration\n}\n\nexport function parseTagging(xml) {\n  const xmlObj = parseXml(xml)\n  let result = []\n  if (xmlObj.Tagging && xmlObj.Tagging.TagSet && xmlObj.Tagging.TagSet.Tag) {\n    const tagResult = xmlObj.Tagging.TagSet.Tag\n    // if it is a single tag convert into an array so that the return value is always an array.\n    if (isObject(tagResult)) {\n      result.push(tagResult)\n    } else {\n      result = tagResult\n    }\n  }\n  return result\n}\n\nexport function parseLifecycleConfig(xml) {\n  const xmlObj = parseXml(xml)\n  return xmlObj.LifecycleConfiguration\n}\n\nexport function parseObjectLockConfig(xml) {\n  const xmlObj = parseXml(xml)\n  let lockConfigResult = {}\n  if (xmlObj.ObjectLockConfiguration) {\n    lockConfigResult = {\n      objectLockEnabled: xmlObj.ObjectLockConfiguration.ObjectLockEnabled,\n    }\n    let retentionResp\n    if (\n      xmlObj.ObjectLockConfiguration &&\n      xmlObj.ObjectLockConfiguration.Rule &&\n      xmlObj.ObjectLockConfiguration.Rule.DefaultRetention\n    ) {\n      retentionResp = xmlObj.ObjectLockConfiguration.Rule.DefaultRetention || {}\n      lockConfigResult.mode = retentionResp.Mode\n    }\n    if (retentionResp) {\n      const isUnitYears = retentionResp.Years\n      if (isUnitYears) {\n        lockConfigResult.validity = isUnitYears\n        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.YEARS\n      } else {\n        lockConfigResult.validity = retentionResp.Days\n        lockConfigResult.unit = RETENTION_VALIDITY_UNITS.DAYS\n      }\n    }\n    return lockConfigResult\n  }\n}\n\nexport function parseObjectRetentionConfig(xml) {\n  const xmlObj = parseXml(xml)\n  const retentionConfig = xmlObj.Retention\n\n  return {\n    mode: retentionConfig.Mode,\n    retainUntilDate: retentionConfig.RetainUntilDate,\n  }\n}\n\nexport function parseBucketEncryptionConfig(xml) {\n  let encConfig = parseXml(xml)\n  return encConfig\n}\n\nexport function parseObjectLegalHoldConfig(xml) {\n  const xmlObj = parseXml(xml)\n  return xmlObj.LegalHold\n}\n\nexport function uploadPartParser(xml) {\n  const xmlObj = parseXml(xml)\n  const respEl = xmlObj.CopyPartResult\n  return respEl\n}\n\nexport function removeObjectsParser(xml) {\n  const xmlObj = parseXml(xml)\n  if (xmlObj.DeleteResult && xmlObj.DeleteResult.Error) {\n    // return errors as array always. as the response is object in case of single object passed in removeObjects\n    return toArray(xmlObj.DeleteResult.Error)\n  }\n  return []\n}\n\nexport function parseSelectObjectContentResponse(res) {\n  // extractHeaderType extracts the first half of the header message, the header type.\n  function extractHeaderType(stream) {\n    const headerNameLen = Buffer.from(stream.read(1)).readUInt8()\n    const headerNameWithSeparator = Buffer.from(stream.read(headerNameLen)).toString()\n    const splitBySeparator = (headerNameWithSeparator || '').split(':')\n    const headerName = splitBySeparator.length >= 1 ? splitBySeparator[1] : ''\n    return headerName\n  }\n\n  function extractHeaderValue(stream) {\n    const bodyLen = Buffer.from(stream.read(2)).readUInt16BE()\n    const bodyName = Buffer.from(stream.read(bodyLen)).toString()\n    return bodyName\n  }\n\n  const selectResults = new SelectResults({}) // will be returned\n\n  const responseStream = readableStream(res) // convert byte array to a readable responseStream\n  while (responseStream._readableState.length) {\n    // Top level responseStream read tracker.\n    let msgCrcAccumulator // accumulate from start of the message till the message crc start.\n\n    const totalByteLengthBuffer = Buffer.from(responseStream.read(4))\n    msgCrcAccumulator = crc32(totalByteLengthBuffer)\n\n    const headerBytesBuffer = Buffer.from(responseStream.read(4))\n    msgCrcAccumulator = crc32(headerBytesBuffer, msgCrcAccumulator)\n\n    const calculatedPreludeCrc = msgCrcAccumulator.readInt32BE() // use it to check if any CRC mismatch in header itself.\n\n    const preludeCrcBuffer = Buffer.from(responseStream.read(4)) // read 4 bytes    i.e 4+4 =8 + 4 = 12 ( prelude + prelude crc)\n    msgCrcAccumulator = crc32(preludeCrcBuffer, msgCrcAccumulator)\n\n    const totalMsgLength = totalByteLengthBuffer.readInt32BE()\n    const headerLength = headerBytesBuffer.readInt32BE()\n    const preludeCrcByteValue = preludeCrcBuffer.readInt32BE()\n\n    if (preludeCrcByteValue !== calculatedPreludeCrc) {\n      // Handle Header CRC mismatch Error\n      throw new Error(\n        `Header Checksum Mismatch, Prelude CRC of ${preludeCrcByteValue} does not equal expected CRC of ${calculatedPreludeCrc}`,\n      )\n    }\n\n    const headers = {}\n    if (headerLength > 0) {\n      const headerBytes = Buffer.from(responseStream.read(headerLength))\n      msgCrcAccumulator = crc32(headerBytes, msgCrcAccumulator)\n      const headerReaderStream = readableStream(headerBytes)\n      while (headerReaderStream._readableState.length) {\n        let headerTypeName = extractHeaderType(headerReaderStream)\n        headerReaderStream.read(1) // just read and ignore it.\n        headers[headerTypeName] = extractHeaderValue(headerReaderStream)\n      }\n    }\n\n    let payloadStream\n    const payLoadLength = totalMsgLength - headerLength - 16\n    if (payLoadLength > 0) {\n      const payLoadBuffer = Buffer.from(responseStream.read(payLoadLength))\n      msgCrcAccumulator = crc32(payLoadBuffer, msgCrcAccumulator)\n      // read the checksum early and detect any mismatch so we can avoid unnecessary further processing.\n      const messageCrcByteValue = Buffer.from(responseStream.read(4)).readInt32BE()\n      const calculatedCrc = msgCrcAccumulator.readInt32BE()\n      // Handle message CRC Error\n      if (messageCrcByteValue !== calculatedCrc) {\n        throw new Error(\n          `Message Checksum Mismatch, Message CRC of ${messageCrcByteValue} does not equal expected CRC of ${calculatedCrc}`,\n        )\n      }\n      payloadStream = readableStream(payLoadBuffer)\n    }\n\n    const messageType = headers['message-type']\n\n    switch (messageType) {\n      case 'error': {\n        const errorMessage = headers['error-code'] + ':\"' + headers['error-message'] + '\"'\n        throw new Error(errorMessage)\n      }\n      case 'event': {\n        const contentType = headers['content-type']\n        const eventType = headers['event-type']\n\n        switch (eventType) {\n          case 'End': {\n            selectResults.setResponse(res)\n            return selectResults\n          }\n\n          case 'Records': {\n            const readData = payloadStream.read(payLoadLength)\n            selectResults.setRecords(readData)\n            break\n          }\n\n          case 'Progress':\n            {\n              switch (contentType) {\n                case 'text/xml': {\n                  const progressData = payloadStream.read(payLoadLength)\n                  selectResults.setProgress(progressData.toString())\n                  break\n                }\n                default: {\n                  const errorMessage = `Unexpected content-type ${contentType} sent for event-type Progress`\n                  throw new Error(errorMessage)\n                }\n              }\n            }\n            break\n          case 'Stats':\n            {\n              switch (contentType) {\n                case 'text/xml': {\n                  const statsData = payloadStream.read(payLoadLength)\n                  selectResults.setStats(statsData.toString())\n                  break\n                }\n                default: {\n                  const errorMessage = `Unexpected content-type ${contentType} sent for event-type Stats`\n                  throw new Error(errorMessage)\n                }\n              }\n            }\n            break\n          default: {\n            // Continuation message: Not sure if it is supported. did not find a reference or any message in response.\n            // It does not have a payload.\n            const warningMessage = `Un implemented event detected  ${messageType}.`\n            // eslint-disable-next-line no-console\n            console.warn(warningMessage)\n          }\n        } // eventType End\n      } // Event End\n    } // messageType End\n  } // Top Level Stream End\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}