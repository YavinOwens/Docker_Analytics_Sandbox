{"ast":null,"code":"import { XMLParser } from 'fast-xml-parser';\nimport * as errors from \"../errors.mjs\";\nimport { parseXml, sanitizeETag, sanitizeObjectKey, toArray } from \"./helper.mjs\";\nimport { readAsString } from \"./response.mjs\";\n// parse XML response for bucket region\nexport function parseBucketRegion(xml) {\n  // return region information\n  return parseXml(xml).LocationConstraint;\n}\nconst fxp = new XMLParser();\n\n// Parse XML and return information as Javascript types\n// parse error XML response\nexport function parseError(xml, headerInfo) {\n  let xmlErr = {};\n  const xmlObj = fxp.parse(xml);\n  if (xmlObj.Error) {\n    xmlErr = xmlObj.Error;\n  }\n  const e = new errors.S3Error();\n  Object.entries(xmlErr).forEach(([key, value]) => {\n    e[key.toLowerCase()] = value;\n  });\n  Object.entries(headerInfo).forEach(([key, value]) => {\n    e[key] = value;\n  });\n  return e;\n}\n\n// Generates an Error object depending on http statusCode and XML body\nexport async function parseResponseError(response) {\n  const statusCode = response.statusCode;\n  let code, message;\n  if (statusCode === 301) {\n    code = 'MovedPermanently';\n    message = 'Moved Permanently';\n  } else if (statusCode === 307) {\n    code = 'TemporaryRedirect';\n    message = 'Are you using the correct endpoint URL?';\n  } else if (statusCode === 403) {\n    code = 'AccessDenied';\n    message = 'Valid and authorized credentials required';\n  } else if (statusCode === 404) {\n    code = 'NotFound';\n    message = 'Not Found';\n  } else if (statusCode === 405) {\n    code = 'MethodNotAllowed';\n    message = 'Method Not Allowed';\n  } else if (statusCode === 501) {\n    code = 'MethodNotAllowed';\n    message = 'Method Not Allowed';\n  } else {\n    code = 'UnknownError';\n    message = `${statusCode}`;\n  }\n  const headerInfo = {};\n  // A value created by S3 compatible server that uniquely identifies the request.\n  headerInfo.amzRequestid = response.headers['x-amz-request-id'];\n  // A special token that helps troubleshoot API replies and issues.\n  headerInfo.amzId2 = response.headers['x-amz-id-2'];\n\n  // Region where the bucket is located. This header is returned only\n  // in HEAD bucket and ListObjects response.\n  headerInfo.amzBucketRegion = response.headers['x-amz-bucket-region'];\n  const xmlString = await readAsString(response);\n  if (xmlString) {\n    throw parseError(xmlString, headerInfo);\n  }\n\n  // Message should be instantiated for each S3Errors.\n  const e = new errors.S3Error(message, {\n    cause: headerInfo\n  });\n  // S3 Error code.\n  e.code = code;\n  Object.entries(headerInfo).forEach(([key, value]) => {\n    // @ts-expect-error force set error properties\n    e[key] = value;\n  });\n  throw e;\n}\n\n/**\n * parse XML response for list objects v2 with metadata in a bucket\n */\nexport function parseListObjectsV2WithMetadata(xml) {\n  const result = {\n    objects: [],\n    isTruncated: false,\n    nextContinuationToken: ''\n  };\n  let xmlobj = parseXml(xml);\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"');\n  }\n  xmlobj = xmlobj.ListBucketResult;\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated;\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken;\n  }\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach(content => {\n      const name = sanitizeObjectKey(content.Key);\n      const lastModified = new Date(content.LastModified);\n      const etag = sanitizeETag(content.ETag);\n      const size = content.Size;\n      let metadata;\n      if (content.UserMetadata != null) {\n        metadata = toArray(content.UserMetadata)[0];\n      } else {\n        metadata = null;\n      }\n      result.objects.push({\n        name,\n        lastModified,\n        etag,\n        size,\n        metadata\n      });\n    });\n  }\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach(commonPrefix => {\n      result.objects.push({\n        prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]),\n        size: 0\n      });\n    });\n  }\n  return result;\n}\n// parse XML response for list parts of an in progress multipart upload\nexport function parseListParts(xml) {\n  let xmlobj = parseXml(xml);\n  const result = {\n    isTruncated: false,\n    parts: [],\n    marker: 0\n  };\n  if (!xmlobj.ListPartsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListPartsResult\"');\n  }\n  xmlobj = xmlobj.ListPartsResult;\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated;\n  }\n  if (xmlobj.NextPartNumberMarker) {\n    result.marker = toArray(xmlobj.NextPartNumberMarker)[0] || '';\n  }\n  if (xmlobj.Part) {\n    toArray(xmlobj.Part).forEach(p => {\n      const part = parseInt(toArray(p.PartNumber)[0], 10);\n      const lastModified = new Date(p.LastModified);\n      const etag = p.ETag.replace(/^\"/g, '').replace(/\"$/g, '').replace(/^&quot;/g, '').replace(/&quot;$/g, '').replace(/^&#34;/g, '').replace(/&#34;$/g, '');\n      result.parts.push({\n        part,\n        lastModified,\n        etag,\n        size: parseInt(p.Size, 10)\n      });\n    });\n  }\n  return result;\n}\nexport function parseListBucket(xml) {\n  let result = [];\n  const parsedXmlRes = parseXml(xml);\n  if (!parsedXmlRes.ListAllMyBucketsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListAllMyBucketsResult\"');\n  }\n  const {\n    ListAllMyBucketsResult: {\n      Buckets = {}\n    } = {}\n  } = parsedXmlRes;\n  if (Buckets.Bucket) {\n    result = toArray(Buckets.Bucket).map((bucket = {}) => {\n      const {\n        Name: bucketName,\n        CreationDate\n      } = bucket;\n      const creationDate = new Date(CreationDate);\n      return {\n        name: bucketName,\n        creationDate: creationDate\n      };\n    });\n  }\n  return result;\n}\nexport function parseInitiateMultipart(xml) {\n  let xmlobj = parseXml(xml);\n  if (!xmlobj.InitiateMultipartUploadResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"InitiateMultipartUploadResult\"');\n  }\n  xmlobj = xmlobj.InitiateMultipartUploadResult;\n  if (xmlobj.UploadId) {\n    return xmlobj.UploadId;\n  }\n  throw new errors.InvalidXMLError('Missing tag: \"UploadId\"');\n}\nexport function parseReplicationConfig(xml) {\n  const xmlObj = parseXml(xml);\n  const {\n    Role,\n    Rule\n  } = xmlObj.ReplicationConfiguration;\n  return {\n    ReplicationConfiguration: {\n      role: Role,\n      rules: toArray(Rule)\n    }\n  };\n}","map":{"version":3,"names":["XMLParser","errors","parseXml","sanitizeETag","sanitizeObjectKey","toArray","readAsString","parseBucketRegion","xml","LocationConstraint","fxp","parseError","headerInfo","xmlErr","xmlObj","parse","Error","e","S3Error","Object","entries","forEach","key","value","toLowerCase","parseResponseError","response","statusCode","code","message","amzRequestid","headers","amzId2","amzBucketRegion","xmlString","cause","parseListObjectsV2WithMetadata","result","objects","isTruncated","nextContinuationToken","xmlobj","ListBucketResult","InvalidXMLError","IsTruncated","NextContinuationToken","Contents","content","name","Key","lastModified","Date","LastModified","etag","ETag","size","Size","metadata","UserMetadata","push","CommonPrefixes","commonPrefix","prefix","Prefix","parseListParts","parts","marker","ListPartsResult","NextPartNumberMarker","Part","p","part","parseInt","PartNumber","replace","parseListBucket","parsedXmlRes","ListAllMyBucketsResult","Buckets","Bucket","map","bucket","Name","bucketName","CreationDate","creationDate","parseInitiateMultipart","InitiateMultipartUploadResult","UploadId","parseReplicationConfig","Role","Rule","ReplicationConfiguration","role","rules"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/internal/xml-parser.ts"],"sourcesContent":["import type * as http from 'node:http'\n\nimport { XMLParser } from 'fast-xml-parser'\n\nimport * as errors from '../errors.ts'\nimport { parseXml, sanitizeETag, sanitizeObjectKey, toArray } from './helper.ts'\nimport { readAsString } from './response.ts'\nimport type { BucketItemFromList, BucketItemWithMetadata, ReplicationConfig } from './type.ts'\n\n// parse XML response for bucket region\nexport function parseBucketRegion(xml: string): string {\n  // return region information\n  return parseXml(xml).LocationConstraint\n}\n\nconst fxp = new XMLParser()\n\n// Parse XML and return information as Javascript types\n// parse error XML response\nexport function parseError(xml: string, headerInfo: Record<string, unknown>) {\n  let xmlErr = {}\n  const xmlObj = fxp.parse(xml)\n  if (xmlObj.Error) {\n    xmlErr = xmlObj.Error\n  }\n  const e = new errors.S3Error() as unknown as Record<string, unknown>\n  Object.entries(xmlErr).forEach(([key, value]) => {\n    e[key.toLowerCase()] = value\n  })\n  Object.entries(headerInfo).forEach(([key, value]) => {\n    e[key] = value\n  })\n  return e\n}\n\n// Generates an Error object depending on http statusCode and XML body\nexport async function parseResponseError(response: http.IncomingMessage) {\n  const statusCode = response.statusCode\n  let code: string, message: string\n  if (statusCode === 301) {\n    code = 'MovedPermanently'\n    message = 'Moved Permanently'\n  } else if (statusCode === 307) {\n    code = 'TemporaryRedirect'\n    message = 'Are you using the correct endpoint URL?'\n  } else if (statusCode === 403) {\n    code = 'AccessDenied'\n    message = 'Valid and authorized credentials required'\n  } else if (statusCode === 404) {\n    code = 'NotFound'\n    message = 'Not Found'\n  } else if (statusCode === 405) {\n    code = 'MethodNotAllowed'\n    message = 'Method Not Allowed'\n  } else if (statusCode === 501) {\n    code = 'MethodNotAllowed'\n    message = 'Method Not Allowed'\n  } else {\n    code = 'UnknownError'\n    message = `${statusCode}`\n  }\n  const headerInfo: Record<string, string | undefined | null> = {}\n  // A value created by S3 compatible server that uniquely identifies the request.\n  headerInfo.amzRequestid = response.headers['x-amz-request-id'] as string | undefined\n  // A special token that helps troubleshoot API replies and issues.\n  headerInfo.amzId2 = response.headers['x-amz-id-2'] as string | undefined\n\n  // Region where the bucket is located. This header is returned only\n  // in HEAD bucket and ListObjects response.\n  headerInfo.amzBucketRegion = response.headers['x-amz-bucket-region'] as string | undefined\n\n  const xmlString = await readAsString(response)\n\n  if (xmlString) {\n    throw parseError(xmlString, headerInfo)\n  }\n\n  // Message should be instantiated for each S3Errors.\n  const e = new errors.S3Error(message, { cause: headerInfo })\n  // S3 Error code.\n  e.code = code\n  Object.entries(headerInfo).forEach(([key, value]) => {\n    // @ts-expect-error force set error properties\n    e[key] = value\n  })\n\n  throw e\n}\n\n/**\n * parse XML response for list objects v2 with metadata in a bucket\n */\nexport function parseListObjectsV2WithMetadata(xml: string) {\n  const result: {\n    objects: Array<BucketItemWithMetadata>\n    isTruncated: boolean\n    nextContinuationToken: string\n  } = {\n    objects: [],\n    isTruncated: false,\n    nextContinuationToken: '',\n  }\n\n  let xmlobj = parseXml(xml)\n  if (!xmlobj.ListBucketResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListBucketResult\"')\n  }\n  xmlobj = xmlobj.ListBucketResult\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated\n  }\n  if (xmlobj.NextContinuationToken) {\n    result.nextContinuationToken = xmlobj.NextContinuationToken\n  }\n\n  if (xmlobj.Contents) {\n    toArray(xmlobj.Contents).forEach((content) => {\n      const name = sanitizeObjectKey(content.Key)\n      const lastModified = new Date(content.LastModified)\n      const etag = sanitizeETag(content.ETag)\n      const size = content.Size\n      let metadata\n      if (content.UserMetadata != null) {\n        metadata = toArray(content.UserMetadata)[0]\n      } else {\n        metadata = null\n      }\n      result.objects.push({ name, lastModified, etag, size, metadata })\n    })\n  }\n\n  if (xmlobj.CommonPrefixes) {\n    toArray(xmlobj.CommonPrefixes).forEach((commonPrefix) => {\n      result.objects.push({ prefix: sanitizeObjectKey(toArray(commonPrefix.Prefix)[0]), size: 0 })\n    })\n  }\n  return result\n}\n\nexport type Multipart = {\n  uploads: Array<{\n    key: string\n    uploadId: string\n    initiator: unknown\n    owner: unknown\n    storageClass: unknown\n    initiated: unknown\n  }>\n  prefixes: { prefix: string }[]\n  isTruncated: boolean\n  nextKeyMarker: undefined\n  nextUploadIdMarker: undefined\n}\n\nexport type UploadedPart = {\n  part: number\n  lastModified?: Date\n  etag: string\n  size: number\n}\n\n// parse XML response for list parts of an in progress multipart upload\nexport function parseListParts(xml: string): {\n  isTruncated: boolean\n  marker: number\n  parts: UploadedPart[]\n} {\n  let xmlobj = parseXml(xml)\n  const result: { isTruncated: boolean; marker: number; parts: UploadedPart[] } = {\n    isTruncated: false,\n    parts: [],\n    marker: 0,\n  }\n  if (!xmlobj.ListPartsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListPartsResult\"')\n  }\n  xmlobj = xmlobj.ListPartsResult\n  if (xmlobj.IsTruncated) {\n    result.isTruncated = xmlobj.IsTruncated\n  }\n  if (xmlobj.NextPartNumberMarker) {\n    result.marker = toArray(xmlobj.NextPartNumberMarker)[0] || ''\n  }\n  if (xmlobj.Part) {\n    toArray(xmlobj.Part).forEach((p) => {\n      const part = parseInt(toArray(p.PartNumber)[0], 10)\n      const lastModified = new Date(p.LastModified)\n      const etag = p.ETag.replace(/^\"/g, '')\n        .replace(/\"$/g, '')\n        .replace(/^&quot;/g, '')\n        .replace(/&quot;$/g, '')\n        .replace(/^&#34;/g, '')\n        .replace(/&#34;$/g, '')\n      result.parts.push({ part, lastModified, etag, size: parseInt(p.Size, 10) })\n    })\n  }\n  return result\n}\n\nexport function parseListBucket(xml: string) {\n  let result: BucketItemFromList[] = []\n  const parsedXmlRes = parseXml(xml)\n\n  if (!parsedXmlRes.ListAllMyBucketsResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"ListAllMyBucketsResult\"')\n  }\n  const { ListAllMyBucketsResult: { Buckets = {} } = {} } = parsedXmlRes\n\n  if (Buckets.Bucket) {\n    result = toArray(Buckets.Bucket).map((bucket = {}) => {\n      const { Name: bucketName, CreationDate } = bucket\n      const creationDate = new Date(CreationDate)\n\n      return { name: bucketName, creationDate: creationDate }\n    })\n  }\n  return result\n}\n\nexport function parseInitiateMultipart(xml: string): string {\n  let xmlobj = parseXml(xml)\n\n  if (!xmlobj.InitiateMultipartUploadResult) {\n    throw new errors.InvalidXMLError('Missing tag: \"InitiateMultipartUploadResult\"')\n  }\n  xmlobj = xmlobj.InitiateMultipartUploadResult\n\n  if (xmlobj.UploadId) {\n    return xmlobj.UploadId\n  }\n  throw new errors.InvalidXMLError('Missing tag: \"UploadId\"')\n}\n\nexport function parseReplicationConfig(xml: string): ReplicationConfig {\n  const xmlObj = parseXml(xml)\n  const { Role, Rule } = xmlObj.ReplicationConfiguration\n  return {\n    ReplicationConfiguration: {\n      role: Role,\n      rules: toArray(Rule),\n    },\n  }\n}\n"],"mappings":"AAEA,SAASA,SAAS,QAAQ,iBAAiB;AAE3C,OAAO,KAAKC,MAAM,MAAM,eAAc;AACtC,SAASC,QAAQ,EAAEC,YAAY,EAAEC,iBAAiB,EAAEC,OAAO,QAAQ,cAAa;AAChF,SAASC,YAAY,QAAQ,gBAAe;AAG5C;AACA,OAAO,SAASC,iBAAiBA,CAACC,GAAW,EAAU;EACrD;EACA,OAAON,QAAQ,CAACM,GAAG,CAAC,CAACC,kBAAkB;AACzC;AAEA,MAAMC,GAAG,GAAG,IAAIV,SAAS,CAAC,CAAC;;AAE3B;AACA;AACA,OAAO,SAASW,UAAUA,CAACH,GAAW,EAAEI,UAAmC,EAAE;EAC3E,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,MAAMC,MAAM,GAAGJ,GAAG,CAACK,KAAK,CAACP,GAAG,CAAC;EAC7B,IAAIM,MAAM,CAACE,KAAK,EAAE;IAChBH,MAAM,GAAGC,MAAM,CAACE,KAAK;EACvB;EACA,MAAMC,CAAC,GAAG,IAAIhB,MAAM,CAACiB,OAAO,CAAC,CAAuC;EACpEC,MAAM,CAACC,OAAO,CAACP,MAAM,CAAC,CAACQ,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;IAC/CN,CAAC,CAACK,GAAG,CAACE,WAAW,CAAC,CAAC,CAAC,GAAGD,KAAK;EAC9B,CAAC,CAAC;EACFJ,MAAM,CAACC,OAAO,CAACR,UAAU,CAAC,CAACS,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;IACnDN,CAAC,CAACK,GAAG,CAAC,GAAGC,KAAK;EAChB,CAAC,CAAC;EACF,OAAON,CAAC;AACV;;AAEA;AACA,OAAO,eAAeQ,kBAAkBA,CAACC,QAA8B,EAAE;EACvE,MAAMC,UAAU,GAAGD,QAAQ,CAACC,UAAU;EACtC,IAAIC,IAAY,EAAEC,OAAe;EACjC,IAAIF,UAAU,KAAK,GAAG,EAAE;IACtBC,IAAI,GAAG,kBAAkB;IACzBC,OAAO,GAAG,mBAAmB;EAC/B,CAAC,MAAM,IAAIF,UAAU,KAAK,GAAG,EAAE;IAC7BC,IAAI,GAAG,mBAAmB;IAC1BC,OAAO,GAAG,yCAAyC;EACrD,CAAC,MAAM,IAAIF,UAAU,KAAK,GAAG,EAAE;IAC7BC,IAAI,GAAG,cAAc;IACrBC,OAAO,GAAG,2CAA2C;EACvD,CAAC,MAAM,IAAIF,UAAU,KAAK,GAAG,EAAE;IAC7BC,IAAI,GAAG,UAAU;IACjBC,OAAO,GAAG,WAAW;EACvB,CAAC,MAAM,IAAIF,UAAU,KAAK,GAAG,EAAE;IAC7BC,IAAI,GAAG,kBAAkB;IACzBC,OAAO,GAAG,oBAAoB;EAChC,CAAC,MAAM,IAAIF,UAAU,KAAK,GAAG,EAAE;IAC7BC,IAAI,GAAG,kBAAkB;IACzBC,OAAO,GAAG,oBAAoB;EAChC,CAAC,MAAM;IACLD,IAAI,GAAG,cAAc;IACrBC,OAAO,GAAI,GAAEF,UAAW,EAAC;EAC3B;EACA,MAAMf,UAAqD,GAAG,CAAC,CAAC;EAChE;EACAA,UAAU,CAACkB,YAAY,GAAGJ,QAAQ,CAACK,OAAO,CAAC,kBAAkB,CAAuB;EACpF;EACAnB,UAAU,CAACoB,MAAM,GAAGN,QAAQ,CAACK,OAAO,CAAC,YAAY,CAAuB;;EAExE;EACA;EACAnB,UAAU,CAACqB,eAAe,GAAGP,QAAQ,CAACK,OAAO,CAAC,qBAAqB,CAAuB;EAE1F,MAAMG,SAAS,GAAG,MAAM5B,YAAY,CAACoB,QAAQ,CAAC;EAE9C,IAAIQ,SAAS,EAAE;IACb,MAAMvB,UAAU,CAACuB,SAAS,EAAEtB,UAAU,CAAC;EACzC;;EAEA;EACA,MAAMK,CAAC,GAAG,IAAIhB,MAAM,CAACiB,OAAO,CAACW,OAAO,EAAE;IAAEM,KAAK,EAAEvB;EAAW,CAAC,CAAC;EAC5D;EACAK,CAAC,CAACW,IAAI,GAAGA,IAAI;EACbT,MAAM,CAACC,OAAO,CAACR,UAAU,CAAC,CAACS,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;IACnD;IACAN,CAAC,CAACK,GAAG,CAAC,GAAGC,KAAK;EAChB,CAAC,CAAC;EAEF,MAAMN,CAAC;AACT;;AAEA;AACA;AACA;AACA,OAAO,SAASmB,8BAA8BA,CAAC5B,GAAW,EAAE;EAC1D,MAAM6B,MAIL,GAAG;IACFC,OAAO,EAAE,EAAE;IACXC,WAAW,EAAE,KAAK;IAClBC,qBAAqB,EAAE;EACzB,CAAC;EAED,IAAIC,MAAM,GAAGvC,QAAQ,CAACM,GAAG,CAAC;EAC1B,IAAI,CAACiC,MAAM,CAACC,gBAAgB,EAAE;IAC5B,MAAM,IAAIzC,MAAM,CAAC0C,eAAe,CAAC,iCAAiC,CAAC;EACrE;EACAF,MAAM,GAAGA,MAAM,CAACC,gBAAgB;EAChC,IAAID,MAAM,CAACG,WAAW,EAAE;IACtBP,MAAM,CAACE,WAAW,GAAGE,MAAM,CAACG,WAAW;EACzC;EACA,IAAIH,MAAM,CAACI,qBAAqB,EAAE;IAChCR,MAAM,CAACG,qBAAqB,GAAGC,MAAM,CAACI,qBAAqB;EAC7D;EAEA,IAAIJ,MAAM,CAACK,QAAQ,EAAE;IACnBzC,OAAO,CAACoC,MAAM,CAACK,QAAQ,CAAC,CAACzB,OAAO,CAAE0B,OAAO,IAAK;MAC5C,MAAMC,IAAI,GAAG5C,iBAAiB,CAAC2C,OAAO,CAACE,GAAG,CAAC;MAC3C,MAAMC,YAAY,GAAG,IAAIC,IAAI,CAACJ,OAAO,CAACK,YAAY,CAAC;MACnD,MAAMC,IAAI,GAAGlD,YAAY,CAAC4C,OAAO,CAACO,IAAI,CAAC;MACvC,MAAMC,IAAI,GAAGR,OAAO,CAACS,IAAI;MACzB,IAAIC,QAAQ;MACZ,IAAIV,OAAO,CAACW,YAAY,IAAI,IAAI,EAAE;QAChCD,QAAQ,GAAGpD,OAAO,CAAC0C,OAAO,CAACW,YAAY,CAAC,CAAC,CAAC,CAAC;MAC7C,CAAC,MAAM;QACLD,QAAQ,GAAG,IAAI;MACjB;MACApB,MAAM,CAACC,OAAO,CAACqB,IAAI,CAAC;QAAEX,IAAI;QAAEE,YAAY;QAAEG,IAAI;QAAEE,IAAI;QAAEE;MAAS,CAAC,CAAC;IACnE,CAAC,CAAC;EACJ;EAEA,IAAIhB,MAAM,CAACmB,cAAc,EAAE;IACzBvD,OAAO,CAACoC,MAAM,CAACmB,cAAc,CAAC,CAACvC,OAAO,CAAEwC,YAAY,IAAK;MACvDxB,MAAM,CAACC,OAAO,CAACqB,IAAI,CAAC;QAAEG,MAAM,EAAE1D,iBAAiB,CAACC,OAAO,CAACwD,YAAY,CAACE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAAER,IAAI,EAAE;MAAE,CAAC,CAAC;IAC9F,CAAC,CAAC;EACJ;EACA,OAAOlB,MAAM;AACf;AAwBA;AACA,OAAO,SAAS2B,cAAcA,CAACxD,GAAW,EAIxC;EACA,IAAIiC,MAAM,GAAGvC,QAAQ,CAACM,GAAG,CAAC;EAC1B,MAAM6B,MAAuE,GAAG;IAC9EE,WAAW,EAAE,KAAK;IAClB0B,KAAK,EAAE,EAAE;IACTC,MAAM,EAAE;EACV,CAAC;EACD,IAAI,CAACzB,MAAM,CAAC0B,eAAe,EAAE;IAC3B,MAAM,IAAIlE,MAAM,CAAC0C,eAAe,CAAC,gCAAgC,CAAC;EACpE;EACAF,MAAM,GAAGA,MAAM,CAAC0B,eAAe;EAC/B,IAAI1B,MAAM,CAACG,WAAW,EAAE;IACtBP,MAAM,CAACE,WAAW,GAAGE,MAAM,CAACG,WAAW;EACzC;EACA,IAAIH,MAAM,CAAC2B,oBAAoB,EAAE;IAC/B/B,MAAM,CAAC6B,MAAM,GAAG7D,OAAO,CAACoC,MAAM,CAAC2B,oBAAoB,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAC/D;EACA,IAAI3B,MAAM,CAAC4B,IAAI,EAAE;IACfhE,OAAO,CAACoC,MAAM,CAAC4B,IAAI,CAAC,CAAChD,OAAO,CAAEiD,CAAC,IAAK;MAClC,MAAMC,IAAI,GAAGC,QAAQ,CAACnE,OAAO,CAACiE,CAAC,CAACG,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACnD,MAAMvB,YAAY,GAAG,IAAIC,IAAI,CAACmB,CAAC,CAAClB,YAAY,CAAC;MAC7C,MAAMC,IAAI,GAAGiB,CAAC,CAAChB,IAAI,CAACoB,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CACnCA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAClBA,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CACvBA,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CACvBA,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CACtBA,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC;MACzBrC,MAAM,CAAC4B,KAAK,CAACN,IAAI,CAAC;QAAEY,IAAI;QAAErB,YAAY;QAAEG,IAAI;QAAEE,IAAI,EAAEiB,QAAQ,CAACF,CAAC,CAACd,IAAI,EAAE,EAAE;MAAE,CAAC,CAAC;IAC7E,CAAC,CAAC;EACJ;EACA,OAAOnB,MAAM;AACf;AAEA,OAAO,SAASsC,eAAeA,CAACnE,GAAW,EAAE;EAC3C,IAAI6B,MAA4B,GAAG,EAAE;EACrC,MAAMuC,YAAY,GAAG1E,QAAQ,CAACM,GAAG,CAAC;EAElC,IAAI,CAACoE,YAAY,CAACC,sBAAsB,EAAE;IACxC,MAAM,IAAI5E,MAAM,CAAC0C,eAAe,CAAC,uCAAuC,CAAC;EAC3E;EACA,MAAM;IAAEkC,sBAAsB,EAAE;MAAEC,OAAO,GAAG,CAAC;IAAE,CAAC,GAAG,CAAC;EAAE,CAAC,GAAGF,YAAY;EAEtE,IAAIE,OAAO,CAACC,MAAM,EAAE;IAClB1C,MAAM,GAAGhC,OAAO,CAACyE,OAAO,CAACC,MAAM,CAAC,CAACC,GAAG,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC,KAAK;MACpD,MAAM;QAAEC,IAAI,EAAEC,UAAU;QAAEC;MAAa,CAAC,GAAGH,MAAM;MACjD,MAAMI,YAAY,GAAG,IAAIlC,IAAI,CAACiC,YAAY,CAAC;MAE3C,OAAO;QAAEpC,IAAI,EAAEmC,UAAU;QAAEE,YAAY,EAAEA;MAAa,CAAC;IACzD,CAAC,CAAC;EACJ;EACA,OAAOhD,MAAM;AACf;AAEA,OAAO,SAASiD,sBAAsBA,CAAC9E,GAAW,EAAU;EAC1D,IAAIiC,MAAM,GAAGvC,QAAQ,CAACM,GAAG,CAAC;EAE1B,IAAI,CAACiC,MAAM,CAAC8C,6BAA6B,EAAE;IACzC,MAAM,IAAItF,MAAM,CAAC0C,eAAe,CAAC,8CAA8C,CAAC;EAClF;EACAF,MAAM,GAAGA,MAAM,CAAC8C,6BAA6B;EAE7C,IAAI9C,MAAM,CAAC+C,QAAQ,EAAE;IACnB,OAAO/C,MAAM,CAAC+C,QAAQ;EACxB;EACA,MAAM,IAAIvF,MAAM,CAAC0C,eAAe,CAAC,yBAAyB,CAAC;AAC7D;AAEA,OAAO,SAAS8C,sBAAsBA,CAACjF,GAAW,EAAqB;EACrE,MAAMM,MAAM,GAAGZ,QAAQ,CAACM,GAAG,CAAC;EAC5B,MAAM;IAAEkF,IAAI;IAAEC;EAAK,CAAC,GAAG7E,MAAM,CAAC8E,wBAAwB;EACtD,OAAO;IACLA,wBAAwB,EAAE;MACxBC,IAAI,EAAEH,IAAI;MACVI,KAAK,EAAEzF,OAAO,CAACsF,IAAI;IACrB;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}