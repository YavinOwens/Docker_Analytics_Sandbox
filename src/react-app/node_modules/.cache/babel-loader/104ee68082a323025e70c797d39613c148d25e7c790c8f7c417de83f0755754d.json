{"ast":null,"code":"/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as crypto from \"crypto\";\nimport * as errors from \"./errors.mjs\";\nimport { getScope, isNumber, isObject, isString, makeDateLong, makeDateShort, uriEscape } from \"./internal/helper.mjs\";\nconst signV4Algorithm = 'AWS4-HMAC-SHA256';\n\n// getCanonicalRequest generate a canonical request of style.\n//\n// canonicalRequest =\n//  <HTTPMethod>\\n\n//  <CanonicalURI>\\n\n//  <CanonicalQueryString>\\n\n//  <CanonicalHeaders>\\n\n//  <SignedHeaders>\\n\n//  <HashedPayload>\n//\nfunction getCanonicalRequest(method, path, headers, signedHeaders, hashedPayload) {\n  if (!isString(method)) {\n    throw new TypeError('method should be of type \"string\"');\n  }\n  if (!isString(path)) {\n    throw new TypeError('path should be of type \"string\"');\n  }\n  if (!isObject(headers)) {\n    throw new TypeError('headers should be of type \"object\"');\n  }\n  if (!Array.isArray(signedHeaders)) {\n    throw new TypeError('signedHeaders should be of type \"array\"');\n  }\n  if (!isString(hashedPayload)) {\n    throw new TypeError('hashedPayload should be of type \"string\"');\n  }\n  const headersArray = signedHeaders.reduce((acc, i) => {\n    // Trim spaces from the value (required by V4 spec)\n    const val = `${headers[i]}`.replace(/ +/g, ' ');\n    acc.push(`${i.toLowerCase()}:${val}`);\n    return acc;\n  }, []);\n  const requestResource = path.split('?')[0];\n  let requestQuery = path.split('?')[1];\n  if (!requestQuery) {\n    requestQuery = '';\n  }\n  if (requestQuery) {\n    requestQuery = requestQuery.split('&').sort().map(element => !element.includes('=') ? element + '=' : element).join('&');\n  }\n  return [method.toUpperCase(), requestResource, requestQuery, headersArray.join('\\n') + '\\n', signedHeaders.join(';').toLowerCase(), hashedPayload].join('\\n');\n}\n\n// generate a credential string\nfunction getCredential(accessKey, region, requestDate, serviceName = 's3') {\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!isObject(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"');\n  }\n  return `${accessKey}/${getScope(region, requestDate, serviceName)}`;\n}\n\n// Returns signed headers array - alphabetically sorted\nfunction getSignedHeaders(headers) {\n  if (!isObject(headers)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  // Excerpts from @lsegal - https://github.com/aws/aws-sdk-js/issues/659#issuecomment-120477258\n  //\n  //  User-Agent:\n  //\n  //      This is ignored from signing because signing this causes problems with generating pre-signed URLs\n  //      (that are executed by other agents) or when customers pass requests through proxies, which may\n  //      modify the user-agent.\n  //\n  //  Content-Length:\n  //\n  //      This is ignored from signing because generating a pre-signed URL should not provide a content-length\n  //      constraint, specifically when vending a S3 pre-signed PUT URL. The corollary to this is that when\n  //      sending regular requests (non-pre-signed), the signature contains a checksum of the body, which\n  //      implicitly validates the payload length (since changing the number of bytes would change the checksum)\n  //      and therefore this header is not valuable in the signature.\n  //\n  //  Content-Type:\n  //\n  //      Signing this header causes quite a number of problems in browser environments, where browsers\n  //      like to modify and normalize the content-type header in different ways. There is more information\n  //      on this in https://github.com/aws/aws-sdk-js/issues/244. Avoiding this field simplifies logic\n  //      and reduces the possibility of future bugs\n  //\n  //  Authorization:\n  //\n  //      Is skipped for obvious reasons\n\n  const ignoredHeaders = ['authorization', 'content-length', 'content-type', 'user-agent'];\n  return Object.keys(headers).filter(header => !ignoredHeaders.includes(header)).sort();\n}\n\n// returns the key used for calculating signature\nfunction getSigningKey(date, region, secretKey, serviceName = 's3') {\n  if (!isObject(date)) {\n    throw new TypeError('date should be of type \"object\"');\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  const dateLine = makeDateShort(date);\n  const hmac1 = crypto.createHmac('sha256', 'AWS4' + secretKey).update(dateLine).digest(),\n    hmac2 = crypto.createHmac('sha256', hmac1).update(region).digest(),\n    hmac3 = crypto.createHmac('sha256', hmac2).update(serviceName).digest();\n  return crypto.createHmac('sha256', hmac3).update('aws4_request').digest();\n}\n\n// returns the string that needs to be signed\nfunction getStringToSign(canonicalRequest, requestDate, region, serviceName = 's3') {\n  if (!isString(canonicalRequest)) {\n    throw new TypeError('canonicalRequest should be of type \"string\"');\n  }\n  if (!isObject(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"');\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  const hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n  const scope = getScope(region, requestDate, serviceName);\n  const stringToSign = [signV4Algorithm, makeDateLong(requestDate), scope, hash];\n  return stringToSign.join('\\n');\n}\n\n// calculate the signature of the POST policy\nexport function postPresignSignatureV4(region, date, secretKey, policyBase64) {\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!isObject(date)) {\n    throw new TypeError('date should be of type \"object\"');\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!isString(policyBase64)) {\n    throw new TypeError('policyBase64 should be of type \"string\"');\n  }\n  const signingKey = getSigningKey(date, region, secretKey);\n  return crypto.createHmac('sha256', signingKey).update(policyBase64).digest('hex').toLowerCase();\n}\n\n// Returns the authorization header\nexport function signV4(request, accessKey, secretKey, region, requestDate, sha256sum, serviceName = 's3') {\n  if (!isObject(request)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for signing');\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for signing');\n  }\n  const signedHeaders = getSignedHeaders(request.headers);\n  const canonicalRequest = getCanonicalRequest(request.method, request.path, request.headers, signedHeaders, sha256sum);\n  const serviceIdentifier = serviceName || 's3';\n  const stringToSign = getStringToSign(canonicalRequest, requestDate, region, serviceIdentifier);\n  const signingKey = getSigningKey(requestDate, region, secretKey, serviceIdentifier);\n  const credential = getCredential(accessKey, region, requestDate, serviceIdentifier);\n  const signature = crypto.createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();\n  return `${signV4Algorithm} Credential=${credential}, SignedHeaders=${signedHeaders.join(';').toLowerCase()}, Signature=${signature}`;\n}\nexport function signV4ByServiceName(request, accessKey, secretKey, region, requestDate, contentSha256, serviceName = 's3') {\n  return signV4(request, accessKey, secretKey, region, requestDate, contentSha256, serviceName);\n}\n\n// returns a presigned URL string\nexport function presignSignatureV4(request, accessKey, secretKey, sessionToken, region, requestDate, expires) {\n  if (!isObject(request)) {\n    throw new TypeError('request should be of type \"object\"');\n  }\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"');\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"');\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"');\n  }\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for presigning');\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for presigning');\n  }\n  if (!isNumber(expires)) {\n    throw new TypeError('expires should be of type \"number\"');\n  }\n  if (expires < 1) {\n    throw new errors.ExpiresParamError('expires param cannot be less than 1 seconds');\n  }\n  if (expires > 604800) {\n    throw new errors.ExpiresParamError('expires param cannot be greater than 7 days');\n  }\n  const iso8601Date = makeDateLong(requestDate);\n  const signedHeaders = getSignedHeaders(request.headers);\n  const credential = getCredential(accessKey, region, requestDate);\n  const hashedPayload = 'UNSIGNED-PAYLOAD';\n  const requestQuery = [];\n  requestQuery.push(`X-Amz-Algorithm=${signV4Algorithm}`);\n  requestQuery.push(`X-Amz-Credential=${uriEscape(credential)}`);\n  requestQuery.push(`X-Amz-Date=${iso8601Date}`);\n  requestQuery.push(`X-Amz-Expires=${expires}`);\n  requestQuery.push(`X-Amz-SignedHeaders=${uriEscape(signedHeaders.join(';').toLowerCase())}`);\n  if (sessionToken) {\n    requestQuery.push(`X-Amz-Security-Token=${uriEscape(sessionToken)}`);\n  }\n  const resource = request.path.split('?')[0];\n  let query = request.path.split('?')[1];\n  if (query) {\n    query = query + '&' + requestQuery.join('&');\n  } else {\n    query = requestQuery.join('&');\n  }\n  const path = resource + '?' + query;\n  const canonicalRequest = getCanonicalRequest(request.method, path, request.headers, signedHeaders, hashedPayload);\n  const stringToSign = getStringToSign(canonicalRequest, requestDate, region);\n  const signingKey = getSigningKey(requestDate, region, secretKey);\n  const signature = crypto.createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase();\n  return request.protocol + '//' + request.headers.host + path + `&X-Amz-Signature=${signature}`;\n}","map":{"version":3,"names":["crypto","errors","getScope","isNumber","isObject","isString","makeDateLong","makeDateShort","uriEscape","signV4Algorithm","getCanonicalRequest","method","path","headers","signedHeaders","hashedPayload","TypeError","Array","isArray","headersArray","reduce","acc","i","val","replace","push","toLowerCase","requestResource","split","requestQuery","sort","map","element","includes","join","toUpperCase","getCredential","accessKey","region","requestDate","serviceName","getSignedHeaders","ignoredHeaders","Object","keys","filter","header","getSigningKey","date","secretKey","dateLine","hmac1","createHmac","update","digest","hmac2","hmac3","getStringToSign","canonicalRequest","hash","createHash","scope","stringToSign","postPresignSignatureV4","policyBase64","signingKey","signV4","request","sha256sum","AccessKeyRequiredError","SecretKeyRequiredError","serviceIdentifier","credential","signature","signV4ByServiceName","contentSha256","presignSignatureV4","sessionToken","expires","ExpiresParamError","iso8601Date","resource","query","protocol","host"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/signing.ts"],"sourcesContent":["/*\n * MinIO Javascript Library for Amazon S3 Compatible Cloud Storage, (C) 2016 MinIO, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as crypto from 'node:crypto'\n\nimport * as errors from './errors.ts'\nimport { getScope, isNumber, isObject, isString, makeDateLong, makeDateShort, uriEscape } from './internal/helper.ts'\nimport type { ICanonicalRequest, IRequest, RequestHeaders } from './internal/type.ts'\n\nconst signV4Algorithm = 'AWS4-HMAC-SHA256'\n\n// getCanonicalRequest generate a canonical request of style.\n//\n// canonicalRequest =\n//  <HTTPMethod>\\n\n//  <CanonicalURI>\\n\n//  <CanonicalQueryString>\\n\n//  <CanonicalHeaders>\\n\n//  <SignedHeaders>\\n\n//  <HashedPayload>\n//\nfunction getCanonicalRequest(\n  method: string,\n  path: string,\n  headers: RequestHeaders,\n  signedHeaders: string[],\n  hashedPayload: string,\n): ICanonicalRequest {\n  if (!isString(method)) {\n    throw new TypeError('method should be of type \"string\"')\n  }\n  if (!isString(path)) {\n    throw new TypeError('path should be of type \"string\"')\n  }\n  if (!isObject(headers)) {\n    throw new TypeError('headers should be of type \"object\"')\n  }\n  if (!Array.isArray(signedHeaders)) {\n    throw new TypeError('signedHeaders should be of type \"array\"')\n  }\n  if (!isString(hashedPayload)) {\n    throw new TypeError('hashedPayload should be of type \"string\"')\n  }\n\n  const headersArray = signedHeaders.reduce((acc, i) => {\n    // Trim spaces from the value (required by V4 spec)\n    const val = `${headers[i]}`.replace(/ +/g, ' ')\n    acc.push(`${i.toLowerCase()}:${val}`)\n    return acc\n  }, [] as string[])\n\n  const requestResource = path.split('?')[0]\n  let requestQuery = path.split('?')[1]\n  if (!requestQuery) {\n    requestQuery = ''\n  }\n\n  if (requestQuery) {\n    requestQuery = requestQuery\n      .split('&')\n      .sort()\n      .map((element) => (!element.includes('=') ? element + '=' : element))\n      .join('&')\n  }\n\n  return [\n    method.toUpperCase(),\n    requestResource,\n    requestQuery,\n    headersArray.join('\\n') + '\\n',\n    signedHeaders.join(';').toLowerCase(),\n    hashedPayload,\n  ].join('\\n')\n}\n\n// generate a credential string\nfunction getCredential(accessKey: string, region: string, requestDate?: Date, serviceName = 's3') {\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n  if (!isObject(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"')\n  }\n  return `${accessKey}/${getScope(region, requestDate, serviceName)}`\n}\n\n// Returns signed headers array - alphabetically sorted\nfunction getSignedHeaders(headers: RequestHeaders): string[] {\n  if (!isObject(headers)) {\n    throw new TypeError('request should be of type \"object\"')\n  }\n  // Excerpts from @lsegal - https://github.com/aws/aws-sdk-js/issues/659#issuecomment-120477258\n  //\n  //  User-Agent:\n  //\n  //      This is ignored from signing because signing this causes problems with generating pre-signed URLs\n  //      (that are executed by other agents) or when customers pass requests through proxies, which may\n  //      modify the user-agent.\n  //\n  //  Content-Length:\n  //\n  //      This is ignored from signing because generating a pre-signed URL should not provide a content-length\n  //      constraint, specifically when vending a S3 pre-signed PUT URL. The corollary to this is that when\n  //      sending regular requests (non-pre-signed), the signature contains a checksum of the body, which\n  //      implicitly validates the payload length (since changing the number of bytes would change the checksum)\n  //      and therefore this header is not valuable in the signature.\n  //\n  //  Content-Type:\n  //\n  //      Signing this header causes quite a number of problems in browser environments, where browsers\n  //      like to modify and normalize the content-type header in different ways. There is more information\n  //      on this in https://github.com/aws/aws-sdk-js/issues/244. Avoiding this field simplifies logic\n  //      and reduces the possibility of future bugs\n  //\n  //  Authorization:\n  //\n  //      Is skipped for obvious reasons\n\n  const ignoredHeaders = ['authorization', 'content-length', 'content-type', 'user-agent']\n  return Object.keys(headers)\n    .filter((header) => !ignoredHeaders.includes(header))\n    .sort()\n}\n\n// returns the key used for calculating signature\nfunction getSigningKey(date: Date, region: string, secretKey: string, serviceName = 's3') {\n  if (!isObject(date)) {\n    throw new TypeError('date should be of type \"object\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"')\n  }\n  const dateLine = makeDateShort(date)\n  const hmac1 = crypto\n      .createHmac('sha256', 'AWS4' + secretKey)\n      .update(dateLine)\n      .digest(),\n    hmac2 = crypto.createHmac('sha256', hmac1).update(region).digest(),\n    hmac3 = crypto.createHmac('sha256', hmac2).update(serviceName).digest()\n  return crypto.createHmac('sha256', hmac3).update('aws4_request').digest()\n}\n\n// returns the string that needs to be signed\nfunction getStringToSign(canonicalRequest: ICanonicalRequest, requestDate: Date, region: string, serviceName = 's3') {\n  if (!isString(canonicalRequest)) {\n    throw new TypeError('canonicalRequest should be of type \"string\"')\n  }\n  if (!isObject(requestDate)) {\n    throw new TypeError('requestDate should be of type \"object\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n  const hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex')\n  const scope = getScope(region, requestDate, serviceName)\n  const stringToSign = [signV4Algorithm, makeDateLong(requestDate), scope, hash]\n\n  return stringToSign.join('\\n')\n}\n\n// calculate the signature of the POST policy\nexport function postPresignSignatureV4(region: string, date: Date, secretKey: string, policyBase64: string): string {\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n  if (!isObject(date)) {\n    throw new TypeError('date should be of type \"object\"')\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"')\n  }\n  if (!isString(policyBase64)) {\n    throw new TypeError('policyBase64 should be of type \"string\"')\n  }\n  const signingKey = getSigningKey(date, region, secretKey)\n  return crypto.createHmac('sha256', signingKey).update(policyBase64).digest('hex').toLowerCase()\n}\n\n// Returns the authorization header\nexport function signV4(\n  request: IRequest,\n  accessKey: string,\n  secretKey: string,\n  region: string,\n  requestDate: Date,\n  sha256sum: string,\n  serviceName = 's3',\n) {\n  if (!isObject(request)) {\n    throw new TypeError('request should be of type \"object\"')\n  }\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"')\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for signing')\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for signing')\n  }\n\n  const signedHeaders = getSignedHeaders(request.headers)\n  const canonicalRequest = getCanonicalRequest(request.method, request.path, request.headers, signedHeaders, sha256sum)\n  const serviceIdentifier = serviceName || 's3'\n  const stringToSign = getStringToSign(canonicalRequest, requestDate, region, serviceIdentifier)\n  const signingKey = getSigningKey(requestDate, region, secretKey, serviceIdentifier)\n  const credential = getCredential(accessKey, region, requestDate, serviceIdentifier)\n  const signature = crypto.createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase()\n\n  return `${signV4Algorithm} Credential=${credential}, SignedHeaders=${signedHeaders\n    .join(';')\n    .toLowerCase()}, Signature=${signature}`\n}\n\nexport function signV4ByServiceName(\n  request: IRequest,\n  accessKey: string,\n  secretKey: string,\n  region: string,\n  requestDate: Date,\n  contentSha256: string,\n  serviceName = 's3',\n): string {\n  return signV4(request, accessKey, secretKey, region, requestDate, contentSha256, serviceName)\n}\n\n// returns a presigned URL string\nexport function presignSignatureV4(\n  request: IRequest,\n  accessKey: string,\n  secretKey: string,\n  sessionToken: string | undefined,\n  region: string,\n  requestDate: Date,\n  expires: number,\n) {\n  if (!isObject(request)) {\n    throw new TypeError('request should be of type \"object\"')\n  }\n  if (!isString(accessKey)) {\n    throw new TypeError('accessKey should be of type \"string\"')\n  }\n  if (!isString(secretKey)) {\n    throw new TypeError('secretKey should be of type \"string\"')\n  }\n  if (!isString(region)) {\n    throw new TypeError('region should be of type \"string\"')\n  }\n\n  if (!accessKey) {\n    throw new errors.AccessKeyRequiredError('accessKey is required for presigning')\n  }\n  if (!secretKey) {\n    throw new errors.SecretKeyRequiredError('secretKey is required for presigning')\n  }\n\n  if (!isNumber(expires)) {\n    throw new TypeError('expires should be of type \"number\"')\n  }\n  if (expires < 1) {\n    throw new errors.ExpiresParamError('expires param cannot be less than 1 seconds')\n  }\n  if (expires > 604800) {\n    throw new errors.ExpiresParamError('expires param cannot be greater than 7 days')\n  }\n\n  const iso8601Date = makeDateLong(requestDate)\n  const signedHeaders = getSignedHeaders(request.headers)\n  const credential = getCredential(accessKey, region, requestDate)\n  const hashedPayload = 'UNSIGNED-PAYLOAD'\n\n  const requestQuery: string[] = []\n  requestQuery.push(`X-Amz-Algorithm=${signV4Algorithm}`)\n  requestQuery.push(`X-Amz-Credential=${uriEscape(credential)}`)\n  requestQuery.push(`X-Amz-Date=${iso8601Date}`)\n  requestQuery.push(`X-Amz-Expires=${expires}`)\n  requestQuery.push(`X-Amz-SignedHeaders=${uriEscape(signedHeaders.join(';').toLowerCase())}`)\n  if (sessionToken) {\n    requestQuery.push(`X-Amz-Security-Token=${uriEscape(sessionToken)}`)\n  }\n\n  const resource = request.path.split('?')[0]\n  let query = request.path.split('?')[1]\n  if (query) {\n    query = query + '&' + requestQuery.join('&')\n  } else {\n    query = requestQuery.join('&')\n  }\n\n  const path = resource + '?' + query\n\n  const canonicalRequest = getCanonicalRequest(request.method, path, request.headers, signedHeaders, hashedPayload)\n\n  const stringToSign = getStringToSign(canonicalRequest, requestDate, region)\n  const signingKey = getSigningKey(requestDate, region, secretKey)\n  const signature = crypto.createHmac('sha256', signingKey).update(stringToSign).digest('hex').toLowerCase()\n  return request.protocol + '//' + request.headers.host + path + `&X-Amz-Signature=${signature}`\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,MAAM;AAElB,OAAO,KAAKC,MAAM,MAAM,cAAa;AACrC,SAASC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,aAAa,EAAEC,SAAS,QAAQ,uBAAsB;AAGrH,MAAMC,eAAe,GAAG,kBAAkB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAC1BC,MAAc,EACdC,IAAY,EACZC,OAAuB,EACvBC,aAAuB,EACvBC,aAAqB,EACF;EACnB,IAAI,CAACV,QAAQ,CAACM,MAAM,CAAC,EAAE;IACrB,MAAM,IAAIK,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA,IAAI,CAACX,QAAQ,CAACO,IAAI,CAAC,EAAE;IACnB,MAAM,IAAII,SAAS,CAAC,iCAAiC,CAAC;EACxD;EACA,IAAI,CAACZ,QAAQ,CAACS,OAAO,CAAC,EAAE;IACtB,MAAM,IAAIG,SAAS,CAAC,oCAAoC,CAAC;EAC3D;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACJ,aAAa,CAAC,EAAE;IACjC,MAAM,IAAIE,SAAS,CAAC,yCAAyC,CAAC;EAChE;EACA,IAAI,CAACX,QAAQ,CAACU,aAAa,CAAC,EAAE;IAC5B,MAAM,IAAIC,SAAS,CAAC,0CAA0C,CAAC;EACjE;EAEA,MAAMG,YAAY,GAAGL,aAAa,CAACM,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAK;IACpD;IACA,MAAMC,GAAG,GAAI,GAAEV,OAAO,CAACS,CAAC,CAAE,EAAC,CAACE,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;IAC/CH,GAAG,CAACI,IAAI,CAAE,GAAEH,CAAC,CAACI,WAAW,CAAC,CAAE,IAAGH,GAAI,EAAC,CAAC;IACrC,OAAOF,GAAG;EACZ,CAAC,EAAE,EAAc,CAAC;EAElB,MAAMM,eAAe,GAAGf,IAAI,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1C,IAAIC,YAAY,GAAGjB,IAAI,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACrC,IAAI,CAACC,YAAY,EAAE;IACjBA,YAAY,GAAG,EAAE;EACnB;EAEA,IAAIA,YAAY,EAAE;IAChBA,YAAY,GAAGA,YAAY,CACxBD,KAAK,CAAC,GAAG,CAAC,CACVE,IAAI,CAAC,CAAC,CACNC,GAAG,CAAEC,OAAO,IAAM,CAACA,OAAO,CAACC,QAAQ,CAAC,GAAG,CAAC,GAAGD,OAAO,GAAG,GAAG,GAAGA,OAAQ,CAAC,CACpEE,IAAI,CAAC,GAAG,CAAC;EACd;EAEA,OAAO,CACLvB,MAAM,CAACwB,WAAW,CAAC,CAAC,EACpBR,eAAe,EACfE,YAAY,EACZV,YAAY,CAACe,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,EAC9BpB,aAAa,CAACoB,IAAI,CAAC,GAAG,CAAC,CAACR,WAAW,CAAC,CAAC,EACrCX,aAAa,CACd,CAACmB,IAAI,CAAC,IAAI,CAAC;AACd;;AAEA;AACA,SAASE,aAAaA,CAACC,SAAiB,EAAEC,MAAc,EAAEC,WAAkB,EAAEC,WAAW,GAAG,IAAI,EAAE;EAChG,IAAI,CAACnC,QAAQ,CAACgC,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIrB,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA,IAAI,CAACZ,QAAQ,CAACmC,WAAW,CAAC,EAAE;IAC1B,MAAM,IAAIvB,SAAS,CAAC,wCAAwC,CAAC;EAC/D;EACA,OAAQ,GAAEqB,SAAU,IAAGnC,QAAQ,CAACoC,MAAM,EAAEC,WAAW,EAAEC,WAAW,CAAE,EAAC;AACrE;;AAEA;AACA,SAASC,gBAAgBA,CAAC5B,OAAuB,EAAY;EAC3D,IAAI,CAACT,QAAQ,CAACS,OAAO,CAAC,EAAE;IACtB,MAAM,IAAIG,SAAS,CAAC,oCAAoC,CAAC;EAC3D;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,MAAM0B,cAAc,GAAG,CAAC,eAAe,EAAE,gBAAgB,EAAE,cAAc,EAAE,YAAY,CAAC;EACxF,OAAOC,MAAM,CAACC,IAAI,CAAC/B,OAAO,CAAC,CACxBgC,MAAM,CAAEC,MAAM,IAAK,CAACJ,cAAc,CAACT,QAAQ,CAACa,MAAM,CAAC,CAAC,CACpDhB,IAAI,CAAC,CAAC;AACX;;AAEA;AACA,SAASiB,aAAaA,CAACC,IAAU,EAAEV,MAAc,EAAEW,SAAiB,EAAET,WAAW,GAAG,IAAI,EAAE;EACxF,IAAI,CAACpC,QAAQ,CAAC4C,IAAI,CAAC,EAAE;IACnB,MAAM,IAAIhC,SAAS,CAAC,iCAAiC,CAAC;EACxD;EACA,IAAI,CAACX,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA,IAAI,CAACX,QAAQ,CAAC4C,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIjC,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,MAAMkC,QAAQ,GAAG3C,aAAa,CAACyC,IAAI,CAAC;EACpC,MAAMG,KAAK,GAAGnD,MAAM,CACfoD,UAAU,CAAC,QAAQ,EAAE,MAAM,GAAGH,SAAS,CAAC,CACxCI,MAAM,CAACH,QAAQ,CAAC,CAChBI,MAAM,CAAC,CAAC;IACXC,KAAK,GAAGvD,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAED,KAAK,CAAC,CAACE,MAAM,CAACf,MAAM,CAAC,CAACgB,MAAM,CAAC,CAAC;IAClEE,KAAK,GAAGxD,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAEG,KAAK,CAAC,CAACF,MAAM,CAACb,WAAW,CAAC,CAACc,MAAM,CAAC,CAAC;EACzE,OAAOtD,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAEI,KAAK,CAAC,CAACH,MAAM,CAAC,cAAc,CAAC,CAACC,MAAM,CAAC,CAAC;AAC3E;;AAEA;AACA,SAASG,eAAeA,CAACC,gBAAmC,EAAEnB,WAAiB,EAAED,MAAc,EAAEE,WAAW,GAAG,IAAI,EAAE;EACnH,IAAI,CAACnC,QAAQ,CAACqD,gBAAgB,CAAC,EAAE;IAC/B,MAAM,IAAI1C,SAAS,CAAC,6CAA6C,CAAC;EACpE;EACA,IAAI,CAACZ,QAAQ,CAACmC,WAAW,CAAC,EAAE;IAC1B,MAAM,IAAIvB,SAAS,CAAC,wCAAwC,CAAC;EAC/D;EACA,IAAI,CAACX,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA,MAAM2C,IAAI,GAAG3D,MAAM,CAAC4D,UAAU,CAAC,QAAQ,CAAC,CAACP,MAAM,CAACK,gBAAgB,CAAC,CAACJ,MAAM,CAAC,KAAK,CAAC;EAC/E,MAAMO,KAAK,GAAG3D,QAAQ,CAACoC,MAAM,EAAEC,WAAW,EAAEC,WAAW,CAAC;EACxD,MAAMsB,YAAY,GAAG,CAACrD,eAAe,EAAEH,YAAY,CAACiC,WAAW,CAAC,EAAEsB,KAAK,EAAEF,IAAI,CAAC;EAE9E,OAAOG,YAAY,CAAC5B,IAAI,CAAC,IAAI,CAAC;AAChC;;AAEA;AACA,OAAO,SAAS6B,sBAAsBA,CAACzB,MAAc,EAAEU,IAAU,EAAEC,SAAiB,EAAEe,YAAoB,EAAU;EAClH,IAAI,CAAC3D,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EACA,IAAI,CAACZ,QAAQ,CAAC4C,IAAI,CAAC,EAAE;IACnB,MAAM,IAAIhC,SAAS,CAAC,iCAAiC,CAAC;EACxD;EACA,IAAI,CAACX,QAAQ,CAAC4C,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIjC,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAAC2D,YAAY,CAAC,EAAE;IAC3B,MAAM,IAAIhD,SAAS,CAAC,yCAAyC,CAAC;EAChE;EACA,MAAMiD,UAAU,GAAGlB,aAAa,CAACC,IAAI,EAAEV,MAAM,EAAEW,SAAS,CAAC;EACzD,OAAOjD,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAEa,UAAU,CAAC,CAACZ,MAAM,CAACW,YAAY,CAAC,CAACV,MAAM,CAAC,KAAK,CAAC,CAAC5B,WAAW,CAAC,CAAC;AACjG;;AAEA;AACA,OAAO,SAASwC,MAAMA,CACpBC,OAAiB,EACjB9B,SAAiB,EACjBY,SAAiB,EACjBX,MAAc,EACdC,WAAiB,EACjB6B,SAAiB,EACjB5B,WAAW,GAAG,IAAI,EAClB;EACA,IAAI,CAACpC,QAAQ,CAAC+D,OAAO,CAAC,EAAE;IACtB,MAAM,IAAInD,SAAS,CAAC,oCAAoC,CAAC;EAC3D;EACA,IAAI,CAACX,QAAQ,CAACgC,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIrB,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAAC4C,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIjC,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EAEA,IAAI,CAACqB,SAAS,EAAE;IACd,MAAM,IAAIpC,MAAM,CAACoE,sBAAsB,CAAC,mCAAmC,CAAC;EAC9E;EACA,IAAI,CAACpB,SAAS,EAAE;IACd,MAAM,IAAIhD,MAAM,CAACqE,sBAAsB,CAAC,mCAAmC,CAAC;EAC9E;EAEA,MAAMxD,aAAa,GAAG2B,gBAAgB,CAAC0B,OAAO,CAACtD,OAAO,CAAC;EACvD,MAAM6C,gBAAgB,GAAGhD,mBAAmB,CAACyD,OAAO,CAACxD,MAAM,EAAEwD,OAAO,CAACvD,IAAI,EAAEuD,OAAO,CAACtD,OAAO,EAAEC,aAAa,EAAEsD,SAAS,CAAC;EACrH,MAAMG,iBAAiB,GAAG/B,WAAW,IAAI,IAAI;EAC7C,MAAMsB,YAAY,GAAGL,eAAe,CAACC,gBAAgB,EAAEnB,WAAW,EAAED,MAAM,EAAEiC,iBAAiB,CAAC;EAC9F,MAAMN,UAAU,GAAGlB,aAAa,CAACR,WAAW,EAAED,MAAM,EAAEW,SAAS,EAAEsB,iBAAiB,CAAC;EACnF,MAAMC,UAAU,GAAGpC,aAAa,CAACC,SAAS,EAAEC,MAAM,EAAEC,WAAW,EAAEgC,iBAAiB,CAAC;EACnF,MAAME,SAAS,GAAGzE,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAEa,UAAU,CAAC,CAACZ,MAAM,CAACS,YAAY,CAAC,CAACR,MAAM,CAAC,KAAK,CAAC,CAAC5B,WAAW,CAAC,CAAC;EAE1G,OAAQ,GAAEjB,eAAgB,eAAc+D,UAAW,mBAAkB1D,aAAa,CAC/EoB,IAAI,CAAC,GAAG,CAAC,CACTR,WAAW,CAAC,CAAE,eAAc+C,SAAU,EAAC;AAC5C;AAEA,OAAO,SAASC,mBAAmBA,CACjCP,OAAiB,EACjB9B,SAAiB,EACjBY,SAAiB,EACjBX,MAAc,EACdC,WAAiB,EACjBoC,aAAqB,EACrBnC,WAAW,GAAG,IAAI,EACV;EACR,OAAO0B,MAAM,CAACC,OAAO,EAAE9B,SAAS,EAAEY,SAAS,EAAEX,MAAM,EAAEC,WAAW,EAAEoC,aAAa,EAAEnC,WAAW,CAAC;AAC/F;;AAEA;AACA,OAAO,SAASoC,kBAAkBA,CAChCT,OAAiB,EACjB9B,SAAiB,EACjBY,SAAiB,EACjB4B,YAAgC,EAChCvC,MAAc,EACdC,WAAiB,EACjBuC,OAAe,EACf;EACA,IAAI,CAAC1E,QAAQ,CAAC+D,OAAO,CAAC,EAAE;IACtB,MAAM,IAAInD,SAAS,CAAC,oCAAoC,CAAC;EAC3D;EACA,IAAI,CAACX,QAAQ,CAACgC,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIrB,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAAC4C,SAAS,CAAC,EAAE;IACxB,MAAM,IAAIjC,SAAS,CAAC,sCAAsC,CAAC;EAC7D;EACA,IAAI,CAACX,QAAQ,CAACiC,MAAM,CAAC,EAAE;IACrB,MAAM,IAAItB,SAAS,CAAC,mCAAmC,CAAC;EAC1D;EAEA,IAAI,CAACqB,SAAS,EAAE;IACd,MAAM,IAAIpC,MAAM,CAACoE,sBAAsB,CAAC,sCAAsC,CAAC;EACjF;EACA,IAAI,CAACpB,SAAS,EAAE;IACd,MAAM,IAAIhD,MAAM,CAACqE,sBAAsB,CAAC,sCAAsC,CAAC;EACjF;EAEA,IAAI,CAACnE,QAAQ,CAAC2E,OAAO,CAAC,EAAE;IACtB,MAAM,IAAI9D,SAAS,CAAC,oCAAoC,CAAC;EAC3D;EACA,IAAI8D,OAAO,GAAG,CAAC,EAAE;IACf,MAAM,IAAI7E,MAAM,CAAC8E,iBAAiB,CAAC,6CAA6C,CAAC;EACnF;EACA,IAAID,OAAO,GAAG,MAAM,EAAE;IACpB,MAAM,IAAI7E,MAAM,CAAC8E,iBAAiB,CAAC,6CAA6C,CAAC;EACnF;EAEA,MAAMC,WAAW,GAAG1E,YAAY,CAACiC,WAAW,CAAC;EAC7C,MAAMzB,aAAa,GAAG2B,gBAAgB,CAAC0B,OAAO,CAACtD,OAAO,CAAC;EACvD,MAAM2D,UAAU,GAAGpC,aAAa,CAACC,SAAS,EAAEC,MAAM,EAAEC,WAAW,CAAC;EAChE,MAAMxB,aAAa,GAAG,kBAAkB;EAExC,MAAMc,YAAsB,GAAG,EAAE;EACjCA,YAAY,CAACJ,IAAI,CAAE,mBAAkBhB,eAAgB,EAAC,CAAC;EACvDoB,YAAY,CAACJ,IAAI,CAAE,oBAAmBjB,SAAS,CAACgE,UAAU,CAAE,EAAC,CAAC;EAC9D3C,YAAY,CAACJ,IAAI,CAAE,cAAauD,WAAY,EAAC,CAAC;EAC9CnD,YAAY,CAACJ,IAAI,CAAE,iBAAgBqD,OAAQ,EAAC,CAAC;EAC7CjD,YAAY,CAACJ,IAAI,CAAE,uBAAsBjB,SAAS,CAACM,aAAa,CAACoB,IAAI,CAAC,GAAG,CAAC,CAACR,WAAW,CAAC,CAAC,CAAE,EAAC,CAAC;EAC5F,IAAImD,YAAY,EAAE;IAChBhD,YAAY,CAACJ,IAAI,CAAE,wBAAuBjB,SAAS,CAACqE,YAAY,CAAE,EAAC,CAAC;EACtE;EAEA,MAAMI,QAAQ,GAAGd,OAAO,CAACvD,IAAI,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC3C,IAAIsD,KAAK,GAAGf,OAAO,CAACvD,IAAI,CAACgB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACtC,IAAIsD,KAAK,EAAE;IACTA,KAAK,GAAGA,KAAK,GAAG,GAAG,GAAGrD,YAAY,CAACK,IAAI,CAAC,GAAG,CAAC;EAC9C,CAAC,MAAM;IACLgD,KAAK,GAAGrD,YAAY,CAACK,IAAI,CAAC,GAAG,CAAC;EAChC;EAEA,MAAMtB,IAAI,GAAGqE,QAAQ,GAAG,GAAG,GAAGC,KAAK;EAEnC,MAAMxB,gBAAgB,GAAGhD,mBAAmB,CAACyD,OAAO,CAACxD,MAAM,EAAEC,IAAI,EAAEuD,OAAO,CAACtD,OAAO,EAAEC,aAAa,EAAEC,aAAa,CAAC;EAEjH,MAAM+C,YAAY,GAAGL,eAAe,CAACC,gBAAgB,EAAEnB,WAAW,EAAED,MAAM,CAAC;EAC3E,MAAM2B,UAAU,GAAGlB,aAAa,CAACR,WAAW,EAAED,MAAM,EAAEW,SAAS,CAAC;EAChE,MAAMwB,SAAS,GAAGzE,MAAM,CAACoD,UAAU,CAAC,QAAQ,EAAEa,UAAU,CAAC,CAACZ,MAAM,CAACS,YAAY,CAAC,CAACR,MAAM,CAAC,KAAK,CAAC,CAAC5B,WAAW,CAAC,CAAC;EAC1G,OAAOyC,OAAO,CAACgB,QAAQ,GAAG,IAAI,GAAGhB,OAAO,CAACtD,OAAO,CAACuE,IAAI,GAAGxE,IAAI,GAAI,oBAAmB6D,SAAU,EAAC;AAChG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}