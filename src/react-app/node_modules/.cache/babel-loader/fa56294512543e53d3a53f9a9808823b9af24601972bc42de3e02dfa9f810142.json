{"ast":null,"code":"import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as querystring from 'query-string';\nimport * as errors from \"./errors.mjs\";\nimport { getEncryptionHeaders, isEmpty, isEmptyObject, isNumber, isObject, isString, isValidBucketName, isValidObjectName } from \"./internal/helper.mjs\";\nimport { RETENTION_MODES } from \"./internal/type.mjs\";\nexport { ENCRYPTION_TYPES, LEGAL_HOLD_STATUS, RETENTION_MODES, RETENTION_VALIDITY_UNITS } from \"./internal/type.mjs\";\nexport const DEFAULT_REGION = 'us-east-1';\nexport class CopySourceOptions {\n  constructor({\n    Bucket,\n    Object,\n    VersionID = '',\n    MatchETag = '',\n    NoMatchETag = '',\n    MatchModifiedSince = null,\n    MatchUnmodifiedSince = null,\n    MatchRange = false,\n    Start = 0,\n    End = 0,\n    Encryption = undefined\n  }) {\n    this.Bucket = Bucket;\n    this.Object = Object;\n    this.VersionID = VersionID;\n    this.MatchETag = MatchETag;\n    this.NoMatchETag = NoMatchETag;\n    this.MatchModifiedSince = MatchModifiedSince;\n    this.MatchUnmodifiedSince = MatchUnmodifiedSince;\n    this.MatchRange = MatchRange;\n    this.Start = Start;\n    this.End = End;\n    this.Encryption = Encryption;\n  }\n  validate() {\n    if (!isValidBucketName(this.Bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid Source bucket name: ' + this.Bucket);\n    }\n    if (!isValidObjectName(this.Object)) {\n      throw new errors.InvalidObjectNameError(`Invalid Source object name: ${this.Object}`);\n    }\n    if (this.MatchRange && this.Start !== -1 && this.End !== -1 && this.Start > this.End || this.Start < 0) {\n      throw new errors.InvalidObjectNameError('Source start must be non-negative, and start must be at most end.');\n    } else if (this.MatchRange && !isNumber(this.Start) || !isNumber(this.End)) {\n      throw new errors.InvalidObjectNameError('MatchRange is specified. But Invalid Start and End values are specified.');\n    }\n    return true;\n  }\n  getHeaders() {\n    const headerOptions = {};\n    headerOptions['x-amz-copy-source'] = encodeURI(this.Bucket + '/' + this.Object);\n    if (!isEmpty(this.VersionID)) {\n      headerOptions['x-amz-copy-source'] = `${encodeURI(this.Bucket + '/' + this.Object)}?versionId=${this.VersionID}`;\n    }\n    if (!isEmpty(this.MatchETag)) {\n      headerOptions['x-amz-copy-source-if-match'] = this.MatchETag;\n    }\n    if (!isEmpty(this.NoMatchETag)) {\n      headerOptions['x-amz-copy-source-if-none-match'] = this.NoMatchETag;\n    }\n    if (!isEmpty(this.MatchModifiedSince)) {\n      headerOptions['x-amz-copy-source-if-modified-since'] = this.MatchModifiedSince;\n    }\n    if (!isEmpty(this.MatchUnmodifiedSince)) {\n      headerOptions['x-amz-copy-source-if-unmodified-since'] = this.MatchUnmodifiedSince;\n    }\n    return headerOptions;\n  }\n}\n\n/**\n * @deprecated use nodejs fs module\n */\nexport function removeDirAndFiles(dirPath, removeSelf = true) {\n  if (removeSelf) {\n    return fs.rmSync(dirPath, {\n      recursive: true,\n      force: true\n    });\n  }\n  fs.readdirSync(dirPath).forEach(item => {\n    fs.rmSync(path.join(dirPath, item), {\n      recursive: true,\n      force: true\n    });\n  });\n}\nexport class CopyDestinationOptions {\n  constructor({\n    Bucket,\n    Object,\n    Encryption,\n    UserMetadata,\n    UserTags,\n    LegalHold,\n    RetainUntilDate,\n    Mode,\n    MetadataDirective\n  }) {\n    this.Bucket = Bucket;\n    this.Object = Object;\n    this.Encryption = Encryption ?? undefined; // null input will become undefined, easy for runtime assert\n    this.UserMetadata = UserMetadata;\n    this.UserTags = UserTags;\n    this.LegalHold = LegalHold;\n    this.Mode = Mode; // retention mode\n    this.RetainUntilDate = RetainUntilDate;\n    this.MetadataDirective = MetadataDirective;\n  }\n  getHeaders() {\n    const replaceDirective = 'REPLACE';\n    const headerOptions = {};\n    const userTags = this.UserTags;\n    if (!isEmpty(userTags)) {\n      headerOptions['X-Amz-Tagging-Directive'] = replaceDirective;\n      headerOptions['X-Amz-Tagging'] = isObject(userTags) ? querystring.stringify(userTags) : isString(userTags) ? userTags : '';\n    }\n    if (this.Mode) {\n      headerOptions['X-Amz-Object-Lock-Mode'] = this.Mode; // GOVERNANCE or COMPLIANCE\n    }\n    if (this.RetainUntilDate) {\n      headerOptions['X-Amz-Object-Lock-Retain-Until-Date'] = this.RetainUntilDate; // needs to be UTC.\n    }\n    if (this.LegalHold) {\n      headerOptions['X-Amz-Object-Lock-Legal-Hold'] = this.LegalHold; // ON or OFF\n    }\n    if (this.UserMetadata) {\n      for (const [key, value] of Object.entries(this.UserMetadata)) {\n        headerOptions[`X-Amz-Meta-${key}`] = value.toString();\n      }\n    }\n    if (this.MetadataDirective) {\n      headerOptions[`X-Amz-Metadata-Directive`] = this.MetadataDirective;\n    }\n    if (this.Encryption) {\n      const encryptionHeaders = getEncryptionHeaders(this.Encryption);\n      for (const [key, value] of Object.entries(encryptionHeaders)) {\n        headerOptions[key] = value;\n      }\n    }\n    return headerOptions;\n  }\n  validate() {\n    if (!isValidBucketName(this.Bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid Destination bucket name: ' + this.Bucket);\n    }\n    if (!isValidObjectName(this.Object)) {\n      throw new errors.InvalidObjectNameError(`Invalid Destination object name: ${this.Object}`);\n    }\n    if (!isEmpty(this.UserMetadata) && !isObject(this.UserMetadata)) {\n      throw new errors.InvalidObjectNameError(`Destination UserMetadata should be an object with key value pairs`);\n    }\n    if (!isEmpty(this.Mode) && ![RETENTION_MODES.GOVERNANCE, RETENTION_MODES.COMPLIANCE].includes(this.Mode)) {\n      throw new errors.InvalidObjectNameError(`Invalid Mode specified for destination object it should be one of [GOVERNANCE,COMPLIANCE]`);\n    }\n    if (this.Encryption !== undefined && isEmptyObject(this.Encryption)) {\n      throw new errors.InvalidObjectNameError(`Invalid Encryption configuration for destination object `);\n    }\n    return true;\n  }\n}\n\n/**\n * maybe this should be a generic type for Records, leave it for later refactor\n */\nexport class SelectResults {\n  constructor({\n    records,\n    // parsed data as stream\n    response,\n    // original response stream\n    stats,\n    // stats as xml\n    progress // stats as xml\n  }) {\n    this.records = records;\n    this.response = response;\n    this.stats = stats;\n    this.progress = progress;\n  }\n  setStats(stats) {\n    this.stats = stats;\n  }\n  getStats() {\n    return this.stats;\n  }\n  setProgress(progress) {\n    this.progress = progress;\n  }\n  getProgress() {\n    return this.progress;\n  }\n  setResponse(response) {\n    this.response = response;\n  }\n  getResponse() {\n    return this.response;\n  }\n  setRecords(records) {\n    this.records = records;\n  }\n  getRecords() {\n    return this.records;\n  }\n}","map":{"version":3,"names":["fs","path","querystring","errors","getEncryptionHeaders","isEmpty","isEmptyObject","isNumber","isObject","isString","isValidBucketName","isValidObjectName","RETENTION_MODES","ENCRYPTION_TYPES","LEGAL_HOLD_STATUS","RETENTION_VALIDITY_UNITS","DEFAULT_REGION","CopySourceOptions","constructor","Bucket","Object","VersionID","MatchETag","NoMatchETag","MatchModifiedSince","MatchUnmodifiedSince","MatchRange","Start","End","Encryption","undefined","validate","InvalidBucketNameError","InvalidObjectNameError","getHeaders","headerOptions","encodeURI","removeDirAndFiles","dirPath","removeSelf","rmSync","recursive","force","readdirSync","forEach","item","join","CopyDestinationOptions","UserMetadata","UserTags","LegalHold","RetainUntilDate","Mode","MetadataDirective","replaceDirective","userTags","stringify","key","value","entries","toString","encryptionHeaders","GOVERNANCE","COMPLIANCE","includes","SelectResults","records","response","stats","progress","setStats","getStats","setProgress","getProgress","setResponse","getResponse","setRecords","getRecords"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/minio/dist/esm/helpers.ts"],"sourcesContent":["import * as fs from 'node:fs'\nimport * as path from 'node:path'\n\nimport * as querystring from 'query-string'\n\nimport * as errors from './errors.ts'\nimport {\n  getEncryptionHeaders,\n  isEmpty,\n  isEmptyObject,\n  isNumber,\n  isObject,\n  isString,\n  isValidBucketName,\n  isValidObjectName,\n} from './internal/helper.ts'\nimport type { Encryption, ObjectMetaData, RequestHeaders } from './internal/type.ts'\nimport { RETENTION_MODES } from './internal/type.ts'\n\nexport { ENCRYPTION_TYPES, LEGAL_HOLD_STATUS, RETENTION_MODES, RETENTION_VALIDITY_UNITS } from './internal/type.ts'\n\nexport const DEFAULT_REGION = 'us-east-1'\n\nexport interface ICopySourceOptions {\n  Bucket: string\n  Object: string\n  /**\n   * Valid versionId\n   */\n  VersionID?: string\n  /**\n   * Etag to match\n   */\n  MatchETag?: string\n  /**\n   * Etag to exclude\n   */\n  NoMatchETag?: string\n  /**\n   * Modified Date of the object/part.  UTC Date in string format\n   */\n  MatchModifiedSince?: string | null\n  /**\n   * Modified Date of the object/part to exclude UTC Date in string format\n   */\n  MatchUnmodifiedSince?: string | null\n  /**\n   * true or false Object range to match\n   */\n  MatchRange?: boolean\n  Start?: number\n  End?: number\n  Encryption?: Encryption\n}\n\nexport class CopySourceOptions {\n  public readonly Bucket: string\n  public readonly Object: string\n  public readonly VersionID: string\n  public MatchETag: string\n  private readonly NoMatchETag: string\n  private readonly MatchModifiedSince: string | null\n  private readonly MatchUnmodifiedSince: string | null\n  public readonly MatchRange: boolean\n  public readonly Start: number\n  public readonly End: number\n  private readonly Encryption?: Encryption\n\n  constructor({\n    Bucket,\n    Object,\n    VersionID = '',\n    MatchETag = '',\n    NoMatchETag = '',\n    MatchModifiedSince = null,\n    MatchUnmodifiedSince = null,\n    MatchRange = false,\n    Start = 0,\n    End = 0,\n    Encryption = undefined,\n  }: ICopySourceOptions) {\n    this.Bucket = Bucket\n    this.Object = Object\n    this.VersionID = VersionID\n    this.MatchETag = MatchETag\n    this.NoMatchETag = NoMatchETag\n    this.MatchModifiedSince = MatchModifiedSince\n    this.MatchUnmodifiedSince = MatchUnmodifiedSince\n    this.MatchRange = MatchRange\n    this.Start = Start\n    this.End = End\n    this.Encryption = Encryption\n  }\n\n  validate() {\n    if (!isValidBucketName(this.Bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid Source bucket name: ' + this.Bucket)\n    }\n    if (!isValidObjectName(this.Object)) {\n      throw new errors.InvalidObjectNameError(`Invalid Source object name: ${this.Object}`)\n    }\n    if ((this.MatchRange && this.Start !== -1 && this.End !== -1 && this.Start > this.End) || this.Start < 0) {\n      throw new errors.InvalidObjectNameError('Source start must be non-negative, and start must be at most end.')\n    } else if ((this.MatchRange && !isNumber(this.Start)) || !isNumber(this.End)) {\n      throw new errors.InvalidObjectNameError(\n        'MatchRange is specified. But Invalid Start and End values are specified.',\n      )\n    }\n\n    return true\n  }\n\n  getHeaders(): RequestHeaders {\n    const headerOptions: RequestHeaders = {}\n    headerOptions['x-amz-copy-source'] = encodeURI(this.Bucket + '/' + this.Object)\n\n    if (!isEmpty(this.VersionID)) {\n      headerOptions['x-amz-copy-source'] = `${encodeURI(this.Bucket + '/' + this.Object)}?versionId=${this.VersionID}`\n    }\n\n    if (!isEmpty(this.MatchETag)) {\n      headerOptions['x-amz-copy-source-if-match'] = this.MatchETag\n    }\n    if (!isEmpty(this.NoMatchETag)) {\n      headerOptions['x-amz-copy-source-if-none-match'] = this.NoMatchETag\n    }\n\n    if (!isEmpty(this.MatchModifiedSince)) {\n      headerOptions['x-amz-copy-source-if-modified-since'] = this.MatchModifiedSince\n    }\n    if (!isEmpty(this.MatchUnmodifiedSince)) {\n      headerOptions['x-amz-copy-source-if-unmodified-since'] = this.MatchUnmodifiedSince\n    }\n\n    return headerOptions\n  }\n}\n\n/**\n * @deprecated use nodejs fs module\n */\nexport function removeDirAndFiles(dirPath: string, removeSelf = true) {\n  if (removeSelf) {\n    return fs.rmSync(dirPath, { recursive: true, force: true })\n  }\n\n  fs.readdirSync(dirPath).forEach((item) => {\n    fs.rmSync(path.join(dirPath, item), { recursive: true, force: true })\n  })\n}\n\nexport interface ICopyDestinationOptions {\n  /**\n   * Bucket name\n   */\n  Bucket: string\n  /**\n   * Object Name for the destination (composed/copied) object defaults\n   */\n  Object: string\n  /**\n   * Encryption configuration defaults to {}\n   * @default {}\n   */\n  Encryption?: Encryption\n  UserMetadata?: ObjectMetaData\n  /**\n   * query-string encoded string or Record<string, string> Object\n   */\n  UserTags?: Record<string, string> | string\n  LegalHold?: 'on' | 'off'\n  /**\n   * UTC Date String\n   */\n  RetainUntilDate?: string\n  Mode?: RETENTION_MODES\n  MetadataDirective?: 'COPY' | 'REPLACE'\n}\n\nexport class CopyDestinationOptions {\n  public readonly Bucket: string\n  public readonly Object: string\n  private readonly Encryption?: Encryption\n  private readonly UserMetadata?: ObjectMetaData\n  private readonly UserTags?: Record<string, string> | string\n  private readonly LegalHold?: 'on' | 'off'\n  private readonly RetainUntilDate?: string\n  private readonly Mode?: RETENTION_MODES\n  private readonly MetadataDirective?: string\n\n  constructor({\n    Bucket,\n    Object,\n    Encryption,\n    UserMetadata,\n    UserTags,\n    LegalHold,\n    RetainUntilDate,\n    Mode,\n    MetadataDirective,\n  }: ICopyDestinationOptions) {\n    this.Bucket = Bucket\n    this.Object = Object\n    this.Encryption = Encryption ?? undefined // null input will become undefined, easy for runtime assert\n    this.UserMetadata = UserMetadata\n    this.UserTags = UserTags\n    this.LegalHold = LegalHold\n    this.Mode = Mode // retention mode\n    this.RetainUntilDate = RetainUntilDate\n    this.MetadataDirective = MetadataDirective\n  }\n\n  getHeaders(): RequestHeaders {\n    const replaceDirective = 'REPLACE'\n    const headerOptions: RequestHeaders = {}\n\n    const userTags = this.UserTags\n    if (!isEmpty(userTags)) {\n      headerOptions['X-Amz-Tagging-Directive'] = replaceDirective\n      headerOptions['X-Amz-Tagging'] = isObject(userTags)\n        ? querystring.stringify(userTags)\n        : isString(userTags)\n        ? userTags\n        : ''\n    }\n\n    if (this.Mode) {\n      headerOptions['X-Amz-Object-Lock-Mode'] = this.Mode // GOVERNANCE or COMPLIANCE\n    }\n\n    if (this.RetainUntilDate) {\n      headerOptions['X-Amz-Object-Lock-Retain-Until-Date'] = this.RetainUntilDate // needs to be UTC.\n    }\n\n    if (this.LegalHold) {\n      headerOptions['X-Amz-Object-Lock-Legal-Hold'] = this.LegalHold // ON or OFF\n    }\n\n    if (this.UserMetadata) {\n      for (const [key, value] of Object.entries(this.UserMetadata)) {\n        headerOptions[`X-Amz-Meta-${key}`] = value.toString()\n      }\n    }\n\n    if (this.MetadataDirective) {\n      headerOptions[`X-Amz-Metadata-Directive`] = this.MetadataDirective\n    }\n\n    if (this.Encryption) {\n      const encryptionHeaders = getEncryptionHeaders(this.Encryption)\n      for (const [key, value] of Object.entries(encryptionHeaders)) {\n        headerOptions[key] = value\n      }\n    }\n    return headerOptions\n  }\n\n  validate() {\n    if (!isValidBucketName(this.Bucket)) {\n      throw new errors.InvalidBucketNameError('Invalid Destination bucket name: ' + this.Bucket)\n    }\n    if (!isValidObjectName(this.Object)) {\n      throw new errors.InvalidObjectNameError(`Invalid Destination object name: ${this.Object}`)\n    }\n    if (!isEmpty(this.UserMetadata) && !isObject(this.UserMetadata)) {\n      throw new errors.InvalidObjectNameError(`Destination UserMetadata should be an object with key value pairs`)\n    }\n\n    if (!isEmpty(this.Mode) && ![RETENTION_MODES.GOVERNANCE, RETENTION_MODES.COMPLIANCE].includes(this.Mode)) {\n      throw new errors.InvalidObjectNameError(\n        `Invalid Mode specified for destination object it should be one of [GOVERNANCE,COMPLIANCE]`,\n      )\n    }\n\n    if (this.Encryption !== undefined && isEmptyObject(this.Encryption)) {\n      throw new errors.InvalidObjectNameError(`Invalid Encryption configuration for destination object `)\n    }\n    return true\n  }\n}\n\n/**\n * maybe this should be a generic type for Records, leave it for later refactor\n */\nexport class SelectResults {\n  private records?: unknown\n  private response?: unknown\n  private stats?: string\n  private progress?: unknown\n\n  constructor({\n    records, // parsed data as stream\n    response, // original response stream\n    stats, // stats as xml\n    progress, // stats as xml\n  }: {\n    records?: unknown\n    response?: unknown\n    stats?: string\n    progress?: unknown\n  }) {\n    this.records = records\n    this.response = response\n    this.stats = stats\n    this.progress = progress\n  }\n\n  setStats(stats: string) {\n    this.stats = stats\n  }\n\n  getStats() {\n    return this.stats\n  }\n\n  setProgress(progress: unknown) {\n    this.progress = progress\n  }\n\n  getProgress() {\n    return this.progress\n  }\n\n  setResponse(response: unknown) {\n    this.response = response\n  }\n\n  getResponse() {\n    return this.response\n  }\n\n  setRecords(records: unknown) {\n    this.records = records\n  }\n\n  getRecords(): unknown {\n    return this.records\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}