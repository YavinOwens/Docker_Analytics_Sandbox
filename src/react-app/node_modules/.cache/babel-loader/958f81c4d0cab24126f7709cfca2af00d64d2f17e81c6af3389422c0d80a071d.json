{"ast":null,"code":"(function (root) {\n  'use strict';\n\n  // A list of regular expressions that match arbitrary IPv4 addresses,\n  // for which a number of weird notations exist.\n  // Note that an address like 0010.0xa5.1.1 is considered legal.\n  const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n  const ipv4Regexes = {\n    fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n    longValue: new RegExp(`^${ipv4Part}$`, 'i')\n  };\n\n  // Regular Expression for checking Octal numbers\n  const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n  const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n  const zoneIndex = '%[0-9a-z]{1,}';\n\n  // IPv6-matching regular expressions.\n  // For IPv6, the task is simpler: it is enough to match the colon-delimited\n  // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n  // the end.\n  const ipv6Part = '(?:[0-9a-f]+::?)+';\n  const ipv6Regexes = {\n    zoneIndex: new RegExp(zoneIndex, 'i'),\n    'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n    deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n    transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n  };\n\n  // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n  function expandIPv6(string, parts) {\n    // More than one '::' means invalid adddress\n    if (string.indexOf('::') !== string.lastIndexOf('::')) {\n      return null;\n    }\n    let colonCount = 0;\n    let lastColon = -1;\n    let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n    let replacement, replacementCount;\n\n    // Remove zone index and save it for later\n    if (zoneId) {\n      zoneId = zoneId.substring(1);\n      string = string.replace(/%.+$/, '');\n    }\n\n    // How many parts do we already have?\n    while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n      colonCount++;\n    }\n\n    // 0::0 is two parts more than ::\n    if (string.substr(0, 2) === '::') {\n      colonCount--;\n    }\n    if (string.substr(-2, 2) === '::') {\n      colonCount--;\n    }\n\n    // The following loop would hang if colonCount > parts\n    if (colonCount > parts) {\n      return null;\n    }\n\n    // replacement = ':' + '0:' * (parts - colonCount)\n    replacementCount = parts - colonCount;\n    replacement = ':';\n    while (replacementCount--) {\n      replacement += '0:';\n    }\n\n    // Insert the missing zeroes\n    string = string.replace('::', replacement);\n\n    // Trim any garbage which may be hanging around if :: was at the edge in\n    // the source strin\n    if (string[0] === ':') {\n      string = string.slice(1);\n    }\n    if (string[string.length - 1] === ':') {\n      string = string.slice(0, -1);\n    }\n    parts = function () {\n      const ref = string.split(':');\n      const results = [];\n      for (let i = 0; i < ref.length; i++) {\n        results.push(parseInt(ref[i], 16));\n      }\n      return results;\n    }();\n    return {\n      parts: parts,\n      zoneId: zoneId\n    };\n  }\n\n  // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n  function matchCIDR(first, second, partSize, cidrBits) {\n    if (first.length !== second.length) {\n      throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n    }\n    let part = 0;\n    let shift;\n    while (cidrBits > 0) {\n      shift = partSize - cidrBits;\n      if (shift < 0) {\n        shift = 0;\n      }\n      if (first[part] >> shift !== second[part] >> shift) {\n        return false;\n      }\n      cidrBits -= partSize;\n      part += 1;\n    }\n    return true;\n  }\n  function parseIntAuto(string) {\n    // Hexadedimal base 16 (0x#)\n    if (hexRegex.test(string)) {\n      return parseInt(string, 16);\n    }\n    // While octal representation is discouraged by ECMAScript 3\n    // and forbidden by ECMAScript 5, we silently allow it to\n    // work only if the rest of the string has numbers less than 8.\n    if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n      if (octalRegex.test(string)) {\n        return parseInt(string, 8);\n      }\n      throw new Error(`ipaddr: cannot parse ${string} as octal`);\n    }\n    // Always include the base 10 radix!\n    return parseInt(string, 10);\n  }\n  function padPart(part, length) {\n    while (part.length < length) {\n      part = `0${part}`;\n    }\n    return part;\n  }\n  const ipaddr = {};\n\n  // An IPv4 address (RFC791).\n  ipaddr.IPv4 = function () {\n    // Constructs a new IPv4 address from an array of four octets\n    // in network order (MSB first)\n    // Verifies the input.\n    function IPv4(octets) {\n      if (octets.length !== 4) {\n        throw new Error('ipaddr: ipv4 octet count should be 4');\n      }\n      let i, octet;\n      for (i = 0; i < octets.length; i++) {\n        octet = octets[i];\n        if (!(0 <= octet && octet <= 255)) {\n          throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n        }\n      }\n      this.octets = octets;\n    }\n\n    // Special IPv4 address ranges.\n    // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n    IPv4.prototype.SpecialRanges = {\n      unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n      broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n      // RFC3171\n      multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n      // RFC3927\n      linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n      // RFC5735\n      loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n      // RFC6598\n      carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n      // RFC1918\n      'private': [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],\n      // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n      reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 18, 0, 0]), 15], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]],\n      // RFC7534, RFC7535\n      as112: [[new IPv4([192, 175, 48, 0]), 24], [new IPv4([192, 31, 196, 0]), 24]],\n      // RFC7450\n      amt: [[new IPv4([192, 52, 193, 0]), 24]]\n    };\n\n    // The 'kind' method exists on both IPv4 and IPv6 classes.\n    IPv4.prototype.kind = function () {\n      return 'ipv4';\n    };\n\n    // Checks if this address matches other one within given CIDR range.\n    IPv4.prototype.match = function (other, cidrRange) {\n      let ref;\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv4') {\n        throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n      }\n      return matchCIDR(this.octets, other.octets, 8, cidrRange);\n    };\n\n    // returns a number of leading ones in IPv4 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n    IPv4.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0;\n      // non-zero encountered stop scanning for zeroes\n      let stop = false;\n      // number of zeroes in octet\n      const zerotable = {\n        0: 8,\n        128: 7,\n        192: 6,\n        224: 5,\n        240: 4,\n        248: 3,\n        252: 2,\n        254: 1,\n        255: 0\n      };\n      let i, octet, zeros;\n      for (i = 3; i >= 0; i -= 1) {\n        octet = this.octets[i];\n        if (octet in zerotable) {\n          zeros = zerotable[octet];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 8) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 32 - cidr;\n    };\n\n    // Checks if the address corresponds to one of the special ranges.\n    IPv4.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    // Returns an array of byte-sized values in network order (MSB first)\n    IPv4.prototype.toByteArray = function () {\n      return this.octets.slice(0);\n    };\n\n    // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n    IPv4.prototype.toIPv4MappedAddress = function () {\n      return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n    };\n\n    // Symmetrical method strictly for aligning with the IPv6 methods.\n    IPv4.prototype.toNormalizedString = function () {\n      return this.toString();\n    };\n\n    // Returns the address in convenient, decimal-dotted format.\n    IPv4.prototype.toString = function () {\n      return this.octets.join('.');\n    };\n    return IPv4;\n  }();\n\n  // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n  ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n      while (i < 4) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  // Checks if a given string is formatted like IPv4 address.\n  ipaddr.IPv4.isIPv4 = function (string) {\n    return this.parser(string) !== null;\n  };\n\n  // Checks if a given string is a valid IPv4 address.\n  ipaddr.IPv4.isValid = function (string) {\n    try {\n      new this(this.parser(string));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a valid IPv4 address in CIDR notation.\n  ipaddr.IPv4.isValidCIDR = function (string) {\n    try {\n      this.parseCIDR(string);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a full four-part IPv4 Address.\n  ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n    if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n  ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 4) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n    }\n  };\n\n  // Tries to parse and validate a string with IPv4 address.\n  // Throws an error if it fails.\n  ipaddr.IPv4.parse = function (string) {\n    const parts = this.parser(string);\n    if (parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n    }\n    return new this(parts);\n  };\n\n  // Parses the string as an IPv4 Address with CIDR Notation.\n  ipaddr.IPv4.parseCIDR = function (string) {\n    let match;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      const maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 32) {\n        const parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n  };\n\n  // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n  // value representing last three octets; this corresponds to a class C\n  // address) are omitted due to classless nature of modern Internet.\n  ipaddr.IPv4.parser = function (string) {\n    let match, part, value;\n\n    // parseInt recognizes all that octal & hexadecimal weirdness for us\n    if (match = string.match(ipv4Regexes.fourOctet)) {\n      return function () {\n        const ref = match.slice(1, 6);\n        const results = [];\n        for (let i = 0; i < ref.length; i++) {\n          part = ref[i];\n          results.push(parseIntAuto(part));\n        }\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.longValue)) {\n      value = parseIntAuto(match[1]);\n      if (value > 0xffffffff || value < 0) {\n        throw new Error('ipaddr: address outside defined range');\n      }\n      return function () {\n        const results = [];\n        let shift;\n        for (shift = 0; shift <= 24; shift += 8) {\n          results.push(value >> shift & 0xff);\n        }\n        return results;\n      }().reverse();\n    } else if (match = string.match(ipv4Regexes.twoOctet)) {\n      return function () {\n        const ref = match.slice(1, 4);\n        const results = [];\n        value = parseIntAuto(ref[1]);\n        if (value > 0xffffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n        results.push(parseIntAuto(ref[0]));\n        results.push(value >> 16 & 0xff);\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else if (match = string.match(ipv4Regexes.threeOctet)) {\n      return function () {\n        const ref = match.slice(1, 5);\n        const results = [];\n        value = parseIntAuto(ref[2]);\n        if (value > 0xffff || value < 0) {\n          throw new Error('ipaddr: address outside defined range');\n        }\n        results.push(parseIntAuto(ref[0]));\n        results.push(parseIntAuto(ref[1]));\n        results.push(value >> 8 & 0xff);\n        results.push(value & 0xff);\n        return results;\n      }();\n    } else {\n      return null;\n    }\n  };\n\n  // A utility function to return subnet mask in IPv4 format given the prefix length\n  ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 32) {\n      throw new Error('ipaddr: invalid IPv4 prefix length');\n    }\n    const octets = [0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 4) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n    return new this(octets);\n  };\n\n  // An IPv6 address (RFC2460)\n  ipaddr.IPv6 = function () {\n    // Constructs an IPv6 address from an array of eight 16 - bit parts\n    // or sixteen 8 - bit parts in network order(MSB first).\n    // Throws an error if the input is invalid.\n    function IPv6(parts, zoneId) {\n      let i, part;\n      if (parts.length === 16) {\n        this.parts = [];\n        for (i = 0; i <= 14; i += 2) {\n          this.parts.push(parts[i] << 8 | parts[i + 1]);\n        }\n      } else if (parts.length === 8) {\n        this.parts = parts;\n      } else {\n        throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n      }\n      for (i = 0; i < this.parts.length; i++) {\n        part = this.parts[i];\n        if (!(0 <= part && part <= 0xffff)) {\n          throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n        }\n      }\n      if (zoneId) {\n        this.zoneId = zoneId;\n      }\n    }\n\n    // Special IPv6 ranges\n    IPv6.prototype.SpecialRanges = {\n      // RFC4291, here and after\n      unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n      linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n      multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n      loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n      uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n      ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n      // RFC6666\n      discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n      // RFC6145\n      rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n      // RFC6052\n      rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n      // RFC3056\n      '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n      // RFC6052, RFC6146\n      teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n      // RFC5180\n      benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n      // RFC7450\n      amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n      as112v6: [[new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48], [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48]],\n      deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n      orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n      droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n      reserved: [\n      // RFC3849\n      [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n      // RFC2928\n      [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32]]\n    };\n\n    // Checks if this address is an IPv4-mapped IPv6 address.\n    IPv6.prototype.isIPv4MappedAddress = function () {\n      return this.range() === 'ipv4Mapped';\n    };\n\n    // The 'kind' method exists on both IPv4 and IPv6 classes.\n    IPv6.prototype.kind = function () {\n      return 'ipv6';\n    };\n\n    // Checks if this address matches other one within given CIDR range.\n    IPv6.prototype.match = function (other, cidrRange) {\n      let ref;\n      if (cidrRange === undefined) {\n        ref = other;\n        other = ref[0];\n        cidrRange = ref[1];\n      }\n      if (other.kind() !== 'ipv6') {\n        throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n      }\n      return matchCIDR(this.parts, other.parts, 16, cidrRange);\n    };\n\n    // returns a number of leading ones in IPv6 address, making sure that\n    // the rest is a solid sequence of 0's (valid netmask)\n    // returns either the CIDR length or null if mask is not valid\n    IPv6.prototype.prefixLengthFromSubnetMask = function () {\n      let cidr = 0;\n      // non-zero encountered stop scanning for zeroes\n      let stop = false;\n      // number of zeroes in octet\n      const zerotable = {\n        0: 16,\n        32768: 15,\n        49152: 14,\n        57344: 13,\n        61440: 12,\n        63488: 11,\n        64512: 10,\n        65024: 9,\n        65280: 8,\n        65408: 7,\n        65472: 6,\n        65504: 5,\n        65520: 4,\n        65528: 3,\n        65532: 2,\n        65534: 1,\n        65535: 0\n      };\n      let part, zeros;\n      for (let i = 7; i >= 0; i -= 1) {\n        part = this.parts[i];\n        if (part in zerotable) {\n          zeros = zerotable[part];\n          if (stop && zeros !== 0) {\n            return null;\n          }\n          if (zeros !== 16) {\n            stop = true;\n          }\n          cidr += zeros;\n        } else {\n          return null;\n        }\n      }\n      return 128 - cidr;\n    };\n\n    // Checks if the address corresponds to one of the special ranges.\n    IPv6.prototype.range = function () {\n      return ipaddr.subnetMatch(this, this.SpecialRanges);\n    };\n\n    // Returns an array of byte-sized values in network order (MSB first)\n    IPv6.prototype.toByteArray = function () {\n      let part;\n      const bytes = [];\n      const ref = this.parts;\n      for (let i = 0; i < ref.length; i++) {\n        part = ref[i];\n        bytes.push(part >> 8);\n        bytes.push(part & 0xff);\n      }\n      return bytes;\n    };\n\n    // Returns the address in expanded format with all zeroes included, like\n    // 2001:0db8:0008:0066:0000:0000:0000:0001\n    IPv6.prototype.toFixedLengthString = function () {\n      const addr = function () {\n        const results = [];\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(padPart(this.parts[i].toString(16), 4));\n        }\n        return results;\n      }.call(this).join(':');\n      let suffix = '';\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n      return addr + suffix;\n    };\n\n    // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n    // Throws an error otherwise.\n    IPv6.prototype.toIPv4Address = function () {\n      if (!this.isIPv4MappedAddress()) {\n        throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n      }\n      const ref = this.parts.slice(-2);\n      const high = ref[0];\n      const low = ref[1];\n      return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n    };\n\n    // Returns the address in expanded format with all zeroes included, like\n    // 2001:db8:8:66:0:0:0:1\n    //\n    // Deprecated: use toFixedLengthString() instead.\n    IPv6.prototype.toNormalizedString = function () {\n      const addr = function () {\n        const results = [];\n        for (let i = 0; i < this.parts.length; i++) {\n          results.push(this.parts[i].toString(16));\n        }\n        return results;\n      }.call(this).join(':');\n      let suffix = '';\n      if (this.zoneId) {\n        suffix = `%${this.zoneId}`;\n      }\n      return addr + suffix;\n    };\n\n    // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n    IPv6.prototype.toRFC5952String = function () {\n      const regex = /((^|:)(0(:|$)){2,})/g;\n      const string = this.toNormalizedString();\n      let bestMatchIndex = 0;\n      let bestMatchLength = -1;\n      let match;\n      while (match = regex.exec(string)) {\n        if (match[0].length > bestMatchLength) {\n          bestMatchIndex = match.index;\n          bestMatchLength = match[0].length;\n        }\n      }\n      if (bestMatchLength < 0) {\n        return string;\n      }\n      return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n    };\n\n    // Returns the address in compact, human-readable format like\n    // 2001:db8:8:66::1\n    // Calls toRFC5952String under the hood.\n    IPv6.prototype.toString = function () {\n      return this.toRFC5952String();\n    };\n    return IPv6;\n  }();\n\n  // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n  ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n    try {\n      const cidr = this.parseCIDR(string);\n      const ipInterfaceOctets = cidr[0].toByteArray();\n      const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      const octets = [];\n      let i = 0;\n      while (i < 16) {\n        // Broadcast address is bitwise OR between ip interface and inverted mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  };\n\n  // Checks if a given string is formatted like IPv6 address.\n  ipaddr.IPv6.isIPv6 = function (string) {\n    return this.parser(string) !== null;\n  };\n\n  // Checks to see if string is a valid IPv6 Address\n  ipaddr.IPv6.isValid = function (string) {\n    // Since IPv6.isValid is always called first, this shortcut\n    // provides a substantial performance gain.\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n    try {\n      const addr = this.parser(string);\n      new this(addr.parts, addr.zoneId);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Checks if a given string is a valid IPv6 address in CIDR notation.\n  ipaddr.IPv6.isValidCIDR = function (string) {\n    // See note in IPv6.isValid\n    if (typeof string === 'string' && string.indexOf(':') === -1) {\n      return false;\n    }\n    try {\n      this.parseCIDR(string);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n  ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n    let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n    try {\n      cidr = this.parseCIDR(string);\n      ipInterfaceOctets = cidr[0].toByteArray();\n      subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n      octets = [];\n      i = 0;\n      while (i < 16) {\n        // Network address is bitwise AND between ip interface and mask\n        octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n        i++;\n      }\n      return new this(octets);\n    } catch (e) {\n      throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n    }\n  };\n\n  // Tries to parse and validate a string with IPv6 address.\n  // Throws an error if it fails.\n  ipaddr.IPv6.parse = function (string) {\n    const addr = this.parser(string);\n    if (addr.parts === null) {\n      throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n    }\n    return new this(addr.parts, addr.zoneId);\n  };\n  ipaddr.IPv6.parseCIDR = function (string) {\n    let maskLength, match, parsed;\n    if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n      maskLength = parseInt(match[2]);\n      if (maskLength >= 0 && maskLength <= 128) {\n        parsed = [this.parse(match[1]), maskLength];\n        Object.defineProperty(parsed, 'toString', {\n          value: function () {\n            return this.join('/');\n          }\n        });\n        return parsed;\n      }\n    }\n    throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n  };\n\n  // Parse an IPv6 address.\n  ipaddr.IPv6.parser = function (string) {\n    let addr, i, match, octet, octets, zoneId;\n    if (match = string.match(ipv6Regexes.deprecatedTransitional)) {\n      return this.parser(`::ffff:${match[1]}`);\n    }\n    if (ipv6Regexes.native.test(string)) {\n      return expandIPv6(string, 8);\n    }\n    if (match = string.match(ipv6Regexes.transitional)) {\n      zoneId = match[6] || '';\n      addr = match[1];\n      if (!match[1].endsWith('::')) {\n        addr = addr.slice(0, -1);\n      }\n      addr = expandIPv6(addr + zoneId, 6);\n      if (addr.parts) {\n        octets = [parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseInt(match[5])];\n        for (i = 0; i < octets.length; i++) {\n          octet = octets[i];\n          if (!(0 <= octet && octet <= 255)) {\n            return null;\n          }\n        }\n        addr.parts.push(octets[0] << 8 | octets[1]);\n        addr.parts.push(octets[2] << 8 | octets[3]);\n        return {\n          parts: addr.parts,\n          zoneId: addr.zoneId\n        };\n      }\n    }\n    return null;\n  };\n\n  // A utility function to return subnet mask in IPv6 format given the prefix length\n  ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n    prefix = parseInt(prefix);\n    if (prefix < 0 || prefix > 128) {\n      throw new Error('ipaddr: invalid IPv6 prefix length');\n    }\n    const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    let j = 0;\n    const filledOctetCount = Math.floor(prefix / 8);\n    while (j < filledOctetCount) {\n      octets[j] = 255;\n      j++;\n    }\n    if (filledOctetCount < 16) {\n      octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n    }\n    return new this(octets);\n  };\n\n  // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n  ipaddr.fromByteArray = function (bytes) {\n    const length = bytes.length;\n    if (length === 4) {\n      return new ipaddr.IPv4(bytes);\n    } else if (length === 16) {\n      return new ipaddr.IPv6(bytes);\n    } else {\n      throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n    }\n  };\n\n  // Checks if the address is valid IP address\n  ipaddr.isValid = function (string) {\n    return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n  };\n\n  // Checks if the address is valid IP address in CIDR notation\n  ipaddr.isValidCIDR = function (string) {\n    return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n  };\n\n  // Attempts to parse an IP Address, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n  ipaddr.parse = function (string) {\n    if (ipaddr.IPv6.isValid(string)) {\n      return ipaddr.IPv6.parse(string);\n    } else if (ipaddr.IPv4.isValid(string)) {\n      return ipaddr.IPv4.parse(string);\n    } else {\n      throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n    }\n  };\n\n  // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n  // Throws an error if it could not be parsed.\n  ipaddr.parseCIDR = function (string) {\n    try {\n      return ipaddr.IPv6.parseCIDR(string);\n    } catch (e) {\n      try {\n        return ipaddr.IPv4.parseCIDR(string);\n      } catch (e2) {\n        throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n      }\n    }\n  };\n\n  // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n  ipaddr.process = function (string) {\n    const addr = this.parse(string);\n    if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n      return addr.toIPv4Address();\n    } else {\n      return addr;\n    }\n  };\n\n  // An utility function to ease named range matching. See examples below.\n  // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n  // on matching IPv4 addresses to IPv6 ranges or vice versa.\n  ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n    let i, rangeName, rangeSubnets, subnet;\n    if (defaultName === undefined || defaultName === null) {\n      defaultName = 'unicast';\n    }\n    for (rangeName in rangeList) {\n      if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n        rangeSubnets = rangeList[rangeName];\n        // ECMA5 Array.isArray isn't available everywhere\n        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n          rangeSubnets = [rangeSubnets];\n        }\n        for (i = 0; i < rangeSubnets.length; i++) {\n          subnet = rangeSubnets[i];\n          if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n            return rangeName;\n          }\n        }\n      }\n    }\n    return defaultName;\n  };\n\n  // Export for both the CommonJS and browser-like environment\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = ipaddr;\n  } else {\n    root.ipaddr = ipaddr;\n  }\n})(this);","map":{"version":3,"names":["root","ipv4Part","ipv4Regexes","fourOctet","RegExp","threeOctet","twoOctet","longValue","octalRegex","hexRegex","zoneIndex","ipv6Part","ipv6Regexes","deprecatedTransitional","transitional","expandIPv6","string","parts","indexOf","lastIndexOf","colonCount","lastColon","zoneId","match","replacement","replacementCount","substring","replace","substr","slice","length","ref","split","results","i","push","parseInt","matchCIDR","first","second","partSize","cidrBits","Error","part","shift","parseIntAuto","test","isNaN","padPart","ipaddr","IPv4","octets","octet","prototype","SpecialRanges","unspecified","broadcast","multicast","linkLocal","loopback","carrierGradeNat","reserved","as112","amt","kind","other","cidrRange","undefined","prefixLengthFromSubnetMask","cidr","stop","zerotable","zeros","range","subnetMatch","toByteArray","toIPv4MappedAddress","IPv6","parse","toString","toNormalizedString","join","broadcastAddressFromCIDR","parseCIDR","ipInterfaceOctets","subnetMaskOctets","subnetMaskFromPrefixLength","e","isIPv4","parser","isValid","isValidCIDR","isValidFourPartDecimal","networkAddressFromCIDR","maskLength","parsed","Object","defineProperty","value","reverse","prefix","j","filledOctetCount","Math","floor","pow","uniqueLocal","ipv4Mapped","discard","rfc6145","rfc6052","teredo","benchmarking","as112v6","deprecated","orchid2","droneRemoteIdProtocolEntityTags","isIPv4MappedAddress","bytes","toFixedLengthString","addr","call","suffix","toIPv4Address","high","low","toRFC5952String","regex","bestMatchIndex","bestMatchLength","exec","index","isIPv6","native","endsWith","fromByteArray","e2","process","address","rangeList","defaultName","rangeName","rangeSubnets","subnet","hasOwnProperty","Array","apply","module","exports"],"sources":["/Users/admin/Documents/analytical_engineering/Docker_Analytics_Sandbox/src/react-app/node_modules/ipaddr.js/lib/ipaddr.js"],"sourcesContent":["(function (root) {\n    'use strict';\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = '(0?\\\\d+|0x[a-f0-9]+)';\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, 'i'),\n        longValue: new RegExp(`^${ipv4Part}$`, 'i')\n    };\n\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, 'i');\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, 'i');\n\n    const zoneIndex = '%[0-9a-z]{1,}';\n\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = '(?:[0-9a-f]+::?)+';\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, 'i'),\n        'native': new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, 'i'),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, 'i'),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, 'i')\n    };\n\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6 (string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf('::') !== string.lastIndexOf('::')) {\n            return null;\n        }\n\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, '');\n        }\n\n        // How many parts do we already have?\n        while ((lastColon = string.indexOf(':', lastColon + 1)) >= 0) {\n            colonCount++;\n        }\n\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === '::') {\n            colonCount--;\n        }\n\n        if (string.substr(-2, 2) === '::') {\n            colonCount--;\n        }\n\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = ':';\n        while (replacementCount--) {\n            replacement += '0:';\n        }\n\n        // Insert the missing zeroes\n        string = string.replace('::', replacement);\n\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === ':') {\n            string = string.slice(1);\n        }\n\n        if (string[string.length - 1] === ':') {\n            string = string.slice(0, -1);\n        }\n\n        parts = (function () {\n            const ref = string.split(':');\n            const results = [];\n\n            for (let i = 0; i < ref.length; i++) {\n                results.push(parseInt(ref[i], 16));\n            }\n\n            return results;\n        })();\n\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR (first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error('ipaddr: cannot match CIDR for objects with different lengths');\n        }\n\n        let part = 0;\n        let shift;\n\n        while (cidrBits > 0) {\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n\n            cidrBits -= partSize;\n            part += 1;\n        }\n\n        return true;\n    }\n\n    function parseIntAuto (string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === '0' && !isNaN(parseInt(string[1], 10))) {\n        if (octalRegex.test(string)) {\n            return parseInt(string, 8);\n        }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n\n    function padPart (part, length) {\n        while (part.length < length) {\n            part = `0${part}`;\n        }\n\n        return part;\n    }\n\n    const ipaddr = {};\n\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = (function () {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4 (octets) {\n            if (octets.length !== 4) {\n                throw new Error('ipaddr: ipv4 octet count should be 4');\n            }\n\n            let i, octet;\n\n            for (i = 0; i < octets.length; i++) {\n                octet = octets[i];\n                if (!((0 <= octet && octet <= 255))) {\n                    throw new Error('ipaddr: ipv4 octet should fit in 8 bits');\n                }\n            }\n\n            this.octets = octets;\n        }\n\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],\n            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],\n            // RFC3171\n            multicast: [[new IPv4([224, 0, 0, 0]), 4]],\n            // RFC3927\n            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],\n            // RFC5735\n            loopback: [[new IPv4([127, 0, 0, 0]), 8]],\n            // RFC6598\n            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],\n            // RFC1918\n            'private': [\n                [new IPv4([10, 0, 0, 0]), 8],\n                [new IPv4([172, 16, 0, 0]), 12],\n                [new IPv4([192, 168, 0, 0]), 16]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [new IPv4([192, 0, 0, 0]), 24],\n                [new IPv4([192, 0, 2, 0]), 24],\n                [new IPv4([192, 88, 99, 0]), 24],\n                [new IPv4([198, 18, 0, 0]), 15],\n                [new IPv4([198, 51, 100, 0]), 24],\n                [new IPv4([203, 0, 113, 0]), 24],\n                [new IPv4([240, 0, 0, 0]), 4]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [new IPv4([192, 175, 48, 0]), 24],\n                [new IPv4([192, 31, 196, 0]), 24],\n            ],\n            // RFC7450\n            amt: [\n                [new IPv4([192, 52, 193, 0]), 24],\n            ],\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function () {\n            return 'ipv4';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function (other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv4') {\n                throw new Error('ipaddr: cannot match ipv4 address with non-ipv4 one');\n            }\n\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n\n            for (i = 3; i >= 0; i -= 1) {\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 32 - cidr;\n        };\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function () {\n            return this.octets.slice(0);\n        };\n\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function () {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function () {\n            return this.toString();\n        };\n\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function () {\n            return this.octets.join('.');\n        };\n\n        return IPv4;\n    })();\n\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function (string) {\n\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 4) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function (string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function (string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function (string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 4) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error('ipaddr: the address does not have IPv4 CIDR format');\n        }\n    };\n\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function (string) {\n        const parts = this.parser(string);\n\n        if (parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv4 Address');\n        }\n\n        return new this(parts);\n    };\n\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function (string) {\n        let match;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv4 CIDR range');\n    };\n\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function (string) {\n        let match, part, value;\n\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if ((match = string.match(ipv4Regexes.fourOctet))) {\n            return (function () {\n                const ref = match.slice(1, 6);\n                const results = [];\n\n                for (let i = 0; i < ref.length; i++) {\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.longValue))) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error('ipaddr: address outside defined range');\n            }\n\n            return ((function () {\n                const results = [];\n                let shift;\n\n                for (shift = 0; shift <= 24; shift += 8) {\n                    results.push((value >> shift) & 0xff);\n                }\n\n                return results;\n            })()).reverse();\n        } else if ((match = string.match(ipv4Regexes.twoOctet))) {\n            return (function () {\n                const ref = match.slice(1, 4);\n                const results = [];\n\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push((value >> 16) & 0xff);\n                results.push((value >>  8) & 0xff);\n                results.push( value        & 0xff);\n\n                return results;\n            })();\n        } else if ((match = string.match(ipv4Regexes.threeOctet))) {\n            return (function () {\n                const ref = match.slice(1, 5);\n                const results = [];\n\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error('ipaddr: address outside defined range');\n                }\n\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push((value >> 8) & 0xff);\n                results.push( value       & 0xff);\n\n                return results;\n            })();\n        } else {\n            return null;\n        }\n    };\n\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error('ipaddr: invalid IPv4 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = (function () {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6 (parts, zoneId) {\n            let i, part;\n\n            if (parts.length === 16) {\n                this.parts = [];\n                for (i = 0; i <= 14; i += 2) {\n                    this.parts.push((parts[i] << 8) | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error('ipaddr: ipv6 part count should be 8 or 16');\n            }\n\n            for (i = 0; i < this.parts.length; i++) {\n                part = this.parts[i];\n                if (!((0 <= part && part <= 0xffff))) {\n                    throw new Error('ipaddr: ipv6 part should fit in 16 bits');\n                }\n            }\n\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],\n            linkLocal: [new IPv6([0xfe80, 0, 0, 0, 0, 0, 0, 0]), 10],\n            multicast: [new IPv6([0xff00, 0, 0, 0, 0, 0, 0, 0]), 8],\n            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],\n            uniqueLocal: [new IPv6([0xfc00, 0, 0, 0, 0, 0, 0, 0]), 7],\n            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 0xffff, 0, 0]), 96],\n            // RFC6666\n            discard: [new IPv6([0x100, 0, 0, 0, 0, 0, 0, 0]), 64],\n            // RFC6145\n            rfc6145: [new IPv6([0, 0, 0, 0, 0xffff, 0, 0, 0]), 96],\n            // RFC6052\n            rfc6052: [new IPv6([0x64, 0xff9b, 0, 0, 0, 0, 0, 0]), 96],\n            // RFC3056\n            '6to4': [new IPv6([0x2002, 0, 0, 0, 0, 0, 0, 0]), 16],\n            // RFC6052, RFC6146\n            teredo: [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 32],\n            // RFC5180\n            benchmarking: [new IPv6([0x2001, 0x2, 0, 0, 0, 0, 0, 0]), 48],\n            // RFC7450\n            amt: [new IPv6([0x2001, 0x3, 0, 0, 0, 0, 0, 0]), 32],\n            as112v6: [\n                [new IPv6([0x2001, 0x4, 0x112, 0, 0, 0, 0, 0]), 48],\n                [new IPv6([0x2620, 0x4f, 0x8000, 0, 0, 0, 0, 0]), 48],\n            ],\n            deprecated: [new IPv6([0x2001, 0x10, 0, 0, 0, 0, 0, 0]), 28],\n            orchid2: [new IPv6([0x2001, 0x20, 0, 0, 0, 0, 0, 0]), 28],\n            droneRemoteIdProtocolEntityTags: [new IPv6([0x2001, 0x30, 0, 0, 0, 0, 0, 0]), 28],\n            reserved: [\n                // RFC3849\n                [new IPv6([0x2001, 0, 0, 0, 0, 0, 0, 0]), 23],\n                // RFC2928\n                [new IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]), 32],\n            ],\n        };\n\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function () {\n            return this.range() === 'ipv4Mapped';\n        };\n\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function () {\n            return 'ipv6';\n        };\n\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function (other, cidrRange) {\n            let ref;\n\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n\n            if (other.kind() !== 'ipv6') {\n                throw new Error('ipaddr: cannot match ipv6 address with non-ipv6 one');\n            }\n\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function () {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n\n            for (let i = 7; i >= 0; i -= 1) {\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n\n            return 128 - cidr;\n        };\n\n\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function () {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function () {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for (let i = 0; i < ref.length; i++) {\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n\n            return bytes;\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function () {\n            const addr = ((function () {\n                const results = [];\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function () {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error('ipaddr: trying to convert a generic ipv6 address to ipv4');\n            }\n\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n\n            return new ipaddr.IPv4([high >> 8, high & 0xff, low >> 8, low & 0xff]);\n        };\n\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function () {\n            const addr = ((function () {\n                const results = [];\n\n                for (let i = 0; i < this.parts.length; i++) {\n                    results.push(this.parts[i].toString(16));\n                }\n\n                return results;\n            }).call(this)).join(':');\n\n            let suffix = '';\n\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n\n            return addr + suffix;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function () {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n\n            while ((match = regex.exec(string))) {\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n\n            if (bestMatchLength < 0) {\n                return string;\n            }\n\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function () {\n            return this.toRFC5952String();\n        };\n\n        return IPv6;\n\n    })();\n\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function (string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while (i < 16) {\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function (string) {\n        return this.parser(string) !== null;\n    };\n\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function (string) {\n\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function (string) {\n\n        // See note in IPv6.isValid\n        if (typeof string === 'string' && string.indexOf(':') === -1) {\n            return false;\n        }\n\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function (string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while (i < 16) {\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function (string) {\n        const addr = this.parser(string);\n\n        if (addr.parts === null) {\n            throw new Error('ipaddr: string is not formatted like an IPv6 Address');\n        }\n\n        return new this(addr.parts, addr.zoneId);\n    };\n\n    ipaddr.IPv6.parseCIDR = function (string) {\n        let maskLength, match, parsed;\n\n        if ((match = string.match(/^(.+)\\/(\\d+)$/))) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [this.parse(match[1]), maskLength];\n                Object.defineProperty(parsed, 'toString', {\n                    value: function () {\n                        return this.join('/');\n                    }\n                });\n                return parsed;\n            }\n        }\n\n        throw new Error('ipaddr: string is not formatted like an IPv6 CIDR range');\n    };\n\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function (string) {\n        let addr, i, match, octet, octets, zoneId;\n\n        if ((match = string.match(ipv6Regexes.deprecatedTransitional))) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if ((match = string.match(ipv6Regexes.transitional))) {\n            zoneId = match[6] || '';\n            addr = match[1]\n            if (!match[1].endsWith('::')) {\n                addr = addr.slice(0, -1)\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for (i = 0; i < octets.length; i++) {\n                    octet = octets[i];\n                    if (!((0 <= octet && octet <= 255))) {\n                        return null;\n                    }\n                }\n\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n\n        return null;\n    };\n\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function (prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error('ipaddr: invalid IPv6 prefix length');\n        }\n\n        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n\n        while (j < filledOctetCount) {\n            octets[j] = 255;\n            j++;\n        }\n\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - (prefix % 8);\n        }\n\n        return new this(octets);\n    };\n\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function (bytes) {\n        const length = bytes.length;\n\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error('ipaddr: the binary input is neither an IPv6 nor IPv4 address');\n        }\n    };\n\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function (string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function (string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n\n\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function (string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error('ipaddr: the address has neither IPv6 nor IPv4 format');\n        }\n    };\n\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function (string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error('ipaddr: the address has neither IPv6 nor IPv4 CIDR format');\n            }\n        }\n    };\n\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function (string) {\n        const addr = this.parse(string);\n\n        if (addr.kind() === 'ipv6' && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function (address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = 'unicast';\n        }\n\n        for (rangeName in rangeList) {\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [rangeSubnets];\n                }\n\n                for (i = 0; i < rangeSubnets.length; i++) {\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n\n        return defaultName;\n    };\n\n    // Export for both the CommonJS and browser-like environment\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = ipaddr;\n\n    } else {\n        root.ipaddr = ipaddr;\n    }\n\n}(this));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}